<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Scott Morrison. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Scott Morrison, Floris van Doorn</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import category_theory.limits.limits category_theory.discrete_category</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/discrete_category.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  universes v u</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  open category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  open category_theory.functor</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  open opposite</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  namespace category_theory.limits</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  variables {C : Type u} [𝒞 : category.{v} C]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  include 𝒞</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  variables {J : Type v} [small_category J]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='category_theory.small_category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type v → Type (v+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='A `small_category` has objects and morphisms in the same universe level.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  variable (F : J ⥤ Cᵒᵖ)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Π (C : Type v) [_inst_1 : category_theory.category.{v v} C] (D : Type u) [_inst_2 : category_theory.category.{v u} D], Type (max v u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  instance [has_colimit.{v} F.left_op] : has_limit.{v} F :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  { cone := cone_of_cocone_left_op (colimit.cocone F.left_op),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='category_theory.limits.cone_of_cocone_left_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.colimit.cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.left_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 374, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 694, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 127, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)}, @category_theory.limits.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) → @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_colimit.{v u} J _inst_1 C 𝒞 F], @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D], @category_theory.functor.{v v v u} C 𝒞 (opposite.{u+1} D) (@category_theory.category.opposite.{v u} D 𝒟) → @category_theory.functor.{v v v u} (opposite.{v+1} C) (@category_theory.category.opposite.{v v} C 𝒞) D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23    is_limit :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24    { lift := λ s, (colimit.desc F.left_op (cocone_left_op_of_cone s)).op,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.colimit.desc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.left_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.cocone_left_op_of_cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 710, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 127, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 382, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_colimit.{v u} J _inst_1 C 𝒞 F] (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.colimit.{v u} J _inst_1 C 𝒞 F _inst_3) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D], @category_theory.functor.{v v v u} C 𝒞 (opposite.{u+1} D) (@category_theory.category.opposite.{v u} D 𝒟) → @category_theory.functor.{v v v u} (opposite.{v+1} C) (@category_theory.category.opposite.{v v} C 𝒞) D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)}, @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F → @category_theory.limits.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.has_hom.{v u} C] {X Y : C}, @category_theory.has_hom.hom.{v u} C 𝒞 X Y → @category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.has_hom.opposite.{v u} C 𝒞) (@opposite.op.{u+1} C Y) (@opposite.op.{u+1} C X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25      fac&#x27; := λ s j,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26      begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j))
    (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j)
       (@category_theory.has_hom.hom.op.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.limits.colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)
          (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
          (@category_theory.limits.colimit.desc.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2))))
          F
          (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          j))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       F
       (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27        rw [cone_of_cocone_left_op_π_app, colimit.cocone_ι, ←op_comp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.limits.cone_of_cocone_left_op_π_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.colimit.cocone_ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.op_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 378, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 701, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 56, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)} (c : @category_theory.limits.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)) (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C) (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞))) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F c))) j) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F c))) F (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F c)) j) (@category_theory.has_hom.hom.op.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@opposite.op.{v+1} J j)) (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.category.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.const.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) c)) (@opposite.op.{v+1} J j)) (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.category.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.const.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) c)) (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) c) (@opposite.op.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} [_inst_3 : @category_theory.limits.has_colimit.{v u} J _inst_1 C 𝒞 F] (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.colimit.cocone.{v u} J _inst_1 C 𝒞 F _inst_3))) j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.colimit.cocone.{v u} J _inst_1 C 𝒞 F _inst_3))) (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.colimit.cocone.{v u} J _inst_1 C 𝒞 F _inst_3)) j) (@category_theory.limits.colimit.ι.{v u} J _inst_1 C 𝒞 F _inst_3 j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y Z : C} {f : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y} {g : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) Y Z}, @eq.{v+1} (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.has_hom.opposite.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))) (@opposite.op.{u+1} C Z) (@opposite.op.{u+1} C X)) (@category_theory.has_hom.hom.op.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Z (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X Y Z f g)) (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C) (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@opposite.op.{u+1} C Z) (@opposite.op.{u+1} C Y) (@opposite.op.{u+1} C X) (@category_theory.has_hom.hom.op.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) Y Z g) (@category_theory.has_hom.hom.op.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j))
    (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j)
       (@category_theory.has_hom.hom.op.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.limits.colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)
          (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
          (@category_theory.limits.colimit.desc.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2))))
          F
          (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          j))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       F
       (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j))
    (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j)
       (@category_theory.has_hom.hom.op.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.limits.colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)
          (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
          (@category_theory.limits.colimit.desc.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
       (@category_theory.has_hom.hom.op.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@opposite.op.{v+1} J j))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             (@opposite.op.{v+1} J j))
          (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2))
             (@opposite.op.{v+1} J j))))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       F
       (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j))
    (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j)
       (@category_theory.has_hom.hom.op.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.limits.colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)
          (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
          (@category_theory.limits.colimit.desc.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
       (@category_theory.has_hom.hom.op.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@opposite.op.{v+1} J j))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             (@opposite.op.{v+1} J j))
          (@category_theory.limits.colimit.ι.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2
             (@opposite.op.{v+1} J j))))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       F
       (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j))
    (@category_theory.has_hom.hom.op.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@opposite.op.{v+1} J j))
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@opposite.op.{v+1} J j))
          (@category_theory.limits.colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)
          (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
          (@category_theory.limits.colimit.ι.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2
             (@opposite.op.{v+1} J j))
          (@category_theory.limits.colimit.desc.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       F
       (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28            colimit.ι_desc, cocone_left_op_of_cone_ι_app, has_hom.hom.op_unop],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.limits.colimit.ι_desc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.cocone_left_op_of_cone_ι_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom.op_unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 726, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 386, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} [_inst_3 : @category_theory.limits.has_colimit.{v u} J _inst_1 C 𝒞 F] (c : @category_theory.limits.cocone.{v u} J _inst_1 C 𝒞 F) (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c)) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.limits.colimit.{v u} J _inst_1 C 𝒞 F _inst_3) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.limits.colimit.ι.{v u} J _inst_1 C 𝒞 F _inst_3 j) (@category_theory.limits.colimit.desc.{v u} J _inst_1 C 𝒞 F _inst_3 c)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F c)) (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F c) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)} (c : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F) (j : opposite.{v+1} J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) j) (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.category.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.const.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F c))) j)) (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.category.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.const.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F c))) (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F c)) j) (@category_theory.has_hom.hom.unop.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F c)) (@opposite.unop.{v+1} J j)) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@opposite.unop.{v+1} J j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F c)) F (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F c) (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u} [𝒞 : category_theory.has_hom.{v u} C] {X Y : opposite.{u+1} C} {f : @category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.has_hom.opposite.{v u} C 𝒞) X Y}, @eq.{v+1} (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.has_hom.opposite.{v u} C 𝒞) (@opposite.op.{u+1} C (@opposite.unop.{u+1} C X)) (@opposite.op.{u+1} C (@opposite.unop.{u+1} C Y))) (@category_theory.has_hom.hom.op.{v u} C 𝒞 (@opposite.unop.{u+1} C Y) (@opposite.unop.{u+1} C X) (@category_theory.has_hom.hom.unop.{v u} C 𝒞 X Y f)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='We have lots of lemmas describing how to simplify `colimit.ι F j ≫ _`,
and combined with `colimit.ext` we rely on these lemmas for many calculations.

However, since `category.assoc` is a `@[simp]` lemma, often expressions are
right associated, and it&#x27;s hard to apply these lemmas about `colimit.ι`.

We thus use `reassoc` to define additional `@[simp]` lemmas, with an arbitrary extra morphism.
(see `tactic/reassoc_axiom.lean`)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j))
    (@category_theory.has_hom.hom.op.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@opposite.op.{v+1} J j))
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@opposite.op.{v+1} J j))
          (@category_theory.limits.colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)
          (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
          (@category_theory.limits.colimit.ι.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2
             (@opposite.op.{v+1} J j))
          (@category_theory.limits.colimit.desc.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       F
       (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j))
    (@category_theory.has_hom.hom.op.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@opposite.op.{v+1} J j))
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
          (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
          (@opposite.op.{v+1} J j)))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       F
       (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j))
    (@category_theory.has_hom.hom.op.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@opposite.op.{v+1} J j))
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.has_hom.hom.unop.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞))
                (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞))
                (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞))
                (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   F
                   s))
             (@opposite.unop.{v+1} J (@opposite.op.{v+1} J j)))
          (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@opposite.unop.{v+1} J (@opposite.op.{v+1} J j)))
          (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞))
                (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞))
                (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞))
                (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   F
                   s))
             F
             (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                s)
             (@opposite.unop.{v+1} J (@opposite.op.{v+1} J j)))))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       F
       (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       F
       (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@opposite.unop.{v+1} J (@opposite.op.{v+1} J j)))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       F
       (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29        refl, end,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       F
       (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@opposite.unop.{v+1} J (@opposite.op.{v+1} J j)))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       F
       (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30      uniq&#x27; := λ s m w,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C) (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞))) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C) (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞))) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F j)) (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C) (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2))) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F j) m (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2)))) F (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2))) j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s)) F (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31      begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s)
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
               (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  _inst_2)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         m
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            F
            (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         F
         (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j)
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2))))
    m
    (@category_theory.has_hom.hom.op.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.limits.colimit.desc.{v u} (opposite.{v+1} J)
          (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32        -- It&#x27;s a pity we can&#x27;t do this automatically.</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s)
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
               (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  _inst_2)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         m
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            F
            (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         F
         (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j)
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2))))
    m
    (@category_theory.has_hom.hom.op.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.limits.colimit.desc.{v u} (opposite.{v+1} J)
          (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33        -- Usually something like this would work by limit.hom_ext,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s)
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
               (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  _inst_2)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         m
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            F
            (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         F
         (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j)
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2))))
    m
    (@category_theory.has_hom.hom.op.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.limits.colimit.desc.{v u} (opposite.{v+1} J)
          (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34        -- but the opposites get in the way of this firing.</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s)
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
               (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  _inst_2)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         m
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            F
            (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         F
         (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j)
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2))))
    m
    (@category_theory.has_hom.hom.op.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.limits.colimit.desc.{v u} (opposite.{v+1} J)
          (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35        have u := (colimit.is_colimit F.left_op).uniq (cocone_left_op_of_cone s) (m.unop),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.limits.colimit.is_colimit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.limits.cocone_left_op_of_cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 707, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 127, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 382, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_colimit.{v u} J _inst_1 C 𝒞 F], @category_theory.limits.is_colimit.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.colimit.cocone.{v u} J _inst_1 C 𝒞 F _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)}, @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F → @category_theory.limits.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C) (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞))) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s)
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
               (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  _inst_2)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         m
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            F
            (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         F
         (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j)
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2))))
    m
    (@category_theory.has_hom.hom.op.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.limits.colimit.desc.{v u} (opposite.{v+1} J)
          (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s)
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
               (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  _inst_2)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         m
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            F
            (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         F
         (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j),
u :
  (∀ (j : opposite.{v+1} J),
     @eq.{v+1}
       (@category_theory.has_hom.hom.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             j)
          (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             j)
          (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2))
          (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
          (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2))
             j)
          (@category_theory.has_hom.hom.unop.{v u} C
             (@category_theory.category_struct.to_has_hom.{v u} C
                (@category_theory.category.to_category_struct.{v u} C 𝒞))
             (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                s)
             (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             m))
       (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
          (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
          j)) →
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2)))
       m)
    (@category_theory.limits.is_colimit.desc.{v u} (opposite.{v+1} J)
       (@category_theory.category.opposite.{v v} J _inst_1)
       C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
          (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2)
       (@category_theory.limits.colimit.is_colimit.{v u} (opposite.{v+1} J)
          (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2)
       (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2))))
    m
    (@category_theory.has_hom.hom.op.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.limits.colimit.desc.{v u} (opposite.{v+1} J)
          (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36        convert congr_arg (λ f : _ ⟶ _, f.op) (u _), clear u,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.has_hom.hom.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1318, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type v} {a₁ a₂ : α} (f : α → β), @eq.{v+1} α a₁ a₂ → @eq.{v+1} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {obj : Type u} [c : category_theory.has_hom.{v u} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.has_hom.{v u} C] {X Y : C}, @category_theory.has_hom.hom.{v u} C 𝒞 X Y → @category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.has_hom.opposite.{v u} C 𝒞) (@opposite.op.{u+1} C Y) (@opposite.op.{u+1} C X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='(∀ (j : opposite.{v+1} J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) j) (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) j) (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2)) (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)) (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.category.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.const.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2))) (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2)) j) (@category_theory.has_hom.hom.unop.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2))) m)) (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.category.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.const.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))) (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)) j)) → @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2)) (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))) (@category_theory.has_hom.hom.unop.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2))) m) (@category_theory.limits.is_colimit.desc.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2) (@category_theory.limits.colimit.is_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2) (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`clear h₁ ... hₙ` tries to clear each hypothesis `hᵢ` from the local context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='clear'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s)
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
               (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  _inst_2)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         m
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            F
            (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         F
         (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j),
u :
  (∀ (j : opposite.{v+1} J),
     @eq.{v+1}
       (@category_theory.has_hom.hom.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             j)
          (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             j)
          (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2))
          (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
          (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2))
             j)
          (@category_theory.has_hom.hom.unop.{v u} C
             (@category_theory.category_struct.to_has_hom.{v u} C
                (@category_theory.category.to_category_struct.{v u} C 𝒞))
             (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                s)
             (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             m))
       (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
          (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
          j)) →
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2)))
       m)
    (@category_theory.limits.is_colimit.desc.{v u} (opposite.{v+1} J)
       (@category_theory.category.opposite.{v v} J _inst_1)
       C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
          (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2)
       (@category_theory.limits.colimit.is_colimit.{v u} (opposite.{v+1} J)
          (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2)
       (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2))))
    m
    (@category_theory.has_hom.hom.op.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.limits.colimit.desc.{v u} (opposite.{v+1} J)
          (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s)
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
               (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  _inst_2)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         m
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            F
            (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         F
         (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j),
u :
  (∀ (j : opposite.{v+1} J),
     @eq.{v+1}
       (@category_theory.has_hom.hom.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             j)
          (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             j)
          (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2))
          (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
          (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2))
             j)
          (@category_theory.has_hom.hom.unop.{v u} C
             (@category_theory.category_struct.to_has_hom.{v u} C
                (@category_theory.category.to_category_struct.{v u} C 𝒞))
             (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                s)
             (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             m))
       (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
          (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
          j)) →
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2)))
       m)
    (@category_theory.limits.is_colimit.desc.{v u} (opposite.{v+1} J)
       (@category_theory.category.opposite.{v v} J _inst_1)
       C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
          (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2)
       (@category_theory.limits.colimit.is_colimit.{v u} (opposite.{v+1} J)
          (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2)
       (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
⊢ ∀ (j : opposite.{v+1} J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} C
         (@category_theory.category_struct.to_has_hom.{v u} C
            (@category_theory.category.to_category_struct.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            j)
         (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
      (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            j)
         (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞
               (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
               _inst_2))
         (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
         (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J)
            (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
               (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞)
               (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞)
               (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞)
               (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞
               (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  _inst_2))
            j)
         (@category_theory.has_hom.hom.unop.{v u} C
            (@category_theory.category_struct.to_has_hom.{v u} C
               (@category_theory.category.to_category_struct.{v u} C 𝒞))
            (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s)
            (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            m))
      (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
         C
         𝒞
         (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
            (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞)
            (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞)
            (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞)
            (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞
               (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
         (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J)
            (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
         j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s)
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
               (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  _inst_2)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         m
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            F
            (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         F
         (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j)
⊢ ∀ (j : opposite.{v+1} J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} C
         (@category_theory.category_struct.to_has_hom.{v u} C
            (@category_theory.category.to_category_struct.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            j)
         (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
      (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            j)
         (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞
               (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
               _inst_2))
         (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
         (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J)
            (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
               (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞)
               (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞)
               (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞)
               (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞
               (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  _inst_2))
            j)
         (@category_theory.has_hom.hom.unop.{v u} C
            (@category_theory.category_struct.to_has_hom.{v u} C
               (@category_theory.category.to_category_struct.{v u} C 𝒞))
            (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s)
            (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            m))
      (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
         C
         𝒞
         (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
            (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞)
            (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞)
            (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞)
            (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞
               (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
         (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J)
            (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
         j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37        intro j,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s)
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
               (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  _inst_2)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         m
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            F
            (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         F
         (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j)
⊢ ∀ (j : opposite.{v+1} J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} C
         (@category_theory.category_struct.to_has_hom.{v u} C
            (@category_theory.category.to_category_struct.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            j)
         (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
      (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            j)
         (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞
               (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
               _inst_2))
         (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
         (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J)
            (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
               (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞)
               (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞)
               (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞)
               (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞
               (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  _inst_2))
            j)
         (@category_theory.has_hom.hom.unop.{v u} C
            (@category_theory.category_struct.to_has_hom.{v u} C
               (@category_theory.category.to_category_struct.{v u} C 𝒞))
            (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s)
            (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            m))
      (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
         C
         𝒞
         (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
            (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞)
            (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞)
            (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞)
            (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞
               (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
         (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J)
            (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
         j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s)
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
               (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  _inst_2)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         m
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            F
            (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         F
         (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2))
          j)
       (@category_theory.has_hom.hom.unop.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s)
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          m))
    (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
          (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
             𝒞)
          (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞)
          (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞)
          (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
       (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38        rw [cocone_left_op_of_cone_ι_app, colimit.cocone_ι],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.limits.cocone_left_op_of_cone_ι_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.colimit.cocone_ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 386, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 701, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)} (c : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F) (j : opposite.{v+1} J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) j) (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.category.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.const.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F c))) j)) (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.category.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.const.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F c))) (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F c)) j) (@category_theory.has_hom.hom.unop.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F c)) (@opposite.unop.{v+1} J j)) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@opposite.unop.{v+1} J j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F c)) F (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F c) (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} [_inst_3 : @category_theory.limits.has_colimit.{v u} J _inst_1 C 𝒞 F] (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.colimit.cocone.{v u} J _inst_1 C 𝒞 F _inst_3))) j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.colimit.cocone.{v u} J _inst_1 C 𝒞 F _inst_3))) (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.colimit.cocone.{v u} J _inst_1 C 𝒞 F _inst_3)) j) (@category_theory.limits.colimit.ι.{v u} J _inst_1 C 𝒞 F _inst_3 j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s)
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
               (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  _inst_2)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         m
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            F
            (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         F
         (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2))
          j)
       (@category_theory.has_hom.hom.unop.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s)
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          m))
    (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
          (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
             𝒞)
          (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞)
          (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞)
          (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
       (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s)
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
               (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  _inst_2)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         m
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            F
            (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         F
         (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2))
          j)
       (@category_theory.has_hom.hom.unop.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s)
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          m))
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                s))
          (@opposite.unop.{v+1} J j))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@opposite.unop.{v+1} J j))
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                s))
          F
          (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s)
          (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s)
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
               (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  _inst_2)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         m
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            F
            (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         F
         (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.limits.colimit.ι.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2
          j)
       (@category_theory.has_hom.hom.unop.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s)
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          m))
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                s))
          (@opposite.unop.{v+1} J j))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@opposite.unop.{v+1} J j))
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                s))
          F
          (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s)
          (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39        convert congr_arg (λ f : _ ⟶ _, f.unop) (w (unop j)), clear w,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.has_hom.hom.unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='opposite.unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1318, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type v} {a₁ a₂ : α} (f : α → β), @eq.{v+1} α a₁ a₂ → @eq.{v+1} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.has_hom.opposite.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@opposite.unop.{v+1} J j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.has_hom.{v u} C] {X Y : opposite.{u+1} C}, @category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.has_hom.opposite.{v u} C 𝒞) X Y → @category_theory.has_hom.hom.{v u} C 𝒞 (@opposite.unop.{u+1} C Y) (@opposite.unop.{u+1} C X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C) (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞))) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F j)) (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C) (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2))) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F j) m (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2)))) F (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2))) j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s)) F (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, opposite.{v+1} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='opposite.{v+1} J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`clear h₁ ... hₙ` tries to clear each hypothesis `hᵢ` from the local context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='clear'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s)
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
               (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  _inst_2)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         m
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            F
            (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         F
         (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s)))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cocone_left_op_of_cone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.limits.colimit.ι.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2
          j)
       (@category_theory.has_hom.hom.unop.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s)
          (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          m))
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                s))
          (@opposite.unop.{v+1} J j))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@opposite.unop.{v+1} J j))
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                s))
          F
          (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s)
          (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s)
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
               (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  _inst_2)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         m
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            F
            (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j))
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         F
         (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.colimit.ι.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       _inst_2
       j)
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@opposite.unop.{v+1} J j))
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2))))
          F
          (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s)
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.colimit.ι.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       _inst_2
       j)
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@opposite.unop.{v+1} J j))
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2))))
          F
          (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40        rw [cone_of_cocone_left_op_π_app, colimit.cocone_ι, has_hom.hom.unop_op],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.limits.cone_of_cocone_left_op_π_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.colimit.cocone_ι'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom.unop_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 378, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 701, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)} (c : @category_theory.limits.cocone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)) (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C) (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞))) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F c))) j) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F c))) F (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F c)) j) (@category_theory.has_hom.hom.op.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@opposite.op.{v+1} J j)) (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.category.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.const.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) c)) (@opposite.op.{v+1} J j)) (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.category.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.const.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) c)) (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) c) (@opposite.op.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} [_inst_3 : @category_theory.limits.has_colimit.{v u} J _inst_1 C 𝒞 F] (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.colimit.cocone.{v u} J _inst_1 C 𝒞 F _inst_3))) j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 F (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cocone.X.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.colimit.cocone.{v u} J _inst_1 C 𝒞 F _inst_3))) (@category_theory.limits.cocone.ι.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.colimit.cocone.{v u} J _inst_1 C 𝒞 F _inst_3)) j) (@category_theory.limits.colimit.ι.{v u} J _inst_1 C 𝒞 F _inst_3 j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u} [𝒞 : category_theory.has_hom.{v u} C] {X Y : C} {f : @category_theory.has_hom.hom.{v u} C 𝒞 X Y}, @eq.{v+1} (@category_theory.has_hom.hom.{v u} C 𝒞 (@opposite.unop.{u+1} C (@opposite.op.{u+1} C X)) (@opposite.unop.{u+1} C (@opposite.op.{u+1} C Y))) (@category_theory.has_hom.hom.unop.{v u} C 𝒞 (@opposite.op.{u+1} C Y) (@opposite.op.{u+1} C X) (@category_theory.has_hom.hom.op.{v u} C 𝒞 X Y f)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s)
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.colimit.ι.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       _inst_2
       j)
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@opposite.unop.{v+1} J j))
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2))))
          F
          (@category_theory.limits.cone.π.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
                (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s)
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.colimit.ι.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       _inst_2
       j)
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@opposite.unop.{v+1} J j))
       (@category_theory.has_hom.hom.op.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@opposite.op.{v+1} J (@opposite.unop.{v+1} J j)))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             (@opposite.op.{v+1} J (@opposite.unop.{v+1} J j)))
          (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             (@category_theory.limits.cocone.ι.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2))
             (@opposite.op.{v+1} J (@opposite.unop.{v+1} J j)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s)
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.colimit.ι.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       _inst_2
       j)
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@opposite.unop.{v+1} J j))
       (@category_theory.has_hom.hom.op.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@opposite.op.{v+1} J (@opposite.unop.{v+1} J j)))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             (@opposite.op.{v+1} J (@opposite.unop.{v+1} J j)))
          (@category_theory.limits.colimit.ι.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2
             (@opposite.op.{v+1} J (@opposite.unop.{v+1} J j)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s)
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.colimit.ι.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       _inst_2
       j)
    (@category_theory.limits.colimit.ι.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       _inst_2
       (@opposite.op.{v+1} J (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41        refl,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_colimit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
    𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s : @category_theory.limits.cone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s)
    (@category_theory.limits.cone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cone_of_cocone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j)
       (@category_theory.limits.cocone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.colimit.cocone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.colimit.ι.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       _inst_2
       j)
    (@category_theory.limits.colimit.ι.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       _inst_2
       (@opposite.op.{v+1} J (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42      end } }</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  instance [has_colimits_of_shape.{v} Jᵒᵖ C] : has_limits_of_shape.{v} J Cᵒᵖ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.limits.has_colimits_of_shape'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.has_limits_of_shape'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 673, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 412, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π (J : Type v) [_inst_1 : category_theory.small_category.{v} J] (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (J : Type v) [_inst_1 : category_theory.small_category.{v} J] (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`C` has colimits of shape `J` if we have chosen a particular colimit of
 every functor `F : J ⥤ C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`C` has limits of shape `J` if we have chosen a particular limit of
 every functor `F : J ⥤ C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  { has_limit := λ F, by apply_instance }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
_inst_2 :
  @category_theory.limits.has_colimits_of_shape.{v u} (opposite.{v+1} J)
    (@category_theory.category.opposite.{v v} J _inst_1)
    C
    𝒞,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
⊢ @category_theory.limits.has_limit.{v u} J _inst_1 (opposite.{u+1} C)
    (@category_theory.category.opposite.{v u} C 𝒞)
    F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  instance [has_colimits.{v} C] : has_limits.{v} Cᵒᵖ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.limits.has_colimits'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.has_limits'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 677, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 416, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`C` has all (small) colimits if it has colimits of every shape.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`C` has all (small) limits if it has limits of every shape.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  { has_limits_of_shape := λ J 𝒥, by { resetI, apply_instance } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝒥'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.small_category.{v} J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='Reset the instance cache. This allows any new instances
 added to the context to be used in typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='teal'><a title='resetI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
_inst_2 : @category_theory.limits.has_colimits.{v u} C 𝒞,
J : Type v,
𝒥 : category_theory.small_category.{v} J
⊢ @category_theory.limits.has_limits_of_shape.{v u} J 𝒥 (opposite.{u+1} C)
    (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  instance [has_limit.{v} F.left_op] : has_colimit.{v} F :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.limits.has_limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.left_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.has_colimit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 127, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 665, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D], @category_theory.functor.{v v v u} C 𝒞 (opposite.{u+1} D) (@category_theory.category.opposite.{v u} D 𝒟) → @category_theory.functor.{v v v u} (opposite.{v+1} C) (@category_theory.category.opposite.{v v} C 𝒞) D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v v u} J _inst_1 C 𝒞 → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`has_limit F` represents a particular chosen limit of the diagram `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='`has_colimit F` represents a particular chosen colimit of the diagram `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  { cocone := cocone_of_cone_left_op (limit.cone F.left_op),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.limits.cocone_of_cone_left_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.limit.cone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.left_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 390, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 433, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 127, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)}, @category_theory.limits.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) → @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_limit.{v u} J _inst_1 C 𝒞 F], @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D], @category_theory.functor.{v v v u} C 𝒞 (opposite.{u+1} D) (@category_theory.category.opposite.{v u} D 𝒟) → @category_theory.functor.{v v v u} (opposite.{v+1} C) (@category_theory.category.opposite.{v v} C 𝒞) D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52    is_colimit :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53    { desc := λ s, (limit.lift F.left_op (cone_left_op_of_cocone s)).op,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.limits.limit.lift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.left_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.cone_left_op_of_cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 449, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 127, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 398, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_limit.{v u} J _inst_1 C 𝒞 F] (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F), @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.limits.limit.{v u} J _inst_1 C 𝒞 F _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v} [𝒞 : category_theory.category.{v v} C] {D : Type u} [𝒟 : category_theory.category.{v u} D], @category_theory.functor.{v v v u} C 𝒞 (opposite.{u+1} D) (@category_theory.category.opposite.{v u} D 𝒟) → @category_theory.functor.{v v v u} (opposite.{v+1} C) (@category_theory.category.opposite.{v v} C 𝒞) D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)}, @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F → @category_theory.limits.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.has_hom.{v u} C] {X Y : C}, @category_theory.has_hom.hom.{v u} C 𝒞 X Y → @category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.has_hom.opposite.{v u} C 𝒞) (@opposite.op.{u+1} C Y) (@opposite.op.{u+1} C X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54      fac&#x27; := λ s j,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55      begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j)
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s))
    (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2))))
          j)
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2))))
          (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          j)
       (@category_theory.has_hom.hom.op.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
          (@category_theory.limits.limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)
          (@category_theory.limits.limit.lift.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56        rw [cocone_of_cone_left_op_ι_app, limit.cone_π, ←op_comp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.limits.cocone_of_cone_left_op_ι_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.limit.cone_π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.op_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 394, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 440, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 56, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)} (c : @category_theory.limits.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)) (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C) (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞))) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F j) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F c))) j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F c))) (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F c)) j) (@category_theory.has_hom.hom.op.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.category.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.const.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) c)) (@opposite.op.{v+1} J j)) (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@opposite.op.{v+1} J j)) (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.category.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.const.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) c)) (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) c) (@opposite.op.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} [_inst_3 : @category_theory.limits.has_limit.{v u} J _inst_1 C 𝒞 F] (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{v u} J _inst_1 C 𝒞 F _inst_3))) j) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{v u} J _inst_1 C 𝒞 F _inst_3))) F (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{v u} J _inst_1 C 𝒞 F _inst_3)) j) (@category_theory.limits.limit.π.{v u} J _inst_1 C 𝒞 F _inst_3 j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y Z : C} {f : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y} {g : @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) Y Z}, @eq.{v+1} (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.has_hom.opposite.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))) (@opposite.op.{u+1} C Z) (@opposite.op.{u+1} C X)) (@category_theory.has_hom.hom.op.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Z (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) X Y Z f g)) (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C) (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@opposite.op.{u+1} C Z) (@opposite.op.{u+1} C Y) (@opposite.op.{u+1} C X) (@category_theory.has_hom.hom.op.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) Y Z g) (@category_theory.has_hom.hom.op.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j)
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s))
    (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2))))
          j)
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2))))
          (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          j)
       (@category_theory.has_hom.hom.op.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
          (@category_theory.limits.limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)
          (@category_theory.limits.limit.lift.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j)
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s))
    (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2))))
          j)
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.has_hom.hom.op.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             (@opposite.op.{v+1} J j))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@opposite.op.{v+1} J j))
          (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2))
             (@opposite.op.{v+1} J j)))
       (@category_theory.has_hom.hom.op.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
          (@category_theory.limits.limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)
          (@category_theory.limits.limit.lift.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j)
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s))
    (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j)
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2))))
          j)
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@category_theory.has_hom.hom.op.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             (@opposite.op.{v+1} J j))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@opposite.op.{v+1} J j))
          (@category_theory.limits.limit.π.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2
             (@opposite.op.{v+1} J j)))
       (@category_theory.has_hom.hom.op.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
          (@category_theory.limits.limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)
          (@category_theory.limits.limit.lift.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j)
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s))
    (@category_theory.has_hom.hom.op.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@opposite.op.{v+1} J j))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             (@opposite.op.{v+1} J j))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@opposite.op.{v+1} J j))
          (@category_theory.limits.limit.lift.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
          (@category_theory.limits.limit.π.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2
             (@opposite.op.{v+1} J j))))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57            limit.lift_π, cone_left_op_of_cocone_π_app, has_hom.hom.op_unop],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.limits.limit.lift_π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.cone_left_op_of_cocone_π_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom.op_unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 455, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 402, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} [_inst_3 : @category_theory.limits.has_limit.{v u} J _inst_1 C 𝒞 F] (c : @category_theory.limits.cone.{v u} J _inst_1 C 𝒞 F) (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c) (@category_theory.limits.limit.{v u} J _inst_1 C 𝒞 F _inst_3) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j) (@category_theory.limits.limit.lift.{v u} J _inst_1 C 𝒞 F _inst_3 c) (@category_theory.limits.limit.π.{v u} J _inst_1 C 𝒞 F _inst_3 j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F c)) F (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F c) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)} (c : @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F) (j : opposite.{v+1} J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.category.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.const.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F c))) j) (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) j)) (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.category.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.const.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F c))) (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F c)) j) (@category_theory.has_hom.hom.unop.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@opposite.unop.{v+1} J j)) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F c)) (@opposite.unop.{v+1} J j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F c)) (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F c) (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u} [𝒞 : category_theory.has_hom.{v u} C] {X Y : opposite.{u+1} C} {f : @category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.has_hom.opposite.{v u} C 𝒞) X Y}, @eq.{v+1} (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.has_hom.opposite.{v u} C 𝒞) (@opposite.op.{u+1} C (@opposite.unop.{u+1} C X)) (@opposite.op.{u+1} C (@opposite.unop.{u+1} C Y))) (@category_theory.has_hom.hom.op.{v u} C 𝒞 (@opposite.unop.{u+1} C Y) (@opposite.unop.{u+1} C X) (@category_theory.has_hom.hom.unop.{v u} C 𝒞 X Y f)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j)
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s))
    (@category_theory.has_hom.hom.op.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@opposite.op.{v+1} J j))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             (@opposite.op.{v+1} J j))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@opposite.op.{v+1} J j))
          (@category_theory.limits.limit.lift.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
          (@category_theory.limits.limit.π.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2
             (@opposite.op.{v+1} J j))))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j)
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s))
    (@category_theory.has_hom.hom.op.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@opposite.op.{v+1} J j))
       (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s)))
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
          (@opposite.op.{v+1} J j)))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j)
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s))
    (@category_theory.has_hom.hom.op.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@opposite.op.{v+1} J j))
       (@category_theory.has_hom.hom.unop.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@opposite.unop.{v+1} J (@opposite.op.{v+1} J j)))
          (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞))
                (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞))
                (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞))
                (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   F
                   s))
             (@opposite.unop.{v+1} J (@opposite.op.{v+1} J j)))
          (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞))
                (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞))
                (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞))
                (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                   (@category_theory.category.opposite.{v u} C 𝒞)
                   F
                   s))
             (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                s)
             (@opposite.unop.{v+1} J (@opposite.op.{v+1} J j)))))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j)
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@opposite.unop.{v+1} J (@opposite.op.{v+1} J j)))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58        refl, end,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
j : J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          j)
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       (@opposite.unop.{v+1} J (@opposite.op.{v+1} J j)))
    (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞))
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s))
       (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59      uniq&#x27; := λ s m w,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C) (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞))) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2))) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C) (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞))) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F j) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s)) (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C) (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F j) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2)))) j) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s) (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2)))) (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2))) j) m) (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s)) (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60      begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j)
         m)
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         F
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j)
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2)))
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s))
    m
    (@category_theory.has_hom.hom.op.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.limits.limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2)
       (@category_theory.limits.limit.lift.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61        have u := (limit.is_limit F.left_op).uniq (cone_left_op_of_cocone s) (m.unop),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.limits.limit.is_limit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.limits.cone_left_op_of_cocone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 446, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 127, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 398, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] (F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞) [_inst_3 : @category_theory.limits.has_limit.{v u} J _inst_1 C 𝒞 F], @category_theory.limits.is_limit.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{v u} J _inst_1 C 𝒞 F _inst_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)}, @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F → @category_theory.limits.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C) (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞))) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2))) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j)
         m)
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         F
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j)
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2)))
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s))
    m
    (@category_theory.has_hom.hom.op.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.limits.limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2)
       (@category_theory.limits.limit.lift.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j)
         m)
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         F
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j),
u :
  (∀ (j : opposite.{v+1} J),
     @eq.{v+1}
       (@category_theory.has_hom.hom.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             j))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
          (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             j)
          (@category_theory.has_hom.hom.unop.{v u} C
             (@category_theory.category_struct.to_has_hom.{v u} C
                (@category_theory.category.to_category_struct.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                s)
             m)
          (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2))
             j))
       (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s)))
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
          j)) →
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2)))
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       m)
    (@category_theory.limits.is_limit.lift.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
       C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2)
       (@category_theory.limits.limit.is_limit.{v u} (opposite.{v+1} J)
          (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2)
       (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2)))
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s))
    m
    (@category_theory.has_hom.hom.op.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.limits.limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2)
       (@category_theory.limits.limit.lift.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62        convert congr_arg (λ f : _ ⟶ _, f.op) (u _), clear u,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.has_hom.hom.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1318, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type v} {a₁ a₂ : α} (f : α → β), @eq.{v+1} α a₁ a₂ → @eq.{v+1} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {obj : Type u} [c : category_theory.has_hom.{v u} obj], obj → obj → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.has_hom.{v u} C] {X Y : C}, @category_theory.has_hom.hom.{v u} C 𝒞 X Y → @category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.has_hom.opposite.{v u} C 𝒞) (@opposite.op.{u+1} C Y) (@opposite.op.{u+1} C X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='(∀ (j : opposite.{v+1} J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s)) (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) j)) (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞) (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s)) (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2)) (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) j) (@category_theory.has_hom.hom.unop.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2))) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s) m) (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.category.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.const.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2))) (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2)) j)) (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.category.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.const.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))) (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s)) j)) → @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s)) (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2))) (@category_theory.has_hom.hom.unop.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2))) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s) m) (@category_theory.limits.is_limit.lift.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2) (@category_theory.limits.limit.is_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2) (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`clear h₁ ... hₙ` tries to clear each hypothesis `hᵢ` from the local context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='clear'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j)
         m)
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         F
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j),
u :
  (∀ (j : opposite.{v+1} J),
     @eq.{v+1}
       (@category_theory.has_hom.hom.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             j))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
          (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             j)
          (@category_theory.has_hom.hom.unop.{v u} C
             (@category_theory.category_struct.to_has_hom.{v u} C
                (@category_theory.category.to_category_struct.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                s)
             m)
          (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2))
             j))
       (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s)))
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
          j)) →
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2)))
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       m)
    (@category_theory.limits.is_limit.lift.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
       C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2)
       (@category_theory.limits.limit.is_limit.{v u} (opposite.{v+1} J)
          (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2)
       (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
       (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
          (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)))
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2)))
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s))
    m
    (@category_theory.has_hom.hom.op.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.limits.limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2)
       (@category_theory.limits.limit.lift.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j)
         m)
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         F
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j),
u :
  (∀ (j : opposite.{v+1} J),
     @eq.{v+1}
       (@category_theory.has_hom.hom.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             j))
       (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
          (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
          (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             j)
          (@category_theory.has_hom.hom.unop.{v u} C
             (@category_theory.category_struct.to_has_hom.{v u} C
                (@category_theory.category.to_category_struct.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                s)
             m)
          (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2))
             j))
       (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s)))
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
          j)) →
  @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
             (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2)))
       (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          s)
       m)
    (@category_theory.limits.is_limit.lift.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
       C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2)
       (@category_theory.limits.limit.is_limit.{v u} (opposite.{v+1} J)
          (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2)
       (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
⊢ ∀ (j : opposite.{v+1} J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} C
         (@category_theory.category_struct.to_has_hom.{v u} C
            (@category_theory.category.to_category_struct.{v u} C 𝒞))
         (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
         (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            j))
      (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
         (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
         (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞
               (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
               _inst_2))
         (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            j)
         (@category_theory.has_hom.hom.unop.{v u} C
            (@category_theory.category_struct.to_has_hom.{v u} C
               (@category_theory.category.to_category_struct.{v u} C 𝒞))
            (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s)
            m)
         (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J)
            (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
               (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞)
               (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞)
               (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞)
               (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞
               (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  _inst_2))
            j))
      (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
         C
         𝒞
         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
            (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞)
            (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞)
            (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞)
            (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞
               (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s)))
         (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
         j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j)
         m)
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         F
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j)
⊢ ∀ (j : opposite.{v+1} J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} C
         (@category_theory.category_struct.to_has_hom.{v u} C
            (@category_theory.category.to_category_struct.{v u} C 𝒞))
         (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
         (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            j))
      (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
         (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
         (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞
               (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
               _inst_2))
         (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            j)
         (@category_theory.has_hom.hom.unop.{v u} C
            (@category_theory.category_struct.to_has_hom.{v u} C
               (@category_theory.category.to_category_struct.{v u} C 𝒞))
            (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s)
            m)
         (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J)
            (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
               (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞)
               (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞)
               (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞)
               (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞
               (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  _inst_2))
            j))
      (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
         C
         𝒞
         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
            (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞)
            (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞)
            (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞)
            (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞
               (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s)))
         (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
         j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63        intro j,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='If the current goal is a Pi/forall `∀ x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.

If the goal is an arrow `t → u`, then it puts `h : t` in the local context and the new goal target is `u`.

If the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j)
         m)
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         F
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j)
⊢ ∀ (j : opposite.{v+1} J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} C
         (@category_theory.category_struct.to_has_hom.{v u} C
            (@category_theory.category.to_category_struct.{v u} C 𝒞))
         (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
         (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            j))
      (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
         (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
         (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞
               (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
               _inst_2))
         (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            j)
         (@category_theory.has_hom.hom.unop.{v u} C
            (@category_theory.category_struct.to_has_hom.{v u} C
               (@category_theory.category.to_category_struct.{v u} C 𝒞))
            (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s)
            m)
         (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J)
            (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
               (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞)
               (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞)
               (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞)
               (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞
               (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                  (@category_theory.category.opposite.{v v} J _inst_1)
                  C
                  𝒞
                  (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                  _inst_2))
            j))
      (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
         C
         𝒞
         (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
            (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞)
            (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞)
            (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞)
            (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
               (@category_theory.category.opposite.{v v} J _inst_1)
               C
               𝒞
               (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
               (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s)))
         (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
         (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
            C
            𝒞
            (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
            (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
         j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j)
         m)
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         F
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j)
       (@category_theory.has_hom.hom.unop.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s)
          m)
       (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2))
          j))
    (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
          (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
             𝒞)
          (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞)
          (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞)
          (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s)))
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64        rw [cone_left_op_of_cocone_π_app, limit.cone_π],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.limits.cone_left_op_of_cocone_π_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.limit.cone_π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 402, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 440, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)} (c : @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F) (j : opposite.{v+1} J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.category.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.const.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F c))) j) (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) j)) (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.category.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.const.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F c))) (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F c)) j) (@category_theory.has_hom.hom.unop.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@opposite.unop.{v+1} J j)) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F c)) (@opposite.unop.{v+1} J j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F c)) (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F c) (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} [_inst_3 : @category_theory.limits.has_limit.{v u} J _inst_1 C 𝒞 F] (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{v u} J _inst_1 C 𝒞 F _inst_3))) j) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{v u} J _inst_1 C 𝒞 F _inst_3))) F (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{v u} J _inst_1 C 𝒞 F _inst_3)) j) (@category_theory.limits.limit.π.{v u} J _inst_1 C 𝒞 F _inst_3 j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j)
         m)
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         F
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j)
       (@category_theory.has_hom.hom.unop.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s)
          m)
       (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2))
          j))
    (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
          (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
             𝒞)
          (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞)
          (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞)
          (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s)))
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
       j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j)
         m)
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         F
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j)
       (@category_theory.has_hom.hom.unop.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s)
          m)
       (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
          C
          𝒞
          (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
             (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞)
             (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                _inst_2))
          j))
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@opposite.unop.{v+1} J j))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                s))
          (@opposite.unop.{v+1} J j))
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                s))
          (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s)
          (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j)
         m)
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         F
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j)
       (@category_theory.has_hom.hom.unop.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s)
          m)
       (@category_theory.limits.limit.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2
          j))
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@opposite.unop.{v+1} J j))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                s))
          (@opposite.unop.{v+1} J j))
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                s))
          (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s)
          (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65        convert congr_arg (λ f : _ ⟶ _, f.unop) (w (unop j)), clear w,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.has_hom.hom.unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='w'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='opposite.unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1318, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type v} {a₁ a₂ : α} (f : α → β), @eq.{v+1} α a₁ a₂ → @eq.{v+1} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.has_hom.opposite.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@opposite.unop.{v+1} J j)) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.has_hom.{v u} C] {X Y : opposite.{u+1} C}, @category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.has_hom.opposite.{v u} C 𝒞) X Y → @category_theory.has_hom.hom.{v u} C 𝒞 (@opposite.unop.{u+1} C Y) (@opposite.unop.{u+1} C X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C) (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞))) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F j) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s)) (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C) (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F j) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2)))) j) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s) (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2)))) (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) _inst_2))) j) m) (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s)) (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F s) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, opposite.{v+1} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='opposite.{v+1} J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`clear h₁ ... hₙ` tries to clear each hypothesis `hᵢ` from the local context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='clear'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j)
         m)
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         F
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j))
    (@category_theory.category_struct.comp.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.cone_left_op_of_cocone.{v u} J _inst_1 C 𝒞 F s))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j)
       (@category_theory.has_hom.hom.unop.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s)
          m)
       (@category_theory.limits.limit.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          _inst_2
          j))
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@opposite.unop.{v+1} J j))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                s))
          (@opposite.unop.{v+1} J j))
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                s))
          (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             s)
          (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s),
w :
  ∀ (j : J),
    @eq.{v+1}
      (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
         (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
            (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s))
      (@category_theory.category_struct.comp.{v u} (opposite.{u+1} C)
         (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞))
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            j)
         (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            j)
         (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞))
               (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                  (@category_theory.category.opposite.{v u} C 𝒞)
                  F
                  (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                     (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                        (@category_theory.category.opposite.{v v} J _inst_1)
                        C
                        𝒞
                        (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                        _inst_2))))
            (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                  (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                     (@category_theory.category.opposite.{v v} J _inst_1)
                     C
                     𝒞
                     (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                     _inst_2)))
            j)
         m)
      (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
         (@category_theory.category.opposite.{v u} C 𝒞)
         F
         (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞))
            (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
               (@category_theory.category.opposite.{v u} C 𝒞)
               F
               s))
         (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
            (@category_theory.category.opposite.{v u} C 𝒞)
            F
            s)
         j),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j))
    (@category_theory.limits.limit.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       _inst_2
       j)
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@opposite.unop.{v+1} J j))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2))))
          (@opposite.unop.{v+1} J j))
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2))))
          (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j))
    (@category_theory.limits.limit.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       _inst_2
       j)
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@opposite.unop.{v+1} J j))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2))))
          (@opposite.unop.{v+1} J j))
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2))))
          (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66        rw [cocone_of_cone_left_op_ι_app, limit.cone_π, has_hom.hom.unop_op],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.limits.cocone_of_cone_left_op_ι_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.limit.cone_π'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.has_hom.hom.unop_op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/cones.lean&#x27;, &#x27;line&#x27;: 394, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 440, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)} (c : @category_theory.limits.cone.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)) (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} (opposite.{u+1} C) (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C) (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞))) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F j) (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F c))) j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)) (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F c))) (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F c)) j) (@category_theory.has_hom.hom.op.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.category.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.const.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) c)) (@opposite.op.{v+1} J j)) (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@opposite.op.{v+1} J j)) (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.category.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.functor.const.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞) (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) c)) (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞 (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F) c) (@opposite.op.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {F : @category_theory.functor.{v v v u} J _inst_1 C 𝒞} [_inst_3 : @category_theory.limits.has_limit.{v u} J _inst_1 C 𝒞 F] (j : J), @eq.{v+1} (@category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{v u} J _inst_1 C 𝒞 F _inst_3))) j) (@category_theory.functor.obj.{v v v u} J _inst_1 C 𝒞 F j)) (@category_theory.nat_trans.app.{v v v u} J _inst_1 C 𝒞 (@category_theory.functor.obj.{v v u (max v u)} C 𝒞 (@category_theory.functor.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.category.{v v v u} J _inst_1 C 𝒞) (@category_theory.functor.const.{v v v u} J _inst_1 C 𝒞) (@category_theory.limits.cone.X.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{v u} J _inst_1 C 𝒞 F _inst_3))) F (@category_theory.limits.cone.π.{v u} J _inst_1 C 𝒞 F (@category_theory.limits.limit.cone.{v u} J _inst_1 C 𝒞 F _inst_3)) j) (@category_theory.limits.limit.π.{v u} J _inst_1 C 𝒞 F _inst_3 j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u} [𝒞 : category_theory.has_hom.{v u} C] {X Y : C} {f : @category_theory.has_hom.hom.{v u} C 𝒞 X Y}, @eq.{v+1} (@category_theory.has_hom.hom.{v u} C 𝒞 (@opposite.unop.{u+1} C (@opposite.op.{u+1} C X)) (@opposite.unop.{u+1} C (@opposite.op.{u+1} C Y))) (@category_theory.has_hom.hom.unop.{v u} C 𝒞 (@opposite.op.{u+1} C Y) (@opposite.op.{u+1} C X) (@category_theory.has_hom.hom.op.{v u} C 𝒞 X Y f)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j))
    (@category_theory.limits.limit.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       _inst_2
       j)
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@opposite.unop.{v+1} J j))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2))))
          (@opposite.unop.{v+1} J j))
       (@category_theory.nat_trans.app.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2))))
          (@category_theory.limits.cocone.ι.{v u} J _inst_1 (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             F
             (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2)))
          (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j))
    (@category_theory.limits.limit.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       _inst_2
       j)
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@opposite.unop.{v+1} J j))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2))))
          (@opposite.unop.{v+1} J j))
       (@category_theory.has_hom.hom.op.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             (@opposite.op.{v+1} J (@opposite.unop.{v+1} J j)))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@opposite.op.{v+1} J (@opposite.unop.{v+1} J j)))
          (@category_theory.nat_trans.app.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@category_theory.limits.cone.π.{v u} (opposite.{v+1} J)
                (@category_theory.category.opposite.{v v} J _inst_1)
                C
                𝒞
                (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   _inst_2))
             (@opposite.op.{v+1} J (@opposite.unop.{v+1} J j)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j))
    (@category_theory.limits.limit.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       _inst_2
       j)
    (@category_theory.has_hom.hom.unop.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          F
          (@opposite.unop.{v+1} J j))
       (@category_theory.functor.obj.{v v v u} J _inst_1 (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)
          (@category_theory.functor.obj.{v v u (max v u)} (opposite.{u+1} C)
             (@category_theory.category.opposite.{v u} C 𝒞)
             (@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.category.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.functor.const.{v v v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞))
             (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
                (@category_theory.category.opposite.{v u} C 𝒞)
                F
                (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2))))
          (@opposite.unop.{v+1} J j))
       (@category_theory.has_hom.hom.op.{v u} C
          (@category_theory.category_struct.to_has_hom.{v u} C
             (@category_theory.category.to_category_struct.{v u} C 𝒞))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.obj.{v v u (max v u)} C 𝒞
                (@category_theory.functor.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.category.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.functor.const.{v v v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞)
                (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J)
                   (@category_theory.category.opposite.{v v} J _inst_1)
                   C
                   𝒞
                   (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                   (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
                      (@category_theory.category.opposite.{v v} J _inst_1)
                      C
                      𝒞
                      (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
                      _inst_2)))
             (@opposite.op.{v+1} J (@opposite.unop.{v+1} J j)))
          (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             (@opposite.op.{v+1} J (@opposite.unop.{v+1} J j)))
          (@category_theory.limits.limit.π.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2
             (@opposite.op.{v+1} J (@opposite.unop.{v+1} J j)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j))
    (@category_theory.limits.limit.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       _inst_2
       j)
    (@category_theory.limits.limit.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       _inst_2
       (@opposite.op.{v+1} J (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67        refl,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞),
_inst_2 :
  @category_theory.limits.has_limit.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C 𝒞
    (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F),
s :
  @category_theory.limits.cocone.{v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) F,
m :
  @category_theory.has_hom.hom.{v u} (opposite.{u+1} C)
    (@category_theory.category_struct.to_has_hom.{v u} (opposite.{u+1} C)
       (@category_theory.category.to_category_struct.{v u} (opposite.{u+1} C)
          (@category_theory.category.opposite.{v u} C 𝒞)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       (@category_theory.limits.cocone_of_cone_left_op.{v u} J _inst_1 C 𝒞 F
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2)))
    (@category_theory.limits.cocone.X.{v u} J _inst_1 (opposite.{u+1} C)
       (@category_theory.category.opposite.{v u} C 𝒞)
       F
       s),
j : opposite.{v+1} J
⊢ @eq.{v+1}
    (@category_theory.has_hom.hom.{v u} C
       (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞))
       (@category_theory.limits.cone.X.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          (@category_theory.limits.limit.cone.{v u} (opposite.{v+1} J)
             (@category_theory.category.opposite.{v v} J _inst_1)
             C
             𝒞
             (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
             _inst_2))
       (@category_theory.functor.obj.{v v v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
          𝒞
          (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
          j))
    (@category_theory.limits.limit.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       _inst_2
       j)
    (@category_theory.limits.limit.π.{v u} (opposite.{v+1} J) (@category_theory.category.opposite.{v v} J _inst_1) C
       𝒞
       (@category_theory.functor.left_op.{v v v u} J _inst_1 C 𝒞 F)
       _inst_2
       (@opposite.op.{v+1} J (@opposite.unop.{v+1} J j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68      end } }</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  instance [has_limits_of_shape.{v} Jᵒᵖ C] : has_colimits_of_shape.{v} J Cᵒᵖ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.limits.has_limits_of_shape'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.has_colimits_of_shape'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 412, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 673, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π (J : Type v) [_inst_1 : category_theory.small_category.{v} J] (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (J : Type v) [_inst_1 : category_theory.small_category.{v} J] (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`C` has limits of shape `J` if we have chosen a particular limit of
 every functor `F : J ⥤ C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`C` has colimits of shape `J` if we have chosen a particular colimit of
 every functor `F : J ⥤ C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  { has_colimit := λ F, by apply_instance }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
J : Type v,
_inst_1 : category_theory.small_category.{v} J,
_inst_2 :
  @category_theory.limits.has_limits_of_shape.{v u} (opposite.{v+1} J)
    (@category_theory.category.opposite.{v v} J _inst_1)
    C
    𝒞,
F : @category_theory.functor.{v v v u} J _inst_1 (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞)
⊢ @category_theory.limits.has_colimit.{v u} J _inst_1 (opposite.{u+1} C)
    (@category_theory.category.opposite.{v u} C 𝒞)
    F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  instance [has_limits.{v} C] : has_colimits.{v} Cᵒᵖ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.limits.has_limits'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.has_colimits'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 416, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 677, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`C` has all (small) limits if it has limits of every shape.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`C` has all (small) colimits if it has colimits of every shape.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  { has_colimits_of_shape := λ J 𝒥, by { resetI, apply_instance } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='𝒥'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.small_category.{v} J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='Reset the instance cache. This allows any new instances
 added to the context to be used in typeclass inference.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='teal'><a title='resetI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
_inst_2 : @category_theory.limits.has_limits.{v u} C 𝒞,
J : Type v,
𝒥 : category_theory.small_category.{v} J
⊢ @category_theory.limits.has_colimits_of_shape.{v u} J 𝒥 (opposite.{u+1} C)
    (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  variables (X : Type v)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  instance has_coproducts_opposite [has_limits_of_shape (discrete X) C] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='blue'><a title='category_theory.limits.has_limits_of_shape'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.discrete'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 412, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/discrete_category.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='green'><a title='Π (J : Type v) [_inst_1 : category_theory.small_category.{v} J] (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='`C` has limits of shape `J` if we have chosen a particular limit of
 every functor `F : J ⥤ C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78    has_colimits_of_shape (discrete X) Cᵒᵖ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.has_colimits_of_shape'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.discrete'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 673, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/discrete_category.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (J : Type v) [_inst_1 : category_theory.small_category.{v} J] (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`C` has colimits of shape `J` if we have chosen a particular colimit of
 every functor `F : J ⥤ C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
X : Type v,
_inst_2 :
  @category_theory.limits.has_limits_of_shape.{v u} (category_theory.discrete.{v} X)
    (category_theory.discrete_category.{v} X)
    C
    𝒞
⊢ @category_theory.limits.has_colimits_of_shape.{v u} (category_theory.discrete.{v} X)
    (category_theory.discrete_category.{v} X)
    (opposite.{u+1} C)
    (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80    haveI : has_limits_of_shape (discrete X)ᵒᵖ C :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.limits.has_limits_of_shape'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.discrete'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 412, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/discrete_category.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (J : Type v) [_inst_1 : category_theory.small_category.{v} J] (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`C` has limits of shape `J` if we have chosen a particular limit of
 every functor `F : J ⥤ C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
X : Type v,
_inst_2 :
  @category_theory.limits.has_limits_of_shape.{v u} (category_theory.discrete.{v} X)
    (category_theory.discrete_category.{v} X)
    C
    𝒞
⊢ @category_theory.limits.has_colimits_of_shape.{v u} (category_theory.discrete.{v} X)
    (category_theory.discrete_category.{v} X)
    (opposite.{u+1} C)
    (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81      has_limits_of_shape_of_equivalence (discrete.opposite X).symm, apply_instance</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.has_limits_of_shape_of_equivalence'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.discrete.opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 655, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/discrete_category.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {J&#x27; : Type v} [_inst_3 : category_theory.small_category.{v} J&#x27;], @category_theory.equivalence.{v v v v} J _inst_1 J&#x27; _inst_3 → Π [_inst_4 : @category_theory.limits.has_limits_of_shape.{v u} J _inst_1 C 𝒞], @category_theory.limits.has_limits_of_shape.{v u} J&#x27; _inst_3 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type v), @category_theory.equivalence.{v v v v} (opposite.{v+1} (category_theory.discrete.{v} α)) (@category_theory.category.opposite.{v v} (category_theory.discrete.{v} α) (category_theory.discrete_category.{v} α)) (category_theory.discrete.{v} α) (category_theory.discrete_category.{v} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
X : Type v,
_inst_2 :
  @category_theory.limits.has_limits_of_shape.{v u} (category_theory.discrete.{v} X)
    (category_theory.discrete_category.{v} X)
    C
    𝒞
⊢ @category_theory.limits.has_colimits_of_shape.{v u} (category_theory.discrete.{v} X)
    (category_theory.discrete_category.{v} X)
    (opposite.{u+1} C)
    (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
X : Type v,
_inst_2 :
  @category_theory.limits.has_limits_of_shape.{v u} (category_theory.discrete.{v} X)
    (category_theory.discrete_category.{v} X)
    C
    𝒞,
_inst :
  @category_theory.limits.has_limits_of_shape.{v u} (opposite.{v+1} (category_theory.discrete.{v} X))
    (@category_theory.category.opposite.{v v} (category_theory.discrete.{v} X)
       (category_theory.discrete_category.{v} X))
    C
    𝒞
⊢ @category_theory.limits.has_colimits_of_shape.{v u} (category_theory.discrete.{v} X)
    (category_theory.discrete_category.{v} X)
    (opposite.{u+1} C)
    (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  instance has_products_opposite [has_colimits_of_shape (discrete X) C] :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='category_theory.limits.has_colimits_of_shape'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.discrete'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 673, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/discrete_category.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π (J : Type v) [_inst_1 : category_theory.small_category.{v} J] (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='`C` has colimits of shape `J` if we have chosen a particular colimit of
 every functor `F : J ⥤ C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85    has_limits_of_shape (discrete X) Cᵒᵖ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.limits.has_limits_of_shape'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.discrete'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 412, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/discrete_category.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (J : Type v) [_inst_1 : category_theory.small_category.{v} J] (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`C` has limits of shape `J` if we have chosen a particular limit of
 every functor `F : J ⥤ C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
X : Type v,
_inst_2 :
  @category_theory.limits.has_colimits_of_shape.{v u} (category_theory.discrete.{v} X)
    (category_theory.discrete_category.{v} X)
    C
    𝒞
⊢ @category_theory.limits.has_limits_of_shape.{v u} (category_theory.discrete.{v} X)
    (category_theory.discrete_category.{v} X)
    (opposite.{u+1} C)
    (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87    haveI : has_colimits_of_shape (discrete X)ᵒᵖ C :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.limits.has_colimits_of_shape'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.discrete'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 673, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/discrete_category.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (J : Type v) [_inst_1 : category_theory.small_category.{v} J] (C : Type u) [𝒞 : category_theory.category.{v u} C], Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`C` has colimits of shape `J` if we have chosen a particular colimit of
 every functor `F : J ⥤ C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
X : Type v,
_inst_2 :
  @category_theory.limits.has_colimits_of_shape.{v u} (category_theory.discrete.{v} X)
    (category_theory.discrete_category.{v} X)
    C
    𝒞
⊢ @category_theory.limits.has_limits_of_shape.{v u} (category_theory.discrete.{v} X)
    (category_theory.discrete_category.{v} X)
    (opposite.{u+1} C)
    (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88      has_colimits_of_shape_of_equivalence (discrete.opposite X).symm, apply_instance</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.limits.has_colimits_of_shape_of_equivalence'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.discrete.opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/limits/limits.lean&#x27;, &#x27;line&#x27;: 937, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/discrete_category.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/cache.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {J : Type v} [_inst_1 : category_theory.small_category.{v} J] {C : Type u} [𝒞 : category_theory.category.{v u} C] {J&#x27; : Type v} [_inst_3 : category_theory.small_category.{v} J&#x27;], @category_theory.equivalence.{v v v v} J _inst_1 J&#x27; _inst_3 → Π [_inst_4 : @category_theory.limits.has_colimits_of_shape.{v u} J _inst_1 C 𝒞], @category_theory.limits.has_colimits_of_shape.{v u} J&#x27; _inst_3 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type v), @category_theory.equivalence.{v v v v} (opposite.{v+1} (category_theory.discrete.{v} α)) (@category_theory.category.opposite.{v v} (category_theory.discrete.{v} α) (category_theory.discrete_category.{v} α)) (category_theory.discrete.{v} α) (category_theory.discrete_category.{v} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Used to add typeclasses to the context so that they can
 be used in typeclass inference. The syntax is the same as `have`,
 but the proof-omitted version is not supported. For
 this one must write `have : t, { &lt;proof&gt; }, resetI, &lt;proof&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='haveI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;:= expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
X : Type v,
_inst_2 :
  @category_theory.limits.has_colimits_of_shape.{v u} (category_theory.discrete.{v} X)
    (category_theory.discrete_category.{v} X)
    C
    𝒞
⊢ @category_theory.limits.has_limits_of_shape.{v u} (category_theory.discrete.{v} X)
    (category_theory.discrete_category.{v} X)
    (opposite.{u+1} C)
    (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u,
𝒞 : category_theory.category.{v u} C,
X : Type v,
_inst_2 :
  @category_theory.limits.has_colimits_of_shape.{v u} (category_theory.discrete.{v} X)
    (category_theory.discrete_category.{v} X)
    C
    𝒞,
_inst :
  @category_theory.limits.has_colimits_of_shape.{v u} (opposite.{v+1} (category_theory.discrete.{v} X))
    (@category_theory.category.opposite.{v v} (category_theory.discrete.{v} X)
       (category_theory.discrete_category.{v} X))
    C
    𝒞
⊢ @category_theory.limits.has_limits_of_shape.{v u} (category_theory.discrete.{v} X)
    (category_theory.discrete_category.{v} X)
    (opposite.{u+1} C)
    (@category_theory.category.opposite.{v u} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  end category_theory.limits</code></pre>
</body>