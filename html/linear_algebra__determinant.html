<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2018 Kenny Lau. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Kenny Lau, Chris Hughes, Tim Baanen</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import data.matrix.basic</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import data.matrix.pequiv</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/pequiv.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import group_theory.perm.sign</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/perm/sign.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  universes u v</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  open equiv equiv.perm finset function</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  namespace matrix</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  variables {n : Type u} [fintype n] [decidable_eq n] {R : Type v} [comm_ring R]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='fintype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='decidable_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='comm_ring'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 217, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`fintype α` means that `α` is finite, i.e. there are only
 finitely many distinct elements of type `α`. The evidence of this
 is a finset `elems` (a list up to permutation without duplicates),
 together with a proof that everything of type `α` is in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  local notation `ε` σ:max := ((sign σ : ℤ ) : R)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='std.prec.max'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='equiv.perm.sign'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 429, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/perm/sign.lean&#x27;, &#x27;line&#x27;: 464, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : fintype.{u} α], equiv.perm.{u+1} α → @units.{0} int int.monoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  /-- The determinant of a matrix given by the Leibniz formula. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  definition det (M : matrix n n R) : R :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='matrix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/basic.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Π (m n : Type u) [_inst_1 : fintype.{u} m] [_inst_2 : fintype.{u} n], Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  univ.sum (λ (σ : perm n), ε σ * univ.prod (λ i, M (σ i) i))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='equiv.perm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Sort u_1 → Sort (max 1 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`perm α` is the type of bijections from `α` to itself.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`prod s f` is the product of `f x` as `x` ranges over the elements of the finite set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  @[simp] lemma det_diagonal {d : n → R} : det (diagonal d) = univ.prod d :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='matrix.det'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='matrix.diagonal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/basic.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {n : Type u} [_inst_1 : fintype.{u} n] [_inst_2 : decidable_eq.{u+1} n] {R : Type v} [_inst_3 : comm_ring.{v} R], @matrix.{u v} n n _inst_1 _inst_1 R → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {n : Type u} [_inst_3 : fintype.{u} n] {α : Type v} [_inst_5 : decidable_eq.{u+1} n] [_inst_6 : has_zero.{v} α], (n → α) → @matrix.{u v} n n _inst_3 _inst_3 α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='The determinant of a matrix given by the Leibniz formula.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`prod s f` is the product of `f x` as `x` ranges over the elements of the finite set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (@matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
          (@mul_zero_class.to_has_zero.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          d))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25    refine (finset.sum_eq_single 1 _ _).trans _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='finset.sum_eq_single'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 215, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : add_comm_monoid.{v} β] {s : finset.{u} α} {f : α → β} (a : α), (∀ (b : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) b s → @ne.{u+1} α b a → @eq.{v+1} β (f b) (@has_zero.zero.{v} β (@add_monoid.to_has_zero.{v} β (@add_comm_monoid.to_add_monoid.{v} β _inst_1)))) → (not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s) → @eq.{v+1} β (f a) (@has_zero.zero.{v} β (@add_monoid.to_has_zero.{v} β (@add_comm_monoid.to_add_monoid.{v} β _inst_1)))) → @eq.{v+1} β (@finset.sum.{u v} α β _inst_1 s f) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (@matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
          (@mul_zero_class.to_has_zero.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          d))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R
⊢ ∀ (b : equiv.perm.{u+1} n),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      b
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1)) →
    @ne.{u+1} (equiv.perm.{u+1} n) b
      (@has_one.one.{u} (equiv.perm.{u+1} n)
         (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
            (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))) →
    @eq.{v+1} R
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} int R
            (@coe_to_lift.{1 v+1} int R
               (@coe_base.{1 v+1} int R
                  (@int.cast_coe.{v} R
                     (@add_group.to_has_neg.{v} R
                        (@add_comm_group.to_add_group.{v} R
                           (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                     (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
            (@coe.{1 1} (@units.{0} int int.monoid) int
               (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                  (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
               (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 b)))
         (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
            (@finset.univ.{u} n _inst_1)
            (λ (i : n),
               @matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                 (@mul_zero_class.to_has_zero.{v} R
                    (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                 d
                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) b i)
                 i)))
      (@has_zero.zero.{v} R
         (@add_monoid.to_has_zero.{v} R
            (@add_comm_monoid.to_add_monoid.{v} R
               (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R
⊢ not
    (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
       (@finset.has_mem.{u} (equiv.perm.{u+1} n))
       (@has_one.one.{u} (equiv.perm.{u+1} n)
          (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
             (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
             (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
             _inst_1
             _inst_1))) →
  @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                (@has_one.one.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               d
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  (@has_one.one.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  i)
               i)))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                (@has_one.one.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               d
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  (@has_one.one.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  i)
               i)))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26    { intros σ h1 h2,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R
⊢ ∀ (b : equiv.perm.{u+1} n),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      b
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1)) →
    @ne.{u+1} (equiv.perm.{u+1} n) b
      (@has_one.one.{u} (equiv.perm.{u+1} n)
         (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
            (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))) →
    @eq.{v+1} R
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} int R
            (@coe_to_lift.{1 v+1} int R
               (@coe_base.{1 v+1} int R
                  (@int.cast_coe.{v} R
                     (@add_group.to_has_neg.{v} R
                        (@add_comm_group.to_add_group.{v} R
                           (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                     (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
            (@coe.{1 1} (@units.{0} int int.monoid) int
               (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                  (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
               (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 b)))
         (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
            (@finset.univ.{u} n _inst_1)
            (λ (i : n),
               @matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                 (@mul_zero_class.to_has_zero.{v} R
                    (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                 d
                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) b i)
                 i)))
      (@has_zero.zero.{v} R
         (@add_monoid.to_has_zero.{v} R
            (@add_comm_monoid.to_add_monoid.{v} R
               (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R
⊢ not
    (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
       (@finset.has_mem.{u} (equiv.perm.{u+1} n))
       (@has_one.one.{u} (equiv.perm.{u+1} n)
          (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
             (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
             (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
             _inst_1
             _inst_1))) →
  @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                (@has_one.one.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               d
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  (@has_one.one.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  i)
               i)))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                (@has_one.one.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               d
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  (@has_one.one.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  i)
               i)))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R
⊢ ∀ (b : equiv.perm.{u+1} n),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      b
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1)) →
    @ne.{u+1} (equiv.perm.{u+1} n) b
      (@has_one.one.{u} (equiv.perm.{u+1} n)
         (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
            (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))) →
    @eq.{v+1} R
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} int R
            (@coe_to_lift.{1 v+1} int R
               (@coe_base.{1 v+1} int R
                  (@int.cast_coe.{v} R
                     (@add_group.to_has_neg.{v} R
                        (@add_comm_group.to_add_group.{v} R
                           (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                     (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
            (@coe.{1 1} (@units.{0} int int.monoid) int
               (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                  (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
               (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 b)))
         (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
            (@finset.univ.{u} n _inst_1)
            (λ (i : n),
               @matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                 (@mul_zero_class.to_has_zero.{v} R
                    (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                 d
                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) b i)
                 i)))
      (@has_zero.zero.{v} R
         (@add_monoid.to_has_zero.{v} R
            (@add_comm_monoid.to_add_monoid.{v} R
               (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R,
σ : equiv.perm.{u+1} n,
h1 :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
h2 :
  @ne.{u+1} (equiv.perm.{u+1} n) σ
    (@has_one.one.{u} (equiv.perm.{u+1} n)
       (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
          (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               d
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
               i)))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27      cases not_forall.1 (mt (equiv.ext _ _) h2) with x h3,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='not_forall'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='mt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='h2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 453, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 50, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {p : α → Prop} [_inst_1 : decidable (@Exists.{u+1} α (λ (x : α), not (p x)))] [_inst_2 : Π (x : α), decidable (p x)], iff (not (∀ (x : α), p x)) (@Exists.{u+1} α (λ (x : α), not (p x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, (a → b) → not b → not a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type u} (f g : equiv.{u+1 u+1} α β), (∀ (x : α), @eq.{u+1} β (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} α β) (@equiv.has_coe_to_fun.{u+1 u+1} α β) f x) (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} α β) (@equiv.has_coe_to_fun.{u+1 u+1} α β) g x)) → @eq.{(max 1 (u+1))} (equiv.{u+1 u+1} α β) f g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{u+1} (equiv.perm.{u+1} n) σ (@has_one.one.{u} (equiv.perm.{u+1} n) (@monoid.to_has_one.{u} (equiv.perm.{u+1} n) (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R,
σ : equiv.perm.{u+1} n,
h1 :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
h2 :
  @ne.{u+1} (equiv.perm.{u+1} n) σ
    (@has_one.one.{u} (equiv.perm.{u+1} n)
       (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
          (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               d
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
               i)))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R,
σ : equiv.perm.{u+1} n,
h1 :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
h2 :
  @ne.{u+1} (equiv.perm.{u+1} n) σ
    (@has_one.one.{u} (equiv.perm.{u+1} n)
       (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
          (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))),
x : n,
h3 :
  not
    (@eq.{u+1} n (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          (@has_one.one.{u} (equiv.perm.{u+1} n)
             (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          x))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               d
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
               i)))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28      convert ring.mul_zero _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='ring.mul_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 165, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : ring.{v} α] (a : α), @eq.{v+1} α (@has_mul.mul.{v} α (@distrib.to_has_mul.{v} α (@ring.to_distrib.{v} α _inst_1)) a (@has_zero.zero.{v} α (@add_monoid.to_has_zero.{v} α (@add_group.to_add_monoid.{v} α (@add_comm_group.to_add_group.{v} α (@ring.to_add_comm_group.{v} α _inst_1)))))) (@has_zero.zero.{v} α (@add_monoid.to_has_zero.{v} α (@add_group.to_add_monoid.{v} α (@add_comm_group.to_add_group.{v} α (@ring.to_add_comm_group.{v} α _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R,
σ : equiv.perm.{u+1} n,
h1 :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
h2 :
  @ne.{u+1} (equiv.perm.{u+1} n) σ
    (@has_one.one.{u} (equiv.perm.{u+1} n)
       (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
          (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))),
x : n,
h3 :
  not
    (@eq.{u+1} n (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          (@has_one.one.{u} (equiv.perm.{u+1} n)
             (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          x))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               d
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
               i)))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R,
σ : equiv.perm.{u+1} n,
h1 :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
h2 :
  @ne.{u+1} (equiv.perm.{u+1} n) σ
    (@has_one.one.{u} (equiv.perm.{u+1} n)
       (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
          (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))),
x : n,
h3 :
  not
    (@eq.{u+1} n (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          (@has_one.one.{u} (equiv.perm.{u+1} n)
             (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          x))
⊢ @eq.{v+1} R
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (i : n),
          @matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
            (@mul_zero_class.to_has_zero.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            d
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
            i))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_group.to_add_monoid.{v} R
             (@add_comm_group.to_add_group.{v} R (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29      apply finset.prod_eq_zero,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='finset.prod_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 649, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} {s : finset.{u} α} {f : α → β} {a : α} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : comm_semiring.{v} β], @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s → @eq.{v+1} β (f a) (@has_zero.zero.{v} β (@mul_zero_class.to_has_zero.{v} β (@semiring.to_mul_zero_class.{v} β (@comm_semiring.to_semiring.{v} β _inst_2)))) → @eq.{v+1} β (@finset.prod.{u v} α β (@comm_semiring.to_comm_monoid.{v} β _inst_2) s f) (@has_zero.zero.{v} β (@mul_zero_class.to_has_zero.{v} β (@semiring.to_mul_zero_class.{v} β (@comm_semiring.to_semiring.{v} β _inst_2))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R,
σ : equiv.perm.{u+1} n,
h1 :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
h2 :
  @ne.{u+1} (equiv.perm.{u+1} n) σ
    (@has_one.one.{u} (equiv.perm.{u+1} n)
       (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
          (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))),
x : n,
h3 :
  not
    (@eq.{u+1} n (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          (@has_one.one.{u} (equiv.perm.{u+1} n)
             (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          x))
⊢ @eq.{v+1} R
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (i : n),
          @matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
            (@mul_zero_class.to_has_zero.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            d
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
            i))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_group.to_add_monoid.{v} R
             (@add_comm_group.to_add_group.{v} R (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R,
σ : equiv.perm.{u+1} n,
h1 :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
h2 :
  @ne.{u+1} (equiv.perm.{u+1} n) σ
    (@has_one.one.{u} (equiv.perm.{u+1} n)
       (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
          (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))),
x : n,
h3 :
  not
    (@eq.{u+1} n (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          (@has_one.one.{u} (equiv.perm.{u+1} n)
             (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          x))
⊢ @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) ?m_1 (@finset.univ.{u} n _inst_1)

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R,
σ : equiv.perm.{u+1} n,
h1 :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
h2 :
  @ne.{u+1} (equiv.perm.{u+1} n) σ
    (@has_one.one.{u} (equiv.perm.{u+1} n)
       (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
          (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))),
x : n,
h3 :
  not
    (@eq.{u+1} n (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          (@has_one.one.{u} (equiv.perm.{u+1} n)
             (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          x))
⊢ @eq.{v+1} R
    (@matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       d
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ ?m_1)
       ?m_1)
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R
             (@comm_semiring.to_semiring.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3)))))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R,
σ : equiv.perm.{u+1} n,
h1 :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
h2 :
  @ne.{u+1} (equiv.perm.{u+1} n) σ
    (@has_one.one.{u} (equiv.perm.{u+1} n)
       (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
          (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))),
x : n,
h3 :
  not
    (@eq.{u+1} n (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          (@has_one.one.{u} (equiv.perm.{u+1} n)
             (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          x))
⊢ n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30      { change x ∈ _, simp },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R,
σ : equiv.perm.{u+1} n,
h1 :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
h2 :
  @ne.{u+1} (equiv.perm.{u+1} n) σ
    (@has_one.one.{u} (equiv.perm.{u+1} n)
       (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
          (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))),
x : n,
h3 :
  not
    (@eq.{u+1} n (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          (@has_one.one.{u} (equiv.perm.{u+1} n)
             (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          x))
⊢ @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) ?m_1 (@finset.univ.{u} n _inst_1)

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R,
σ : equiv.perm.{u+1} n,
h1 :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
h2 :
  @ne.{u+1} (equiv.perm.{u+1} n) σ
    (@has_one.one.{u} (equiv.perm.{u+1} n)
       (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
          (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))),
x : n,
h3 :
  not
    (@eq.{u+1} n (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          (@has_one.one.{u} (equiv.perm.{u+1} n)
             (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          x))
⊢ @eq.{v+1} R
    (@matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       d
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ ?m_1)
       ?m_1)
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R
             (@comm_semiring.to_semiring.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3)))))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R,
σ : equiv.perm.{u+1} n,
h1 :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
h2 :
  @ne.{u+1} (equiv.perm.{u+1} n) σ
    (@has_one.one.{u} (equiv.perm.{u+1} n)
       (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
          (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))),
x : n,
h3 :
  not
    (@eq.{u+1} n (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          (@has_one.one.{u} (equiv.perm.{u+1} n)
             (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          x))
⊢ n'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R,
σ : equiv.perm.{u+1} n,
h1 :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
h2 :
  @ne.{u+1} (equiv.perm.{u+1} n) σ
    (@has_one.one.{u} (equiv.perm.{u+1} n)
       (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
          (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))),
x : n,
h3 :
  not
    (@eq.{u+1} n (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          (@has_one.one.{u} (equiv.perm.{u+1} n)
             (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          x))
⊢ @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) ?m_1 (@finset.univ.{u} n _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R,
σ : equiv.perm.{u+1} n,
h1 :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
h2 :
  @ne.{u+1} (equiv.perm.{u+1} n) σ
    (@has_one.one.{u} (equiv.perm.{u+1} n)
       (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
          (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))),
x : n,
h3 :
  not
    (@eq.{u+1} n (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          (@has_one.one.{u} (equiv.perm.{u+1} n)
             (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          x))
⊢ @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) x (@finset.univ.{u} n _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R,
σ : equiv.perm.{u+1} n,
h1 :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
h2 :
  @ne.{u+1} (equiv.perm.{u+1} n) σ
    (@has_one.one.{u} (equiv.perm.{u+1} n)
       (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
          (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))),
x : n,
h3 :
  not
    (@eq.{u+1} n (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          (@has_one.one.{u} (equiv.perm.{u+1} n)
             (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          x))
⊢ @eq.{v+1} R
    (@matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       d
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
       x)
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R
             (@comm_semiring.to_semiring.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31      exact if_neg h3 },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='if_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], not c → ∀ {α : Type v} {t e : α}, @eq.{v+1} α (@ite.{v+1} c h α t e) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@eq.{u+1} n (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x) (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) (@has_one.one.{u} (equiv.perm.{u+1} n) (@monoid.to_has_one.{u} (equiv.perm.{u+1} n) (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R,
σ : equiv.perm.{u+1} n,
h1 :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
h2 :
  @ne.{u+1} (equiv.perm.{u+1} n) σ
    (@has_one.one.{u} (equiv.perm.{u+1} n)
       (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
          (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))),
x : n,
h3 :
  not
    (@eq.{u+1} n (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          (@has_one.one.{u} (equiv.perm.{u+1} n)
             (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          x))
⊢ @eq.{v+1} R
    (@matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       d
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
       x)
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R
             (@comm_semiring.to_semiring.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R
⊢ not
    (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
       (@finset.has_mem.{u} (equiv.perm.{u+1} n))
       (@has_one.one.{u} (equiv.perm.{u+1} n)
          (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
             (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
             (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
             _inst_1
             _inst_1))) →
  @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                (@has_one.one.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               d
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  (@has_one.one.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  i)
               i)))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                (@has_one.one.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               d
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  (@has_one.one.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  i)
               i)))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32    { simp },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R
⊢ not
    (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
       (@finset.has_mem.{u} (equiv.perm.{u+1} n))
       (@has_one.one.{u} (equiv.perm.{u+1} n)
          (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
             (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
             (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
             _inst_1
             _inst_1))) →
  @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                (@has_one.one.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               d
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  (@has_one.one.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  i)
               i)))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                (@has_one.one.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               d
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  (@has_one.one.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  i)
               i)))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R
⊢ not
    (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
       (@finset.has_mem.{u} (equiv.perm.{u+1} n))
       (@has_one.one.{u} (equiv.perm.{u+1} n)
          (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
             (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
             (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
             _inst_1
             _inst_1))) →
  @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                (@has_one.one.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               d
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  (@has_one.one.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  i)
               i)))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                (@has_one.one.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               d
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  (@has_one.one.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  i)
               i)))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33    { simp }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
d : n → R
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                (@has_one.one.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               d
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  (@has_one.one.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_has_one.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  i)
               i)))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  @[simp] lemma det_zero (h : nonempty n) : det (0 : matrix n n R) = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='nonempty'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='matrix.det'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='matrix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 790, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/basic.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Sort u → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {n : Type u} [_inst_1 : fintype.{u} n] [_inst_2 : decidable_eq.{u+1} n] {R : Type v} [_inst_3 : comm_ring.{v} R], @matrix.{u v} n n _inst_1 _inst_1 R → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (m n : Type u) [_inst_1 : fintype.{u} m] [_inst_2 : fintype.{u} n], Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='The determinant of a matrix given by the Leibniz formula.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  by rw [← diagonal_zero, det_diagonal, finset.prod_const, ← fintype.card,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='matrix.diagonal_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='matrix.det_diagonal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.prod_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='fintype.card'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/basic.lean&#x27;, &#x27;line&#x27;: 71, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 400, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 103, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : Type u} [_inst_3 : fintype.{u} n] {α : Type v} [_inst_5 : decidable_eq.{u+1} n] [_inst_6 : has_zero.{v} α], @eq.{(max u v)+1} (@matrix.{u v} n n _inst_3 _inst_3 α) (@matrix.diagonal.{u v} n _inst_3 α (λ (a b : n), _inst_5 a b) _inst_6 (λ (_x : n), @has_zero.zero.{v} α _inst_6)) (@has_zero.zero.{(max u v)} (@matrix.{u v} n n _inst_3 _inst_3 α) (@matrix.has_zero.{u v} n n _inst_3 _inst_3 α _inst_6))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : Type u} [_inst_1 : fintype.{u} n] [_inst_2 : decidable_eq.{u+1} n] {R : Type v} [_inst_3 : comm_ring.{v} R] {d : n → R}, @eq.{v+1} R (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 (@matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b) (@mul_zero_class.to_has_zero.{v} R (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) d)) (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3)) (@finset.univ.{u} n _inst_1) d)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} {s : finset.{u} α} [_inst_1 : comm_monoid.{v} β] (b : β), @eq.{v+1} β (@finset.prod.{u v} α β _inst_1 s (λ (a : α), b)) (@has_pow.pow.{v 0} β nat (@monoid.has_pow.{v} β (@comm_monoid.to_monoid.{v} β _inst_1)) b (@finset.card.{u} α s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type ?l_1) [_inst_1 : fintype.{?l_1} α], nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`card α` is the number of elements in `α`, defined when `α` is a fintype.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
h : nonempty.{u+1} n
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (@has_zero.zero.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
          (@matrix.has_zero.{u v} n n _inst_1 _inst_1 R
             (@mul_zero_class.to_has_zero.{v} R
                (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
h : nonempty.{u+1} n
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (@matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
          (@mul_zero_class.to_has_zero.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (λ (_x : n),
             @has_zero.zero.{v} R
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
h : nonempty.{u+1} n
⊢ @eq.{v+1} R
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (_x : n),
          @has_zero.zero.{v} R
            (@mul_zero_class.to_has_zero.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
h : nonempty.{u+1} n
⊢ @eq.{v+1} R
    (@has_pow.pow.{v 0} R nat
       (@monoid.has_pow.{v} R
          (@comm_monoid.to_monoid.{v} R
             (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))))
       (@has_zero.zero.{v} R
          (@mul_zero_class.to_has_zero.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))
       (@finset.card.{u} n (@finset.univ.{u} n _inst_1)))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
h : nonempty.{u+1} n
⊢ @eq.{v+1} R
    (@has_pow.pow.{v 0} R nat
       (@monoid.has_pow.{v} R
          (@comm_monoid.to_monoid.{v} R
             (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))))
       (@has_zero.zero.{v} R
          (@mul_zero_class.to_has_zero.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))
       (@fintype.card.{u} n _inst_1))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38    zero_pow (fintype.card_pos_iff.2 h)]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='zero_pow'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fintype.card_pos_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 428, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 378, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : semiring.{v} α] {n : nat}, @has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) n → @eq.{v+1} α (@has_pow.pow.{v 0} α nat (@monoid.has_pow.{v} α (@semiring.to_monoid.{v} α _inst_1)) (@has_zero.zero.{v} α (@mul_zero_class.to_has_zero.{v} α (@semiring.to_mul_zero_class.{v} α _inst_1))) n) (@has_zero.zero.{v} α (@mul_zero_class.to_has_zero.{v} α (@semiring.to_mul_zero_class.{v} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : fintype.{u} α], iff (@has_lt.lt.{0} nat nat.has_lt (@has_zero.zero.{0} nat nat.has_zero) (@fintype.card.{u} α _inst_1)) (nonempty.{u+1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nonempty.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
h : nonempty.{u+1} n
⊢ @eq.{v+1} R
    (@has_pow.pow.{v 0} R nat
       (@monoid.has_pow.{v} R
          (@comm_monoid.to_monoid.{v} R
             (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))))
       (@has_zero.zero.{v} R
          (@mul_zero_class.to_has_zero.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))
       (@fintype.card.{u} n _inst_1))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
h : nonempty.{u+1} n
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (@has_zero.zero.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
          (@matrix.has_zero.{u v} n n _inst_1 _inst_1 R
             (@mul_zero_class.to_has_zero.{v} R
                (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
h : nonempty.{u+1} n
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (@has_zero.zero.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
          (@matrix.has_zero.{u v} n n _inst_1 _inst_1 R
             (@mul_zero_class.to_has_zero.{v} R
                (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  @[simp] lemma det_one : det (1 : matrix n n R) = 1 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='matrix.det'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='matrix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/basic.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Π {n : Type u} [_inst_1 : fintype.{u} n] [_inst_2 : decidable_eq.{u+1} n] {R : Type v} [_inst_3 : comm_ring.{v} R], @matrix.{u v} n n _inst_1 _inst_1 R → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (m n : Type u) [_inst_1 : fintype.{u} m] [_inst_2 : fintype.{u} n], Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The determinant of a matrix given by the Leibniz formula.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  by rw [← diagonal_one]; simp [-diagonal_one]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='matrix.diagonal_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/basic.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : Type u} [_inst_3 : fintype.{u} n] {α : Type v} [_inst_5 : decidable_eq.{u+1} n] [_inst_6 : has_zero.{v} α] [_inst_7 : has_one.{v} α], @eq.{(max u v)+1} (@matrix.{u v} n n _inst_3 _inst_3 α) (@matrix.diagonal.{u v} n _inst_3 α (λ (a b : n), _inst_5 a b) _inst_6 (λ (_x : n), @has_one.one.{v} α _inst_7)) (@has_one.one.{(max u v)} (@matrix.{u v} n n _inst_3 _inst_3 α) (@matrix.has_one.{u v} n _inst_3 α (λ (a b : n), _inst_5 a b) _inst_6 _inst_7))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (@has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
          (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
             (@mul_zero_class.to_has_zero.{v} R
                (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
             (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
    (@has_one.one.{v} R (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (@matrix.diagonal.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
          (@mul_zero_class.to_has_zero.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (λ (_x : n),
             @has_one.one.{v} R (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
    (@has_one.one.{v} R (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (@has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
          (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
             (@mul_zero_class.to_has_zero.{v} R
                (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
             (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
    (@has_one.one.{v} R (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (@has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
          (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
             (@mul_zero_class.to_has_zero.{v} R
                (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
             (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
    (@has_one.one.{v} R (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  lemma det_mul_aux {M N : matrix n n R} {p : n → n} (H : ¬bijective p) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='matrix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='function.bijective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/basic.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Π (m n : Type u) [_inst_1 : fintype.{u} m] [_inst_2 : fintype.{u} n], Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort u₁} {β : Sort u₂}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44    univ.sum (λ σ : perm n, (ε σ) * (univ.prod (λ x, M (σ x) (p x) * N (p x) x))) = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='equiv.perm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Sort u_1 → Sort (max 1 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='n → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='n → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`perm α` is the type of bijections from `α` to itself.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`prod s f` is the product of `f x` as `x` ranges over the elements of the finite set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p)
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (x : n),
                  @has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                       (p x))
                    (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46    obtain ⟨i, j, hpij, hij⟩ : ∃ i j, p i = p j ∧ i ≠ j,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='n → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p)
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (x : n),
                  @has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                       (p x))
                    (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p)
⊢ @Exists.{u+1} n (λ (i : n), @Exists.{u+1} n (λ (j : n), and (@eq.{u+1} n (p i) (p j)) (@ne.{u+1} n i j)))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (x : n),
                  @has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                       (p x))
                    (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47    { rw [← fintype.injective_iff_bijective, injective] at H,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='fintype.injective_iff_bijective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='function.injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 417, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : fintype.{u} α] {f : α → α}, iff (@function.injective.{u+1 u+1} α α f) (@function.bijective.{u+1 u+1} α α f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort ?l_1} {β : Sort ?l_2}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p)
⊢ @Exists.{u+1} n (λ (i : n), @Exists.{u+1} n (λ (j : n), and (@eq.{u+1} n (p i) (p j)) (@ne.{u+1} n i j)))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (x : n),
                  @has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                       (p x))
                    (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p)
⊢ @Exists.{u+1} n (λ (i : n), @Exists.{u+1} n (λ (j : n), and (@eq.{u+1} n (p i) (p j)) (@ne.{u+1} n i j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.injective.{u+1 u+1} n n p)
⊢ @Exists.{u+1} n (λ (i : n), @Exists.{u+1} n (λ (j : n), and (@eq.{u+1} n (p i) (p j)) (@ne.{u+1} n i j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (∀ ⦃a₁ a₂ : n⦄, @eq.{u+1} n (p a₁) (p a₂) → @eq.{u+1} n a₁ a₂)
⊢ @Exists.{u+1} n (λ (i : n), @Exists.{u+1} n (λ (j : n), and (@eq.{u+1} n (p i) (p j)) (@ne.{u+1} n i j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p)
⊢ @Exists.{u+1} n (λ (i : n), @Exists.{u+1} n (λ (j : n), and (@eq.{u+1} n (p i) (p j)) (@ne.{u+1} n i j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (∀ ⦃a₁ a₂ : n⦄, @eq.{u+1} n (p a₁) (p a₂) → @eq.{u+1} n a₁ a₂)
⊢ @Exists.{u+1} n (λ (i : n), @Exists.{u+1} n (λ (j : n), and (@eq.{u+1} n (p i) (p j)) (@ne.{u+1} n i j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48      push_neg at H,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/push_neg.lean&#x27;, &#x27;line&#x27;: 129, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Push negations in the goal of some assumption.
For instance, given `h : ¬ ∀ x, ∃ y, x ≤ y`, will be transformed by `push_neg at h` into
`h : ∃ x, ∀ y, y &lt; x`. Variables names are conserved.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='push_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (∀ ⦃a₁ a₂ : n⦄, @eq.{u+1} n (p a₁) (p a₂) → @eq.{u+1} n a₁ a₂)
⊢ @Exists.{u+1} n (λ (i : n), @Exists.{u+1} n (λ (j : n), and (@eq.{u+1} n (p i) (p j)) (@ne.{u+1} n i j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H :
  @Exists.{u+1} n
    (λ ⦃a₁ : n⦄,
       @Exists.{u+1} n (λ ⦃a₂ : n⦄, and (@eq.{u+1} n (p a₁) (p a₂)) (not (@eq.{u+1} n a₁ a₂))))
⊢ @Exists.{u+1} n (λ (i : n), @Exists.{u+1} n (λ (j : n), and (@eq.{u+1} n (p i) (p j)) (@ne.{u+1} n i j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49      exact H },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u+1} n (λ ⦃a₁ : n⦄, @Exists.{u+1} n (λ ⦃a₂ : n⦄, and (@eq.{u+1} n (p a₁) (p a₂)) (not (@eq.{u+1} n a₁ a₂))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H :
  @Exists.{u+1} n
    (λ ⦃a₁ : n⦄,
       @Exists.{u+1} n (λ ⦃a₂ : n⦄, and (@eq.{u+1} n (p a₁) (p a₂)) (not (@eq.{u+1} n a₁ a₂))))
⊢ @Exists.{u+1} n (λ (i : n), @Exists.{u+1} n (λ (j : n), and (@eq.{u+1} n (p i) (p j)) (@ne.{u+1} n i j)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (x : n),
                  @has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                       (p x))
                    (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50    exact sum_involution</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='finset.sum_involution'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 416, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : add_comm_monoid.{v} β] {s : finset.{u} α} {f : α → β} (g : Π (a : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s → α), (∀ (a : α) (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @eq.{v+1} β (@has_add.add.{v} β (@add_semigroup.to_has_add.{v} β (@add_monoid.to_add_semigroup.{v} β (@add_comm_monoid.to_add_monoid.{v} β _inst_1))) (f a) (f (g a ha))) (@has_zero.zero.{v} β (@add_monoid.to_has_zero.{v} β (@add_comm_monoid.to_add_monoid.{v} β _inst_1)))) → (∀ (a : α) (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @ne.{v+1} β (f a) (@has_zero.zero.{v} β (@add_monoid.to_has_zero.{v} β (@add_comm_monoid.to_add_monoid.{v} β _inst_1))) → @ne.{u+1} α (g a ha) a) → ∀ (h₃ : ∀ (a : α) (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) (g a ha) s), (∀ (a : α) (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @eq.{u+1} α (g (g a ha) (h₃ a ha)) a) → @eq.{v+1} β (@finset.sum.{u v} α β _inst_1 s f) (@has_zero.zero.{v} β (@add_monoid.to_has_zero.{v} β (@add_comm_monoid.to_add_monoid.{v} β _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (x : n),
                  @has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                       (p x))
                    (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51      (λ σ _, σ * swap i j)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (x : n),
                  @has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                       (p x))
                    (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52      (λ σ _,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (x : n),
                  @has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                       (p x))
                    (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53        have ∀ a, p (swap i j a) = p a := λ a, by simp only [swap_apply_def]; split_ifs; cc,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='blue'><a title='equiv.swap_apply_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 855, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1300, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} [_inst_1 : decidable_eq.{?l_1} α] (a b x : α), @eq.{?l_1} α (@coe_fn.{(max 1 ?l_1) ?l_1} (equiv.perm.{?l_1} α) (@equiv.has_coe_to_fun.{?l_1 ?l_1} α α) (@equiv.swap.{?l_1} α (λ (a b : α), _inst_1 a b) a b) x) (@ite.{?l_1} (@eq.{?l_1} α x a) (_inst_1 x a) α b (@ite.{?l_1} (@eq.{?l_1} α x b) (_inst_1 x b) α a x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Tries to prove the main goal using congruence closure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='cc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (x : n),
                  @has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                       (p x))
                    (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
a : n
⊢ @eq.{u+1} n
    (p
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
          a))
    (p a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (x : n),
                  @has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                       (p x))
                    (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54        have univ.prod (λ x, M (σ x) (p x)) = univ.prod (λ x, M ((σ * swap i j) x) (p x)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (x : n),
                  @has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                       (p x))
                    (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55          from prod_bij (λ a _, swap i j a) (λ _ _, mem_univ _) (by simp [this])</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='finset.prod_bij'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 277, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} {γ : Type u} [_inst_1 : comm_monoid.{v} β] {s : finset.{u} α} {t : finset.{u} γ} {f : α → β} {g : γ → β} (i : Π (a : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s → γ), (∀ (a : α) (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @has_mem.mem.{u u} γ (finset.{u} γ) (@finset.has_mem.{u} γ) (i a ha) t) → (∀ (a : α) (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @eq.{v+1} β (f a) (g (i a ha))) → (∀ (a₁ a₂ : α) (ha₁ : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a₁ s) (ha₂ : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a₂ s), @eq.{u+1} γ (i a₁ ha₁) (i a₂ ha₂) → @eq.{u+1} α a₁ a₂) → (∀ (b : γ), @has_mem.mem.{u u} γ (finset.{u} γ) (@finset.has_mem.{u} γ) b t → @Exists.{u+1} α (λ (a : α), @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s) (λ (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @eq.{u+1} γ b (i a ha)))) → @eq.{v+1} β (@finset.prod.{u v} α β _inst_1 s f) (@finset.prod.{u v} γ β _inst_1 t g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : n), @eq.{u+1} n (p (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j) a)) (p a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (x : n),
                  @has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                       (p x))
                    (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
this :
  ∀ (a : n),
    @eq.{u+1} n
      (p
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            a))
      (p a)
⊢ ∀ (a : n),
    @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) →
    @eq.{v+1} R (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ a) (p a))
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@has_mul.mul.{u} (equiv.perm.{u+1} n)
               (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                  (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                     (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
               σ
               (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j))
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
               (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
               a))
         (p
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
               (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
               a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (x : n),
                  @has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                       (p x))
                    (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56            (λ _ _ _ _ h, (swap i j).injective h)</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (x : n),
                  @has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                       (p x))
                    (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57            (λ b _, ⟨swap i j b, mem_univ _, by simp⟩),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='equiv.swap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 846, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : decidable_eq.{u+1} α], α → α → equiv.perm.{u+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`swap a b` is the permutation that swaps `a` and `b` and
 leaves other values as is.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (x : n),
                  @has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                       (p x))
                    (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
this :
  ∀ (a : n),
    @eq.{u+1} n
      (p
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            a))
      (p a),
b : n,
_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) b (@finset.univ.{u} n _inst_1)
⊢ @eq.{u+1} n b
    (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
       (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
          b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (x : n),
                  @has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                       (p x))
                    (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58        by simp [sign_mul, this, sign_swap hij, prod_mul_distrib])</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='equiv.perm.sign_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.perm.sign_swap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hij'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.prod_mul_distrib'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/perm/sign.lean&#x27;, &#x27;line&#x27;: 473, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/perm/sign.lean&#x27;, &#x27;line&#x27;: 485, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 169, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : decidable_eq.{?l_1+1} α] [_inst_2 : fintype.{?l_1} α] (f g : equiv.perm.{?l_1+1} α), @eq.{1} (@units.{0} int int.monoid) (@equiv.perm.sign.{?l_1} α (λ (a b : α), _inst_1 a b) _inst_2 (@has_mul.mul.{?l_1} (equiv.perm.{?l_1+1} α) (@semigroup.to_has_mul.{?l_1} (equiv.perm.{?l_1+1} α) (@monoid.to_semigroup.{?l_1} (equiv.perm.{?l_1+1} α) (@group.to_monoid.{?l_1} (equiv.perm.{?l_1+1} α) (@equiv.perm.perm_group.{?l_1} α)))) f g)) (@has_mul.mul.{0} (@units.{0} int int.monoid) (@units.has_mul.{0} int int.monoid) (@equiv.perm.sign.{?l_1} α (λ (a b : α), _inst_1 a b) _inst_2 f) (@equiv.perm.sign.{?l_1} α (λ (a b : α), _inst_1 a b) _inst_2 g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} R (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3)) (@finset.univ.{u} n _inst_1) (λ (x : n), M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x) (p x))) (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3)) (@finset.univ.{u} n _inst_1) (λ (x : n), M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) (@has_mul.mul.{u} (equiv.perm.{u+1} n) (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n) (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n) (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))) σ (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)) x) (p x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : fintype.{u} α] {x y : α}, @ne.{u+1} α x y → @eq.{1} (@units.{0} int int.monoid) (@equiv.perm.sign.{u} α (λ (a b : α), _inst_1 a b) _inst_2 (@equiv.swap.{u+1} α (λ (a b : α), _inst_1 a b) x y)) (@has_neg.neg.{0} (@units.{0} int int.monoid) (@units.has_neg.{0} int int.ring) (@has_one.one.{0} (@units.{0} int int.monoid) (@units.has_one.{0} int int.monoid)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{u+1} n i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {s : finset.{?l_1} α} {f g : α → β} [_inst_1 : comm_monoid.{?l_2} β], @eq.{?l_2+1} β (@finset.prod.{?l_1 ?l_2} α β _inst_1 s (λ (x : α), @has_mul.mul.{?l_2} β (@semigroup.to_has_mul.{?l_2} β (@monoid.to_semigroup.{?l_2} β (@comm_monoid.to_monoid.{?l_2} β _inst_1))) (f x) (g x))) (@has_mul.mul.{?l_2} β (@semigroup.to_has_mul.{?l_2} β (@monoid.to_semigroup.{?l_2} β (@comm_monoid.to_monoid.{?l_2} β _inst_1))) (@finset.prod.{?l_1 ?l_2} α β _inst_1 s f) (@finset.prod.{?l_1 ?l_2} α β _inst_1 s g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (x : n),
                  @has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                       (p x))
                    (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
this :
  ∀ (a : n),
    @eq.{u+1} n
      (p
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            a))
      (p a),
this :
  @eq.{v+1} R
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (x : n),
          M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x) (p x)))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (x : n),
          M
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
               (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                  (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  σ
                  (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j))
               x)
            (p x)))
⊢ @eq.{v+1} R
    (@has_add.add.{v} R
       (@add_semigroup.to_has_add.{v} R
          (@add_monoid.to_add_semigroup.{v} R
             (@add_comm_monoid.to_add_monoid.{v} R
                (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@has_mul.mul.{v} R
          (@mul_zero_class.to_has_mul.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
          (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
             (@finset.univ.{u} n _inst_1)
             (λ (x : n),
                @has_mul.mul.{v} R
                  (@mul_zero_class.to_has_mul.{v} R
                     (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                  (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                     (p x))
                  (N (p x) x))))
       (@has_mul.mul.{v} R
          (@mul_zero_class.to_has_mul.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
                   (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                      (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                         (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                            (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                      σ
                      (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)))))
          (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
             (@finset.univ.{u} n _inst_1)
             (λ (x : n),
                @has_mul.mul.{v} R
                  (@mul_zero_class.to_has_mul.{v} R
                     (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                  (M
                     (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                        (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                           (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                              (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                                 (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                           σ
                           (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j))
                        x)
                     (p x))
                  (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (x : n),
                  @has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                       (p x))
                    (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59      (λ σ _ _ h, hij (σ.injective $ by conv {to_lhs, rw ← h}; simp))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='equiv.injective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 64, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 65, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α β : Type u} (f : equiv.{u+1 u+1} α β), @function.injective.{u+1 u+1} α β (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} α β) (@equiv.has_coe_to_fun.{u+1 u+1} α β) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (equiv.perm.{u+1} n) (@has_mul.mul.{u} (equiv.perm.{u+1} n) (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n) (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n) (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))) σ (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)) σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='to_lhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (x : n),
                  @has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                       (p x))
                    (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
_x :
  @ne.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (x : n),
             @has_mul.mul.{v} R
               (@mul_zero_class.to_has_mul.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x) (p x))
               (N (p x) x))))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))),
h :
  @eq.{u+1} (equiv.perm.{u+1} n)
    (@has_mul.mul.{u} (equiv.perm.{u+1} n)
       (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
          (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
             (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
       σ
       (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j))
    σ
⊢ @eq.{u+1} n (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
    (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
_x :
  @ne.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (x : n),
             @has_mul.mul.{v} R
               (@mul_zero_class.to_has_mul.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x) (p x))
               (N (p x) x))))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))),
h :
  @eq.{u+1} (equiv.perm.{u+1} n)
    (@has_mul.mul.{u} (equiv.perm.{u+1} n)
       (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
          (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
             (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
       σ
       (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j))
    σ
| @eq.{u+1} n (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
    (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
_x :
  @ne.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (x : n),
             @has_mul.mul.{v} R
               (@mul_zero_class.to_has_mul.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x) (p x))
               (N (p x) x))))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))),
h :
  @eq.{u+1} (equiv.perm.{u+1} n)
    (@has_mul.mul.{u} (equiv.perm.{u+1} n)
       (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
          (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
             (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
       σ
       (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j))
    σ
| @coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
_x :
  @ne.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (x : n),
             @has_mul.mul.{v} R
               (@mul_zero_class.to_has_mul.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x) (p x))
               (N (p x) x))))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))),
h :
  @eq.{u+1} (equiv.perm.{u+1} n)
    (@has_mul.mul.{u} (equiv.perm.{u+1} n)
       (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
          (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
             (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
       σ
       (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j))
    σ
| @coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
    (@has_mul.mul.{u} (equiv.perm.{u+1} n)
       (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
          (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
             (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
       σ
       (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j))
    i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
_x :
  @ne.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (x : n),
             @has_mul.mul.{v} R
               (@mul_zero_class.to_has_mul.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x) (p x))
               (N (p x) x))))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))),
h :
  @eq.{u+1} (equiv.perm.{u+1} n)
    (@has_mul.mul.{u} (equiv.perm.{u+1} n)
       (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
          (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
             (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
       σ
       (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j))
    σ
⊢ @eq.{u+1} n (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
    (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (x : n),
                  @has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                       (p x))
                    (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60      (λ _ _, mem_univ _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='finset.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : fintype.{u} α] (x : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x (@finset.univ.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (x : n),
                  @has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                       (p x))
                    (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61      (λ _ _, equiv.ext _ _ $ by simp)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='equiv.ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 50, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f g : equiv.{u+1 u+1} α β), (∀ (x : α), @eq.{u+1} β (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} α β) (@equiv.has_coe_to_fun.{u+1 u+1} α β) f x) (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} α β) (@equiv.has_coe_to_fun.{u+1 u+1} α β) g x)) → @eq.{(max 1 (u+1))} (equiv.{u+1 u+1} α β) f g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (x : n),
                  @has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                       (p x))
                    (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j,
_x : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    _x
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
⊢ ∀ (x : n),
    @eq.{u+1} n
      (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@has_mul.mul.{u} (equiv.perm.{u+1} n)
               (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                  (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                     (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
               _x
               (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j))
         x)
      (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) _x x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
p : n → n,
H : not (@function.bijective.{u+1 u+1} n n p),
i j : n,
hpij : @eq.{u+1} n (p i) (p j),
hij : @ne.{u+1} n i j
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (x : n),
                  @has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x)
                       (p x))
                    (N (p x) x)))))
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  @[simp] lemma det_mul (M N : matrix n n R) : det (M * N) = det M * det N :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='matrix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='matrix.det'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='matrix.det'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='matrix.det'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/basic.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Π (m n : Type u) [_inst_1 : fintype.{u} m] [_inst_2 : fintype.{u} n], Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {n : Type u} [_inst_1 : fintype.{u} n] [_inst_2 : decidable_eq.{u+1} n] {R : Type v} [_inst_3 : comm_ring.{v} R], @matrix.{u v} n n _inst_1 _inst_1 R → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u v)} [c : has_mul.{(max u v)} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {n : Type u} [_inst_1 : fintype.{u} n] [_inst_2 : decidable_eq.{u+1} n] {R : Type v} [_inst_3 : comm_ring.{v} R], @matrix.{u v} n n _inst_1 _inst_1 R → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {n : Type u} [_inst_1 : fintype.{u} n] [_inst_2 : decidable_eq.{u+1} n] {R : Type v} [_inst_3 : comm_ring.{v} R], @matrix.{u v} n n _inst_1 _inst_1 R → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='The determinant of a matrix given by the Leibniz formula.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The determinant of a matrix given by the Leibniz formula.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The determinant of a matrix given by the Leibniz formula.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  calc det (M * N) = univ.sum (λ σ : perm n, (univ.pi (λ a, univ)).sum</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='matrix.det'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='equiv.perm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.pi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 1463, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {n : Type u} [_inst_1 : fintype.{u} n] [_inst_2 : decidable_eq.{u+1} n] {R : Type v} [_inst_3 : comm_ring.{v} R], @matrix.{u v} n n _inst_1 _inst_1 R → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u v)} [c : has_mul.{(max u v)} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {δ : α → Type u} [_inst_1 : decidable_eq.{u+1} α] (s : finset.{u} α), (Π (a : α), finset.{u} (δ a)) → finset.{u} (Π (a : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s → δ a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The determinant of a matrix given by the Leibniz formula.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`perm α` is the type of bijections from `α` to itself.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66      (λ (p : Π (a : n), a ∈ univ → n), ε σ *</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='∀ (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67      univ.attach.prod (λ i, M (σ i.1) (p i.1 (mem_univ _)) * N (p i.1 (mem_univ _)) i.1))) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.attach'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='finset.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='finset.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 622, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} (s : finset.{u} α), finset.{u} (@subtype.{u+1} α (λ (x : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@subtype.{u+1} n (λ (x : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) x (@finset.univ.{u} n _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@subtype.{u+1} n (λ (x : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) x (@finset.univ.{u} n _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {p : α → Prop}, @subtype.{u+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@subtype.{u+1} n (λ (x : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) x (@finset.univ.{u} n _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {p : α → Prop}, @subtype.{u+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : fintype.{u} α] (x : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x (@finset.univ.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@subtype.{u+1} n (λ (x : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) x (@finset.univ.{u} n _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {p : α → Prop}, @subtype.{u+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : fintype.{u} α] (x : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x (@finset.univ.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@subtype.{u+1} n (λ (x : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) x (@finset.univ.{u} n _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {p : α → Prop}, @subtype.{u+1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`attach s` takes the elements of `s` and forms a new set of elements of the
 subtype `{x // x ∈ s}`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`prod s f` is the product of `f x` as `x` ranges over the elements of the finite set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68    by simp only [det, mul_val&#x27;, prod_sum, mul_sum]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='matrix.det'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='matrix.mul_val&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.prod_sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.mul_sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/basic.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 653, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 626, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : Type ?l_1} [_inst_1 : fintype.{?l_1} n] [_inst_2 : decidable_eq.{?l_1+1} n] {R : Type ?l_2} [_inst_3 : comm_ring.{?l_2} R], @matrix.{?l_1 ?l_2} n n _inst_1 _inst_1 R → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : Type ?l_1} [_inst_3 : fintype.{?l_1} n] {α : Type ?l_2} [_inst_5 : has_mul.{?l_2} α] [_inst_6 : add_comm_monoid.{?l_2} α] {M N : @matrix.{?l_1 ?l_2} n n _inst_3 _inst_3 α} {i k : n}, @eq.{?l_2+1} α (@has_mul.mul.{(max ?l_1 ?l_2)} (@matrix.{?l_1 ?l_2} n n _inst_3 _inst_3 α) (@matrix.has_mul.{?l_1 ?l_2} n _inst_3 α _inst_5 _inst_6) M N i k) (@finset.sum.{?l_1 ?l_2} n α _inst_6 (@finset.univ.{?l_1} n _inst_3) (λ (j : n), @has_mul.mul.{?l_2} α _inst_5 (M i j) (N j k)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : decidable_eq.{?l_1+1} α] [_inst_2 : comm_semiring.{?l_2} β] {δ : α → Type ?l_3} [_inst_3 : Π (a : α), decidable_eq.{?l_3+1} (δ a)] {s : finset.{?l_1} α} {t : Π (a : α), finset.{?l_3} (δ a)} {f : Π (a : α), δ a → β}, @eq.{?l_2+1} β (@finset.prod.{?l_1 ?l_2} α β (@comm_semiring.to_comm_monoid.{?l_2} β _inst_2) s (λ (a : α), @finset.sum.{?l_3 ?l_2} (δ a) β (@semiring.to_add_comm_monoid.{?l_2} β (@comm_semiring.to_semiring.{?l_2} β _inst_2)) (t a) (λ (b : δ a), f a b))) (@finset.sum.{(max ?l_1 ?l_3) ?l_2} (Π (a : α), @has_mem.mem.{?l_1 ?l_1} α (finset.{?l_1} α) (@finset.has_mem.{?l_1} α) a s → δ a) β (@semiring.to_add_comm_monoid.{?l_2} β (@comm_semiring.to_semiring.{?l_2} β _inst_2)) (@finset.pi.{?l_1 ?l_3} α (λ (a : α), δ a) (λ (a b : α), _inst_1 a b) s t) (λ (p : Π (a : α), @has_mem.mem.{?l_1 ?l_1} α (finset.{?l_1} α) (@finset.has_mem.{?l_1} α) a s → δ a), @finset.prod.{?l_1 ?l_2} (@subtype.{?l_1+1} α (λ (x : α), @has_mem.mem.{?l_1 ?l_1} α (finset.{?l_1} α) (@finset.has_mem.{?l_1} α) x s)) β (@comm_semiring.to_comm_monoid.{?l_2} β _inst_2) (@finset.attach.{?l_1} α s) (λ (x : @subtype.{?l_1+1} α (λ (x : α), @has_mem.mem.{?l_1 ?l_1} α (finset.{?l_1} α) (@finset.has_mem.{?l_1} α) x s)), f (@subtype.val.{?l_1+1} α (λ (x : α), @has_mem.mem.{?l_1 ?l_1} α (finset.{?l_1} α) (@finset.has_mem.{?l_1} α) x s) x) (p (@subtype.val.{?l_1+1} α (λ (x : α), @has_mem.mem.{?l_1 ?l_1} α (finset.{?l_1} α) (@finset.has_mem.{?l_1} α) x s) x) (@subtype.property.{?l_1+1} α (λ (x : α), @has_mem.mem.{?l_1 ?l_1} α (finset.{?l_1} α) (@finset.has_mem.{?l_1} α) x s) x)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {s : finset.{?l_1} α} {f : α → β} {b : β} [_inst_1 : semiring.{?l_2} β], @eq.{?l_2+1} β (@has_mul.mul.{?l_2} β (@mul_zero_class.to_has_mul.{?l_2} β (@semiring.to_mul_zero_class.{?l_2} β _inst_1)) b (@finset.sum.{?l_1 ?l_2} α β (@semiring.to_add_comm_monoid.{?l_2} β _inst_1) s f)) (@finset.sum.{?l_1 ?l_2} α β (@semiring.to_add_comm_monoid.{?l_2} β _inst_1) s (λ (x : α), @has_mul.mul.{?l_2} β (@mul_zero_class.to_has_mul.{?l_2} β (@semiring.to_mul_zero_class.{?l_2} β _inst_1)) b (f x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The determinant of a matrix given by the Leibniz formula.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (@has_mul.mul.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
          (@matrix.has_mul.{u v} n _inst_1 R
             (@mul_zero_class.to_has_mul.{v} R
                (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          M
          N))
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @finset.sum.{u v}
            (Π (a : n),
               @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n)
            R
            (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
            (@finset.pi.{u u} n (λ (a : n), n) (λ (a b : n), _inst_2 a b) (@finset.univ.{u} n _inst_1)
               (λ (a : n), @finset.univ.{u} n _inst_1))
            (λ
             (p :
               Π (a : n),
                 @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n),
               @has_mul.mul.{v} R
                 (@mul_zero_class.to_has_mul.{v} R
                    (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                 (@coe.{1 v+1} int R
                    (@coe_to_lift.{1 v+1} int R
                       (@coe_base.{1 v+1} int R
                          (@int.cast_coe.{v} R
                             (@add_group.to_has_neg.{v} R
                                (@add_comm_group.to_add_group.{v} R
                                   (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                             (@mul_zero_class.to_has_zero.{v} R
                                (@semiring.to_mul_zero_class.{v} R
                                   (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                             (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                             (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
                    (@coe.{1 1} (@units.{0} int int.monoid) int
                       (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                          (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                       (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
                 (@finset.prod.{u v}
                    (@subtype.{u+1} n
                       (λ (x : n),
                          @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) x (@finset.univ.{u} n _inst_1)))
                    R
                    (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
                    (@finset.attach.{u} n (@finset.univ.{u} n _inst_1))
                    (λ
                     (i :
                       @subtype.{u+1} n
                         (λ (x : n),
                            @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) x
                              (@finset.univ.{u} n _inst_1))),
                       @has_mul.mul.{v} R
                         (@mul_zero_class.to_has_mul.{v} R
                            (@semiring.to_mul_zero_class.{v} R
                               (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                         (M
                            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ
                               (@subtype.val.{u+1} n
                                  (λ (x : n),
                                     @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) x
                                       (@finset.univ.{u} n _inst_1))
                                  i))
                            (p
                               (@subtype.val.{u+1} n
                                  (λ (x : n),
                                     @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) x
                                       (@finset.univ.{u} n _inst_1))
                                  i)
                               (@finset.mem_univ.{u} n _inst_1
                                  (@subtype.val.{u+1} n
                                     (λ (x : n),
                                        @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) x
                                          (@finset.univ.{u} n _inst_1))
                                     i))))
                         (N
                            (p
                               (@subtype.val.{u+1} n
                                  (λ (x : n),
                                     @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) x
                                       (@finset.univ.{u} n _inst_1))
                                  i)
                               (@finset.mem_univ.{u} n _inst_1
                                  (@subtype.val.{u+1} n
                                     (λ (x : n),
                                        @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) x
                                          (@finset.univ.{u} n _inst_1))
                                     i)))
                            (@subtype.val.{u+1} n
                               (λ (x : n),
                                  @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) x
                                    (@finset.univ.{u} n _inst_1))
                               i)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  ... = univ.sum (λ σ : perm n, univ.sum</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='equiv.perm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`perm α` is the type of bijections from `α` to itself.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70      (λ p : n → n, ε σ * univ.prod (λ i, M (σ i) (p i) * N (p i) i))) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='n → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='n → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`prod s f` is the product of `f x` as `x` ranges over the elements of the finite set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71    sum_congr rfl (λ σ _, sum_bij</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.sum_congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.sum_bij'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 76, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 277, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {β : Type v} {s₁ s₂ : finset.{u} α} {f g : α → β} [_inst_1 : add_comm_monoid.{v} β], @eq.{u+1} (finset.{u} α) s₁ s₂ → (∀ (x : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x s₂ → @eq.{v+1} β (f x) (g x)) → @eq.{v+1} β (@finset.sum.{u v} α β _inst_1 s₁ f) (@finset.sum.{u v} α β _inst_1 s₂ g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n)) σ (@finset.univ.{u} (equiv.perm.{u+1} n) (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {β : Type v} {γ : Type u} [_inst_1 : add_comm_monoid.{v} β] {s : finset.{u} α} {t : finset.{u} γ} {f : α → β} {g : γ → β} (i : Π (a : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s → γ), (∀ (a : α) (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @has_mem.mem.{u u} γ (finset.{u} γ) (@finset.has_mem.{u} γ) (i a ha) t) → (∀ (a : α) (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @eq.{v+1} β (f a) (g (i a ha))) → (∀ (a₁ a₂ : α) (ha₁ : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a₁ s) (ha₂ : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a₂ s), @eq.{u+1} γ (i a₁ ha₁) (i a₂ ha₂) → @eq.{u+1} α a₁ a₂) → (∀ (b : γ), @has_mem.mem.{u u} γ (finset.{u} γ) (@finset.has_mem.{u} γ) b t → @Exists.{u+1} α (λ (a : α), @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s) (λ (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @eq.{u+1} γ b (i a ha)))) → @eq.{v+1} β (@finset.sum.{u v} α β _inst_1 s f) (@finset.sum.{u v} γ β _inst_1 t g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72      (λ f h i, f i (mem_univ _)) (λ _ _, mem_univ _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='∀ (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (∀ (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n) (finset.{u} (∀ (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n)) (@finset.has_mem.{u} (∀ (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n)) f (@finset.pi.{u u} n (λ (a : n), n) (λ (a b : n), _inst_2 a b) (@finset.univ.{u} n _inst_1) (λ (a : n), @finset.univ.{u} n _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : fintype.{u} α] (x : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x (@finset.univ.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='∀ (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (∀ (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n) (finset.{u} (∀ (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n)) (@finset.has_mem.{u} (∀ (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n)) _x (@finset.pi.{u u} n (λ (a : n), n) (λ (a b : n), _inst_2 a b) (@finset.univ.{u} n _inst_1) (λ (a : n), @finset.univ.{u} n _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : fintype.{u} α] (x : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x (@finset.univ.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73      (by simp) (by simp [funext_iff]) (λ b _, ⟨λ i hi, b i, by simp⟩))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='function.funext_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/function.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {β : α → Sort ?l_2} {f₁ f₂ : Π (x : α), β x}, iff (@eq.{(imax ?l_1 ?l_2)} (Π (x : α), β x) f₁ f₂) (∀ (a : α), @eq.{?l_2} (β a) (f₁ a) (f₂ a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='n → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) b (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='n → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
⊢ ∀
  (a : Π (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n),
    @has_mem.mem.{u u}
      (Π (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n)
      (finset.{u}
         (Π (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n))
      (@finset.has_mem.{u}
         (Π (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n))
      a
      (@finset.pi.{u u} n (λ (a : n), n) (λ (a b : n), _inst_2 a b) (@finset.univ.{u} n _inst_1)
         (λ (a : n), @finset.univ.{u} n _inst_1)) →
    @eq.{v+1} R
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} int R
            (@coe_to_lift.{1 v+1} int R
               (@coe_base.{1 v+1} int R
                  (@int.cast_coe.{v} R
                     (@add_group.to_has_neg.{v} R
                        (@add_comm_group.to_add_group.{v} R
                           (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                     (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
            (@coe.{1 1} (@units.{0} int int.monoid) int
               (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                  (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
               (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
         (@finset.prod.{u v}
            (@subtype.{u+1} n
               (λ (x : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) x (@finset.univ.{u} n _inst_1)))
            R
            (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
            (@finset.attach.{u} n (@finset.univ.{u} n _inst_1))
            (λ
             (i :
               @subtype.{u+1} n
                 (λ (x : n),
                    @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) x (@finset.univ.{u} n _inst_1))),
               @has_mul.mul.{v} R
                 (@mul_zero_class.to_has_mul.{v} R
                    (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                 (M
                    (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ
                       (@subtype.val.{u+1} n
                          (λ (x : n),
                             @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) x (@finset.univ.{u} n _inst_1))
                          i))
                    (a
                       (@subtype.val.{u+1} n
                          (λ (x : n),
                             @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) x (@finset.univ.{u} n _inst_1))
                          i)
                       (@finset.mem_univ.{u} n _inst_1
                          (@subtype.val.{u+1} n
                             (λ (x : n),
                                @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) x
                                  (@finset.univ.{u} n _inst_1))
                             i))))
                 (N
                    (a
                       (@subtype.val.{u+1} n
                          (λ (x : n),
                             @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) x (@finset.univ.{u} n _inst_1))
                          i)
                       (@finset.mem_univ.{u} n _inst_1
                          (@subtype.val.{u+1} n
                             (λ (x : n),
                                @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) x
                                  (@finset.univ.{u} n _inst_1))
                             i)))
                    (@subtype.val.{u+1} n
                       (λ (x : n),
                          @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) x (@finset.univ.{u} n _inst_1))
                       i)))))
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} int R
            (@coe_to_lift.{1 v+1} int R
               (@coe_base.{1 v+1} int R
                  (@int.cast_coe.{v} R
                     (@add_group.to_has_neg.{v} R
                        (@add_comm_group.to_add_group.{v} R
                           (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                     (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
            (@coe.{1 1} (@units.{0} int int.monoid) int
               (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                  (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
               (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
         (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
            (@finset.univ.{u} n _inst_1)
            (λ (i : n),
               @has_mul.mul.{v} R
                 (@mul_zero_class.to_has_mul.{v} R
                    (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                 (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
                    (a i (@finset.mem_univ.{u} n _inst_1 i)))
                 (N (a i (@finset.mem_univ.{u} n _inst_1 i)) i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
⊢ ∀
  (a₁ a₂ :
    Π (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n),
    @has_mem.mem.{u u}
      (Π (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n)
      (finset.{u}
         (Π (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n))
      (@finset.has_mem.{u}
         (Π (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n))
      a₁
      (@finset.pi.{u u} n (λ (a : n), n) (λ (a b : n), _inst_2 a b) (@finset.univ.{u} n _inst_1)
         (λ (a : n), @finset.univ.{u} n _inst_1)) →
    @has_mem.mem.{u u}
      (Π (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n)
      (finset.{u}
         (Π (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n))
      (@finset.has_mem.{u}
         (Π (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n))
      a₂
      (@finset.pi.{u u} n (λ (a : n), n) (λ (a b : n), _inst_2 a b) (@finset.univ.{u} n _inst_1)
         (λ (a : n), @finset.univ.{u} n _inst_1)) →
    @eq.{u+1} (n → n) (λ (i : n), a₁ i (@finset.mem_univ.{u} n _inst_1 i))
      (λ (i : n), a₂ i (@finset.mem_univ.{u} n _inst_1 i)) →
    @eq.{u+1}
      (Π (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n)
      a₁
      a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
b : n → n,
_x :
  @has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) b
    (@finset.univ.{u} (n → n)
       (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1)))
⊢ @Exists.{0}
    (@has_mem.mem.{u u}
       (Π (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n)
       (finset.{u}
          (Π (a : n),
             @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n))
       (@finset.has_mem.{u}
          (Π (a : n),
             @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n))
       (λ (i : n) (hi : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
          b i)
       (@finset.pi.{u u} n (λ (a : n), n) (λ (a b : n), _inst_2 a b) (@finset.univ.{u} n _inst_1)
          (λ (a : n), @finset.univ.{u} n _inst_1)))
    (λ
     (ha :
       @has_mem.mem.{u u}
         (Π (a : n), @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n)
         (finset.{u}
            (Π (a : n),
               @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n))
         (@finset.has_mem.{u}
            (Π (a : n),
               @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1) → n))
         (λ (i : n) (hi : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
            b i)
         (@finset.pi.{u u} n (λ (a : n), n) (λ (a b : n), _inst_2 a b) (@finset.univ.{u} n _inst_1)
            (λ (a : n), @finset.univ.{u} n _inst_1))), @eq.{u+1} (n → n) b (λ (i : n), b i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  ... = univ.sum (λ p : n → n, univ.sum</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75      (λ σ : perm n, ε σ * univ.prod (λ i, M (σ i) (p i) * N (p i) i))) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='equiv.perm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='n → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='n → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`perm α` is the type of bijections from `α` to itself.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`prod s f` is the product of `f x` as `x` ranges over the elements of the finite set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76    finset.sum_comm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.sum_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 173, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {β : Type v} {γ : Type u} [_inst_1 : add_comm_monoid.{v} β] [_inst_2 : decidable_eq.{u+1} γ] {s : finset.{u} γ} {t : finset.{u} α} {f : γ → α → β}, @eq.{v+1} β (@finset.sum.{u v} γ β _inst_1 s (λ (x : γ), @finset.sum.{u v} α β _inst_1 t (f x))) (@finset.sum.{u v} α β _inst_1 t (λ (y : α), @finset.sum.{u v} γ β _inst_1 s (λ (x : γ), f x y)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  ... = ((@univ (n → n) _).filter bijective).sum (λ p : n → n, univ.sum</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='finset.filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='function.bijective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finset.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 705, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/function.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} (p : α → Prop) [_inst_3 : @decidable_pred.{u+1} α p], finset.{u} α → finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u}, (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`filter p s` is the set of elements of `s` that satisfy `p`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78      (λ σ : perm n, ε σ * univ.prod (λ i, M (σ i) (p i) * N (p i) i))) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='equiv.perm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='n → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='n → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`perm α` is the type of bijections from `α` to itself.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`prod s f` is the product of `f x` as `x` ranges over the elements of the finite set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79    eq.symm $ sum_subset (filter_subset _) </code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='finset.sum_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.filter_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 189, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 712, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type v} {a b : α}, @eq.{v+1} α a b → @eq.{v+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} {β : Type v} {s₁ s₂ : finset.{u} α} {f : α → β} [_inst_1 : add_comm_monoid.{v} β], @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) s₁ s₂ → (∀ (x : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x s₂ → not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x s₁) → @eq.{v+1} β (f x) (@has_zero.zero.{v} β (@add_monoid.to_has_zero.{v} β (@add_comm_monoid.to_add_monoid.{v} β _inst_1)))) → @eq.{v+1} β (@finset.sum.{u v} α β _inst_1 s₁ f) (@finset.sum.{u v} α β _inst_1 s₂ f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {p : α → Prop} [_inst_1 : @decidable_pred.{u+1} α p] (s : finset.{u} α), @has_subset.subset.{u} (finset.{u} α) (@finset.has_subset.{u} α) (@finset.filter.{u} α p (λ (a : α), _inst_1 a) s) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80      (λ f _ hbij, det_mul_aux $ by simpa using hbij)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hbij'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='matrix.det_mul_aux'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='hbij'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;line&#x27;: 43, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='n → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) f (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) f (@finset.filter.{u} (n → n) (@function.bijective.{u+1 u+1} n n) (λ (a : n → n), @fintype.decidable_bijective_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) _inst_1 (λ (a b : n), _inst_2 a b) a) (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {n : Type u} [_inst_1 : fintype.{u} n] [_inst_2 : decidable_eq.{u+1} n] {R : Type v} [_inst_3 : comm_ring.{v} R] {M N : @matrix.{u v} n n _inst_1 _inst_1 R} {p : n → n}, not (@function.bijective.{u+1 u+1} n n p) → @eq.{v+1} R (@finset.sum.{u v} (equiv.perm.{u+1} n) R (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))) (@finset.univ.{u} (equiv.perm.{u+1} n) (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)) (λ (σ : equiv.perm.{u+1} n), @has_mul.mul.{v} R (@mul_zero_class.to_has_mul.{v} R (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (@coe.{1 v+1} int R (@coe_to_lift.{1 v+1} int R (@coe_base.{1 v+1} int R (@int.cast_coe.{v} R (@add_group.to_has_neg.{v} R (@add_comm_group.to_add_group.{v} R (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (@mul_zero_class.to_has_zero.{v} R (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))) (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))) (@coe.{1 1} (@units.{0} int int.monoid) int (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid))) (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))) (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3)) (@finset.univ.{u} n _inst_1) (λ (x : n), @has_mul.mul.{v} R (@mul_zero_class.to_has_mul.{v} R (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ x) (p x)) (N (p x) x))))) (@has_zero.zero.{v} R (@mul_zero_class.to_has_zero.{v} R (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) f (@finset.filter.{u} (n → n) (@function.bijective.{u+1 u+1} n n) (λ (a : n → n), @fintype.decidable_bijective_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) _inst_1 (λ (a b : n), _inst_2 a b) a) (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
f : n → n,
_x :
  @has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) f
    (@finset.univ.{u} (n → n)
       (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1))),
hbij :
  not
    (@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) f
       (@finset.filter.{u} (n → n) (@function.bijective.{u+1 u+1} n n)
          (λ (a : n → n),
             @fintype.decidable_bijective_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) _inst_1
               (λ (a b : n), _inst_2 a b)
               a)
          (@finset.univ.{u} (n → n)
             (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1)))))
⊢ not (@function.bijective.{u+1 u+1} n n (λ (i : n), f i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  ... = (@univ (perm n) _).sum (λ τ, univ.sum</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.perm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='finset.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`perm α` is the type of bijections from `α` to itself.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82      (λ σ : perm n, ε σ * univ.prod (λ i, M (σ i) (τ i) * N (τ i) i))) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='equiv.perm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`perm α` is the type of bijections from `α` to itself.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`prod s f` is the product of `f x` as `x` ranges over the elements of the finite set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83    sum_bij (λ p h, equiv.of_bijective (mem_filter.1 h).2) (λ _ _, mem_univ _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.sum_bij'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.of_bijective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.mem_filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and.right'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 277, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 808, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 710, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {β : Type v} {γ : Type u} [_inst_1 : add_comm_monoid.{v} β] {s : finset.{u} α} {t : finset.{u} γ} {f : α → β} {g : γ → β} (i : Π (a : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s → γ), (∀ (a : α) (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @has_mem.mem.{u u} γ (finset.{u} γ) (@finset.has_mem.{u} γ) (i a ha) t) → (∀ (a : α) (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @eq.{v+1} β (f a) (g (i a ha))) → (∀ (a₁ a₂ : α) (ha₁ : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a₁ s) (ha₂ : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a₂ s), @eq.{u+1} γ (i a₁ ha₁) (i a₂ ha₂) → @eq.{u+1} α a₁ a₂) → (∀ (b : γ), @has_mem.mem.{u u} γ (finset.{u} γ) (@finset.has_mem.{u} γ) b t → @Exists.{u+1} α (λ (a : α), @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s) (λ (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @eq.{u+1} γ b (i a ha)))) → @eq.{v+1} β (@finset.sum.{u v} α β _inst_1 s f) (@finset.sum.{u v} γ β _inst_1 t g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='n → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) p (@finset.filter.{u} (n → n) (@function.bijective.{u+1 u+1} n n) (λ (a : n → n), @fintype.decidable_bijective_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) _inst_1 (λ (a b : n), _inst_2 a b) a) (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u} {f : α → β}, @function.bijective.{u+1 u+1} α β f → equiv.{u+1 u+1} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {p : α → Prop} [_inst_1 : @decidable_pred.{u+1} α p] {s : finset.{u} α} {a : α}, iff (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a (@finset.filter.{u} α p (λ (a : α), _inst_1 a) s)) (and (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s) (p a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) p (@finset.filter.{u} (n → n) (@function.bijective.{u+1 u+1} n n) (λ (a : n → n), @fintype.decidable_bijective_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) _inst_1 (λ (a b : n), _inst_2 a b) a) (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, and a b → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='n → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x (@finset.filter.{u} (n → n) (@function.bijective.{u+1 u+1} n n) (λ (a : n → n), @fintype.decidable_bijective_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) _inst_1 (λ (a b : n), _inst_2 a b) a) (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : fintype.{u} α] (x : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x (@finset.univ.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84      (λ _ _, rfl) (λ _ _ _ _ h, by injection h)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1036, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='n → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x (@finset.filter.{u} (n → n) (@function.bijective.{u+1 u+1} n n) (λ (a : n → n), @fintype.decidable_bijective_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) _inst_1 (λ (a b : n), _inst_2 a b) a) (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type v} {a : α}, @eq.{v+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='n → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n → n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x (@finset.filter.{u} (n → n) (@function.bijective.{u+1 u+1} n n) (λ (a : n → n), @fintype.decidable_bijective_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) _inst_1 (λ (a b : n), _inst_2 a b) a) (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x (@finset.filter.{u} (n → n) (@function.bijective.{u+1 u+1} n n) (λ (a : n → n), @fintype.decidable_bijective_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) _inst_1 (λ (a b : n), _inst_2 a b) a) (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{u+1} (equiv.perm.{u+1} n) (@equiv.of_bijective.{u+1 u+1} n n _x (@and.right (@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1)))) (@function.bijective.{u+1 u+1} n n _x) (@iff.mp (@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x (@finset.filter.{u} (n → n) (@function.bijective.{u+1 u+1} n n) (λ (a : n → n), @fintype.decidable_bijective_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) _inst_1 (λ (a b : n), _inst_2 a b) a) (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1))))) (and (@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1)))) (@function.bijective.{u+1 u+1} n n _x)) (@finset.mem_filter.{u} (n → n) (@function.bijective.{u+1 u+1} n n) (λ (a : n → n), @fintype.decidable_bijective_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) _inst_1 (λ (a b : n), _inst_2 a b) a) (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1))) _x) _x_1))) (@equiv.of_bijective.{u+1 u+1} n n _x_2 (@and.right (@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x_2 (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1)))) (@function.bijective.{u+1 u+1} n n _x_2) (@iff.mp (@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x_2 (@finset.filter.{u} (n → n) (@function.bijective.{u+1 u+1} n n) (λ (a : n → n), @fintype.decidable_bijective_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) _inst_1 (λ (a b : n), _inst_2 a b) a) (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1))))) (and (@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x_2 (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1)))) (@function.bijective.{u+1 u+1} n n _x_2)) (@finset.mem_filter.{u} (n → n) (@function.bijective.{u+1 u+1} n n) (λ (a : n → n), @fintype.decidable_bijective_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) _inst_1 (λ (a b : n), _inst_2 a b) a) (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1))) _x_2) _x_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} (equiv.perm.{u+1} n) (@equiv.of_bijective.{u+1 u+1} n n _x (@and.right (@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1)))) (@function.bijective.{u+1 u+1} n n _x) (@iff.mp (@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x (@finset.filter.{u} (n → n) (@function.bijective.{u+1 u+1} n n) (λ (a : n → n), @fintype.decidable_bijective_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) _inst_1 (λ (a b : n), _inst_2 a b) a) (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1))))) (and (@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1)))) (@function.bijective.{u+1 u+1} n n _x)) (@finset.mem_filter.{u} (n → n) (@function.bijective.{u+1 u+1} n n) (λ (a : n → n), @fintype.decidable_bijective_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) _inst_1 (λ (a b : n), _inst_2 a b) a) (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1))) _x) _x_1))) (@equiv.of_bijective.{u+1 u+1} n n _x_2 (@and.right (@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x_2 (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1)))) (@function.bijective.{u+1 u+1} n n _x_2) (@iff.mp (@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x_2 (@finset.filter.{u} (n → n) (@function.bijective.{u+1 u+1} n n) (λ (a : n → n), @fintype.decidable_bijective_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) _inst_1 (λ (a b : n), _inst_2 a b) a) (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1))))) (and (@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x_2 (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1)))) (@function.bijective.{u+1 u+1} n n _x_2)) (@finset.mem_filter.{u} (n → n) (@function.bijective.{u+1 u+1} n n) (λ (a : n → n), @fintype.decidable_bijective_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) _inst_1 (λ (a b : n), _inst_2 a b) a) (@finset.univ.{u} (n → n) (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1))) _x_2) _x_3)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='The `injection` tactic is based on the fact that constructors of inductive data types are injections. That means that if `c` is a constructor of an inductive datatype, and if `(c t₁)` and `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.

If `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies injectivity to derive the equality of all arguments of `t₁` and `t₂` placed in the same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`. To use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.

Given `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types `a = c` and `b = d` to the main goal. The tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='injection'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
_x _x : n → n,
_x :
  @has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x
    (@finset.filter.{u} (n → n) (@function.bijective.{u+1 u+1} n n)
       (λ (a : n → n),
          @fintype.decidable_bijective_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) _inst_1
            (λ (a b : n), _inst_2 a b)
            a)
       (@finset.univ.{u} (n → n)
          (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1)))),
_x :
  @has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x
    (@finset.filter.{u} (n → n) (@function.bijective.{u+1 u+1} n n)
       (λ (a : n → n),
          @fintype.decidable_bijective_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) _inst_1
            (λ (a b : n), _inst_2 a b)
            a)
       (@finset.univ.{u} (n → n)
          (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1)))),
h :
  @eq.{u+1} (equiv.perm.{u+1} n)
    (@equiv.of_bijective.{u+1 u+1} n n _x
       (@and.right
          (@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x
             (@finset.univ.{u} (n → n)
                (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1))))
          (@function.bijective.{u+1 u+1} n n _x)
          (@iff.mp
             (@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x
                (@finset.filter.{u} (n → n) (@function.bijective.{u+1 u+1} n n)
                   (λ (a : n → n),
                      @fintype.decidable_bijective_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) _inst_1
                        (λ (a b : n), _inst_2 a b)
                        a)
                   (@finset.univ.{u} (n → n)
                      (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1)))))
             (and
                (@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x
                   (@finset.univ.{u} (n → n)
                      (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1))))
                (@function.bijective.{u+1 u+1} n n _x))
             (@finset.mem_filter.{u} (n → n) (@function.bijective.{u+1 u+1} n n)
                (λ (a : n → n),
                   @fintype.decidable_bijective_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) _inst_1
                     (λ (a b : n), _inst_2 a b)
                     a)
                (@finset.univ.{u} (n → n)
                   (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1)))
                _x)
             _x)))
    (@equiv.of_bijective.{u+1 u+1} n n _x
       (@and.right
          (@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x
             (@finset.univ.{u} (n → n)
                (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1))))
          (@function.bijective.{u+1 u+1} n n _x)
          (@iff.mp
             (@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x
                (@finset.filter.{u} (n → n) (@function.bijective.{u+1 u+1} n n)
                   (λ (a : n → n),
                      @fintype.decidable_bijective_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) _inst_1
                        (λ (a b : n), _inst_2 a b)
                        a)
                   (@finset.univ.{u} (n → n)
                      (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1)))))
             (and
                (@has_mem.mem.{u u} (n → n) (finset.{u} (n → n)) (@finset.has_mem.{u} (n → n)) _x
                   (@finset.univ.{u} (n → n)
                      (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1))))
                (@function.bijective.{u+1 u+1} n n _x))
             (@finset.mem_filter.{u} (n → n) (@function.bijective.{u+1 u+1} n n)
                (λ (a : n → n),
                   @fintype.decidable_bijective_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) _inst_1
                     (λ (a b : n), _inst_2 a b)
                     a)
                (@finset.univ.{u} (n → n)
                   (@pi.fintype.{u u} n (λ (a : n), n) _inst_1 (λ (a b : n), _inst_2 a b) (λ (a : n), _inst_1)))
                _x)
             _x)))
⊢ @eq.{u+1} (n → n) _x _x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85      (λ b _, ⟨b, mem_filter.2 ⟨mem_univ _, b.bijective⟩, eq_of_to_fun_eq rfl⟩)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.mem_filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='finset.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='equiv.bijective'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='equiv.eq_of_to_fun_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 710, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n)) b (@finset.univ.{u} (equiv.perm.{u+1} n) (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {p : α → Prop} [_inst_1 : @decidable_pred.{u+1} α p] {s : finset.{u} α} {a : α}, iff (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a (@finset.filter.{u} α p (λ (a : α), _inst_1 a) s)) (and (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s) (p a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : fintype.{u} α] (x : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x (@finset.univ.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} (f : equiv.{u+1 u+1} α β), @function.bijective.{u+1 u+1} α β (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} α β) (@equiv.has_coe_to_fun.{u+1 u+1} α β) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α β : Type u} {e₁ e₂ : equiv.{u+1 u+1} α β}, @eq.{u+1} (@has_coe_to_fun.F.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} α β) (@equiv.has_coe_to_fun.{u+1 u+1} α β) e₁) (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} α β) (@equiv.has_coe_to_fun.{u+1 u+1} α β) e₁) (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} α β) (@equiv.has_coe_to_fun.{u+1 u+1} α β) e₂) → @eq.{(max 1 (u+1))} (equiv.{u+1 u+1} α β) e₁ e₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  ... = univ.sum (λ σ : perm n, univ.sum (λ τ : perm n,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='equiv.perm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='equiv.perm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`perm α` is the type of bijections from `α` to itself.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`perm α` is the type of bijections from `α` to itself.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87      (univ.prod (λ i, N (σ i) i) * ε τ) * univ.prod (λ j, M (τ j) (σ j)))) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`prod s f` is the product of `f x` as `x` ranges over the elements of the finite set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`prod s f` is the product of `f x` as `x` ranges over the elements of the finite set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88    by simp [mul_sum, det, mul_comm, mul_left_comm, prod_mul_distrib, mul_assoc]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='finset.mul_sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='matrix.det'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_left_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.prod_mul_distrib'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 626, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 169, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {s : finset.{?l_1} α} {f : α → β} {b : β} [_inst_1 : semiring.{?l_2} β], @eq.{?l_2+1} β (@has_mul.mul.{?l_2} β (@mul_zero_class.to_has_mul.{?l_2} β (@semiring.to_mul_zero_class.{?l_2} β _inst_1)) b (@finset.sum.{?l_1 ?l_2} α β (@semiring.to_add_comm_monoid.{?l_2} β _inst_1) s f)) (@finset.sum.{?l_1 ?l_2} α β (@semiring.to_add_comm_monoid.{?l_2} β _inst_1) s (λ (x : α), @has_mul.mul.{?l_2} β (@mul_zero_class.to_has_mul.{?l_2} β (@semiring.to_mul_zero_class.{?l_2} β _inst_1)) b (f x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : Type ?l_1} [_inst_1 : fintype.{?l_1} n] [_inst_2 : decidable_eq.{?l_1+1} n] {R : Type ?l_2} [_inst_3 : comm_ring.{?l_2} R], @matrix.{?l_1 ?l_2} n n _inst_1 _inst_1 R → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : comm_semigroup.{?l_1} α] (a b : α), @eq.{?l_1+1} α (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) a b) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : comm_semigroup.{?l_1} α] (a b c : α), @eq.{?l_1+1} α (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) a (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) b c)) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) b (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) a c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {s : finset.{?l_1} α} {f g : α → β} [_inst_1 : comm_monoid.{?l_2} β], @eq.{?l_2+1} β (@finset.prod.{?l_1 ?l_2} α β _inst_1 s (λ (x : α), @has_mul.mul.{?l_2} β (@semigroup.to_has_mul.{?l_2} β (@monoid.to_semigroup.{?l_2} β (@comm_monoid.to_monoid.{?l_2} β _inst_1))) (f x) (g x))) (@has_mul.mul.{?l_2} β (@semigroup.to_has_mul.{?l_2} β (@monoid.to_semigroup.{?l_2} β (@comm_monoid.to_monoid.{?l_2} β _inst_1))) (@finset.prod.{?l_1 ?l_2} α β _inst_1 s f) (@finset.prod.{?l_1 ?l_2} α β _inst_1 s g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : semigroup.{?l_1} α] (a b c : α), @eq.{?l_1+1} α (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α _inst_1) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α _inst_1) a b) c) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α _inst_1) a (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The determinant of a matrix given by the Leibniz formula.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (τ : equiv.perm.{u+1} n),
          @finset.sum.{u v} (equiv.perm.{u+1} n) R
            (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
            (λ (σ : equiv.perm.{u+1} n),
               @has_mul.mul.{v} R
                 (@mul_zero_class.to_has_mul.{v} R
                    (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                 (@coe.{1 v+1} int R
                    (@coe_to_lift.{1 v+1} int R
                       (@coe_base.{1 v+1} int R
                          (@int.cast_coe.{v} R
                             (@add_group.to_has_neg.{v} R
                                (@add_comm_group.to_add_group.{v} R
                                   (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                             (@mul_zero_class.to_has_zero.{v} R
                                (@semiring.to_mul_zero_class.{v} R
                                   (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                             (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                             (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
                    (@coe.{1 1} (@units.{0} int int.monoid) int
                       (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                          (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                       (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
                 (@finset.prod.{u v} n R
                    (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
                    (@finset.univ.{u} n _inst_1)
                    (λ (i : n),
                       @has_mul.mul.{v} R
                         (@mul_zero_class.to_has_mul.{v} R
                            (@semiring.to_mul_zero_class.{v} R
                               (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                         (M
                            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ
                               i)
                            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ
                               i))
                         (N
                            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ
                               i)
                            i))))))
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @finset.sum.{u v} (equiv.perm.{u+1} n) R
            (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
            (λ (τ : equiv.perm.{u+1} n),
               @has_mul.mul.{v} R
                 (@mul_zero_class.to_has_mul.{v} R
                    (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                 (@has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (@finset.prod.{u v} n R
                       (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
                       (@finset.univ.{u} n _inst_1)
                       (λ (i : n),
                          N
                            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ
                               i)
                            i))
                    (@coe.{1 v+1} int R
                       (@coe_to_lift.{1 v+1} int R
                          (@coe_base.{1 v+1} int R
                             (@int.cast_coe.{v} R
                                (@add_group.to_has_neg.{v} R
                                   (@add_comm_group.to_add_group.{v} R
                                      (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                                (@mul_zero_class.to_has_zero.{v} R
                                   (@semiring.to_mul_zero_class.{v} R
                                      (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                                (@distrib.to_has_add.{v} R
                                   (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
                       (@coe.{1 1} (@units.{0} int int.monoid) int
                          (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                             (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ))))
                 (@finset.prod.{u v} n R
                    (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
                    (@finset.univ.{u} n _inst_1)
                    (λ (j : n),
                       M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ j)
                         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ
                            j))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  ... = univ.sum (λ σ : perm n, univ.sum (λ τ : perm n,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='equiv.perm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='equiv.perm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : add_comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`perm α` is the type of bijections from `α` to itself.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`perm α` is the type of bijections from `α` to itself.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90      (univ.prod (λ i, N (σ i) i) * (ε σ * ε τ)) *</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`prod s f` is the product of `f x` as `x` ranges over the elements of the finite set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91      univ.prod (λ i, M (τ i) i))) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`prod s f` is the product of `f x` as `x` ranges over the elements of the finite set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92    sum_congr rfl (λ σ _, sum_bij (λ τ _, τ * σ⁻¹) (λ _ _, mem_univ _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.sum_congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.sum_bij'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_inv.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 76, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 277, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 313, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {β : Type v} {s₁ s₂ : finset.{u} α} {f g : α → β} [_inst_1 : add_comm_monoid.{v} β], @eq.{u+1} (finset.{u} α) s₁ s₂ → (∀ (x : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x s₂ → @eq.{v+1} β (f x) (g x)) → @eq.{v+1} β (@finset.sum.{u v} α β _inst_1 s₁ f) (@finset.sum.{u v} α β _inst_1 s₂ g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {a : α}, @eq.{u+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n)) σ (@finset.univ.{u} (equiv.perm.{u+1} n) (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {β : Type v} {γ : Type u} [_inst_1 : add_comm_monoid.{v} β] {s : finset.{u} α} {t : finset.{u} γ} {f : α → β} {g : γ → β} (i : Π (a : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s → γ), (∀ (a : α) (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @has_mem.mem.{u u} γ (finset.{u} γ) (@finset.has_mem.{u} γ) (i a ha) t) → (∀ (a : α) (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @eq.{v+1} β (f a) (g (i a ha))) → (∀ (a₁ a₂ : α) (ha₁ : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a₁ s) (ha₂ : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a₂ s), @eq.{u+1} γ (i a₁ ha₁) (i a₂ ha₂) → @eq.{u+1} α a₁ a₂) → (∀ (b : γ), @has_mem.mem.{u u} γ (finset.{u} γ) (@finset.has_mem.{u} γ) b t → @Exists.{u+1} α (λ (a : α), @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s) (λ (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @eq.{u+1} γ b (i a ha)))) → @eq.{v+1} β (@finset.sum.{u v} α β _inst_1 s f) (@finset.sum.{u v} γ β _inst_1 t g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n)) τ (@finset.univ.{u} (equiv.perm.{u+1} n) (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_inv.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n)) _x (@finset.univ.{u} (equiv.perm.{u+1} n) (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : fintype.{u} α] (x : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x (@finset.univ.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93      (λ τ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n)) τ (@finset.univ.{u} (equiv.perm.{u+1} n) (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94        have univ.prod (λ j, M (τ j) (σ j)) = univ.prod (λ j, M ((τ * σ⁻¹) j) j),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='finset.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_inv.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 313, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_inv.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`prod s f` is the product of `f x` as `x` ranges over the elements of the finite set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`prod s f` is the product of `f x` as `x` ranges over the elements of the finite set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95          by rw prod_univ_perm σ⁻¹; simp [mul_apply],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='finset.prod_univ_perm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_inv.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='equiv.perm.mul_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/perm/sign.lean&#x27;, &#x27;line&#x27;: 714, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 313, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 169, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} [_inst_1 : fintype.{u} α] [_inst_2 : comm_monoid.{v} β] {f : α → β} (σ : equiv.perm.{u+1} α), @eq.{v+1} β (@finset.prod.{u v} α β _inst_2 (@finset.univ.{u} α _inst_1) f) (@finset.prod.{u v} α β _inst_2 (@finset.univ.{u} α _inst_1) (λ (z : α), f (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} α) (@equiv.has_coe_to_fun.{u+1 u+1} α α) σ z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_inv.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} (f g : equiv.perm.{?l_1+1} α) (x : α), @eq.{?l_1+1} α (@coe_fn.{(max 1 (?l_1+1)) ?l_1+1} (equiv.perm.{?l_1+1} α) (@equiv.has_coe_to_fun.{?l_1+1 ?l_1+1} α α) (@has_mul.mul.{?l_1} (equiv.perm.{?l_1+1} α) (@semigroup.to_has_mul.{?l_1} (equiv.perm.{?l_1+1} α) (@monoid.to_semigroup.{?l_1} (equiv.perm.{?l_1+1} α) (@group.to_monoid.{?l_1} (equiv.perm.{?l_1+1} α) (@equiv.perm.perm_group.{?l_1} α)))) f g) x) (@coe_fn.{(max 1 (?l_1+1)) ?l_1+1} (equiv.perm.{?l_1+1} α) (@equiv.has_coe_to_fun.{?l_1+1 ?l_1+1} α α) f (@coe_fn.{(max 1 (?l_1+1)) ?l_1+1} (equiv.perm.{?l_1+1} α) (@equiv.has_coe_to_fun.{?l_1+1 ?l_1+1} α α) g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
τ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
⊢ @eq.{v+1} R
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (j : n),
          M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ j)
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ j)))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (j : n),
          M
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
               (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                  (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  τ
                  (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                     (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                     σ))
               j)
            j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96        have h : ε σ * ε (τ * σ⁻¹) = ε τ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_inv.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 313, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_inv.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97          calc ε σ * ε (τ * σ⁻¹) = ε ((τ * σ⁻¹) * σ) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_inv.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_inv.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 313, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 313, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_inv.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_inv.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98            by rw [mul_comm, sign_mul (τ * σ⁻¹)]; simp [sign_mul]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='mul_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.perm.sign_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='equiv.perm.sign_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/perm/sign.lean&#x27;, &#x27;line&#x27;: 473, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/perm/sign.lean&#x27;, &#x27;line&#x27;: 473, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : comm_semigroup.{v} α] (a b : α), @eq.{v+1} α (@has_mul.mul.{v} α (@semigroup.to_has_mul.{v} α (@comm_semigroup.to_semigroup.{v} α _inst_1)) a b) (@has_mul.mul.{v} α (@semigroup.to_has_mul.{v} α (@comm_semigroup.to_semigroup.{v} α _inst_1)) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : fintype.{u} α] (f g : equiv.perm.{u+1} α), @eq.{1} (@units.{0} int int.monoid) (@equiv.perm.sign.{u} α (λ (a b : α), _inst_1 a b) _inst_2 (@has_mul.mul.{u} (equiv.perm.{u+1} α) (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} α) (@monoid.to_semigroup.{u} (equiv.perm.{u+1} α) (@group.to_monoid.{u} (equiv.perm.{u+1} α) (@equiv.perm.perm_group.{u} α)))) f g)) (@has_mul.mul.{0} (@units.{0} int int.monoid) (@units.has_mul.{0} int int.monoid) (@equiv.perm.sign.{u} α (λ (a b : α), _inst_1 a b) _inst_2 f) (@equiv.perm.sign.{u} α (λ (a b : α), _inst_1 a b) _inst_2 g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : decidable_eq.{?l_1+1} α] [_inst_2 : fintype.{?l_1} α] (f g : equiv.perm.{?l_1+1} α), @eq.{1} (@units.{0} int int.monoid) (@equiv.perm.sign.{?l_1} α (λ (a b : α), _inst_1 a b) _inst_2 (@has_mul.mul.{?l_1} (equiv.perm.{?l_1+1} α) (@semigroup.to_has_mul.{?l_1} (equiv.perm.{?l_1+1} α) (@monoid.to_semigroup.{?l_1} (equiv.perm.{?l_1+1} α) (@group.to_monoid.{?l_1} (equiv.perm.{?l_1+1} α) (@equiv.perm.perm_group.{?l_1} α)))) f g)) (@has_mul.mul.{0} (@units.{0} int int.monoid) (@units.has_mul.{0} int int.monoid) (@equiv.perm.sign.{?l_1} α (λ (a b : α), _inst_1 a b) _inst_2 f) (@equiv.perm.sign.{?l_1} α (λ (a b : α), _inst_1 a b) _inst_2 g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
τ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
this :
  @eq.{v+1} R
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (j : n),
          M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ j)
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ j)))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (j : n),
          M
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
               (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                  (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  τ
                  (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                     (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                     σ))
               j)
            j))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
                (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                   (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                      (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                         (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                   τ
                   (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                      (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                      σ))))))
    (@coe.{1 v+1} int R
       (@coe_to_lift.{1 v+1} int R
          (@coe_base.{1 v+1} int R
             (@int.cast_coe.{v} R
                (@add_group.to_has_neg.{v} R
                   (@add_comm_group.to_add_group.{v} R
                      (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@coe.{1 1} (@units.{0} int int.monoid) int
          (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
             (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
             (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                   (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                      (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                         (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                   τ
                   (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                      (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                      σ))
                σ))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
τ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
this :
  @eq.{v+1} R
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (j : n),
          M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ j)
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ j)))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (j : n),
          M
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
               (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                  (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  τ
                  (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                     (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                     σ))
               j)
            j))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@semigroup.to_has_mul.{v} R (@comm_semigroup.to_semigroup.{v} R (@comm_ring.to_comm_semigroup.{v} R _inst_3)))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
                (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                   (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                      (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                         (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                   τ
                   (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                      (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                      σ)))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))))
    (@coe.{1 v+1} int R
       (@coe_to_lift.{1 v+1} int R
          (@coe_base.{1 v+1} int R
             (@int.cast_coe.{v} R
                (@add_group.to_has_neg.{v} R
                   (@add_comm_group.to_add_group.{v} R
                      (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@coe.{1 1} (@units.{0} int int.monoid) int
          (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
             (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
             (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                   (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                      (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                         (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                   τ
                   (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                      (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                      σ))
                σ))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
τ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
this :
  @eq.{v+1} R
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (j : n),
          M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ j)
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ j)))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (j : n),
          M
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
               (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                  (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  τ
                  (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                     (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                     σ))
               j)
            j))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@semigroup.to_has_mul.{v} R (@comm_semigroup.to_semigroup.{v} R (@comm_ring.to_comm_semigroup.{v} R _inst_3)))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
                (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                   (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                      (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                         (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                   τ
                   (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                      (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                      σ)))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))))
    (@coe.{1 v+1} int R
       (@coe_to_lift.{1 v+1} int R
          (@coe_base.{1 v+1} int R
             (@int.cast_coe.{v} R
                (@add_group.to_has_neg.{v} R
                   (@add_comm_group.to_add_group.{v} R
                      (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@coe.{1 1} (@units.{0} int int.monoid) int
          (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
             (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
          (@has_mul.mul.{0} (@units.{0} int int.monoid) (@units.has_mul.{0} int int.monoid)
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                   (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                      (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                         (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                   τ
                   (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                      (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                      σ)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
τ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
this :
  @eq.{v+1} R
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (j : n),
          M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ j)
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ j)))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (j : n),
          M
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
               (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                  (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  τ
                  (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                     (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                     σ))
               j)
            j))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
                (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                   (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                      (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                         (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                   τ
                   (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                      (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                      σ))))))
    (@coe.{1 v+1} int R
       (@coe_to_lift.{1 v+1} int R
          (@coe_base.{1 v+1} int R
             (@int.cast_coe.{v} R
                (@add_group.to_has_neg.{v} R
                   (@add_comm_group.to_add_group.{v} R
                      (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@coe.{1 1} (@units.{0} int int.monoid) int
          (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
             (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
             (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                   (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                      (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                         (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                   τ
                   (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                      (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                      σ))
                σ))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99          ... = ε τ : by simp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/int/basic.lean&#x27;, &#x27;line&#x27;: 15, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
τ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
this :
  @eq.{v+1} R
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (j : n),
          M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ j)
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ j)))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (j : n),
          M
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
               (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                  (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  τ
                  (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                     (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                     σ))
               j)
            j))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
                (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                   (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                      (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                         (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                   τ
                   (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                      (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                      σ))))))
    (@coe.{1 v+1} int R
       (@coe_to_lift.{1 v+1} int R
          (@coe_base.{1 v+1} int R
             (@int.cast_coe.{v} R
                (@add_group.to_has_neg.{v} R
                   (@add_comm_group.to_add_group.{v} R
                      (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@coe.{1 1} (@units.{0} int int.monoid) int
          (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
             (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
             (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                   (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                      (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                         (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                   τ
                   (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                      (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                      σ))
                σ))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
τ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
this :
  @eq.{v+1} R
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (j : n),
          M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ j)
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ j)))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (j : n),
          M
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
               (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                  (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  τ
                  (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                     (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                     σ))
               j)
            j))
⊢ @eq.{v+1} R
    (@coe.{1 v+1} int R
       (@coe_to_lift.{1 v+1} int R
          (@coe_base.{1 v+1} int R
             (@int.cast_coe.{v} R
                (@add_group.to_has_neg.{v} R
                   (@add_comm_group.to_add_group.{v} R
                      (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@coe.{1 1} (@units.{0} int int.monoid) int
          (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
             (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
             (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                   (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                      (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                         (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                   τ
                   (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                      (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                      σ))
                σ))))
    (@coe.{1 v+1} int R
       (@coe_to_lift.{1 v+1} int R
          (@coe_base.{1 v+1} int R
             (@int.cast_coe.{v} R
                (@add_group.to_has_neg.{v} R
                   (@add_comm_group.to_add_group.{v} R
                      (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@coe.{1 1} (@units.{0} int int.monoid) int
          (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
             (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100        by rw h; simp [this, mul_comm, mul_assoc, mul_left_comm])</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_left_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} R (@has_mul.mul.{v} R (@mul_zero_class.to_has_mul.{v} R (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (@coe.{1 v+1} int R (@coe_to_lift.{1 v+1} int R (@coe_base.{1 v+1} int R (@int.cast_coe.{v} R (@add_group.to_has_neg.{v} R (@add_comm_group.to_add_group.{v} R (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (@mul_zero_class.to_has_zero.{v} R (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))) (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))) (@coe.{1 1} (@units.{0} int int.monoid) int (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid))) (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))) (@coe.{1 v+1} int R (@coe_to_lift.{1 v+1} int R (@coe_base.{1 v+1} int R (@int.cast_coe.{v} R (@add_group.to_has_neg.{v} R (@add_comm_group.to_add_group.{v} R (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (@mul_zero_class.to_has_zero.{v} R (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))) (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))) (@coe.{1 1} (@units.{0} int int.monoid) int (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid))) (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 (@has_mul.mul.{u} (equiv.perm.{u+1} n) (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n) (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n) (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))) τ (@has_inv.inv.{u} (equiv.perm.{u+1} n) (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)) σ)))))) (@coe.{1 v+1} int R (@coe_to_lift.{1 v+1} int R (@coe_base.{1 v+1} int R (@int.cast_coe.{v} R (@add_group.to_has_neg.{v} R (@add_comm_group.to_add_group.{v} R (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (@mul_zero_class.to_has_zero.{v} R (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))) (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))) (@coe.{1 1} (@units.{0} int int.monoid) int (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid))) (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} R (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3)) (@finset.univ.{u} n _inst_1) (λ (j : n), M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ j) (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ j))) (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3)) (@finset.univ.{u} n _inst_1) (λ (j : n), M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) (@has_mul.mul.{u} (equiv.perm.{u+1} n) (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n) (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n) (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))) τ (@has_inv.inv.{u} (equiv.perm.{u+1} n) (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)) σ)) j) j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : comm_semigroup.{?l_1} α] (a b : α), @eq.{?l_1+1} α (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) a b) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : semigroup.{?l_1} α] (a b c : α), @eq.{?l_1+1} α (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α _inst_1) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α _inst_1) a b) c) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α _inst_1) a (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : comm_semigroup.{?l_1} α] (a b c : α), @eq.{?l_1+1} α (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) a (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) b c)) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) b (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) a c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
τ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
this :
  @eq.{v+1} R
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (j : n),
          M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ j)
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ j)))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (j : n),
          M
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
               (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                  (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  τ
                  (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                     (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                     σ))
               j)
            j)),
h :
  @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
                (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                   (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                      (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                         (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                   τ
                   (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                      (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                      σ))))))
    (@coe.{1 v+1} int R
       (@coe_to_lift.{1 v+1} int R
          (@coe_base.{1 v+1} int R
             (@int.cast_coe.{v} R
                (@add_group.to_has_neg.{v} R
                   (@add_comm_group.to_add_group.{v} R
                      (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@coe.{1 1} (@units.{0} int int.monoid) int
          (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
             (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ)))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@has_mul.mul.{v} R
          (@mul_zero_class.to_has_mul.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
             (@finset.univ.{u} n _inst_1)
             (λ (i : n),
                N (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) i))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (j : n),
             M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ j)
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ j))))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@has_mul.mul.{v} R
          (@mul_zero_class.to_has_mul.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
             (@finset.univ.{u} n _inst_1)
             (λ (i : n),
                N (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) i))
          (@has_mul.mul.{v} R
             (@mul_zero_class.to_has_mul.{v} R
                (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
             (@coe.{1 v+1} int R
                (@coe_to_lift.{1 v+1} int R
                   (@coe_base.{1 v+1} int R
                      (@int.cast_coe.{v} R
                         (@add_group.to_has_neg.{v} R
                            (@add_comm_group.to_add_group.{v} R
                               (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                         (@mul_zero_class.to_has_zero.{v} R
                            (@semiring.to_mul_zero_class.{v} R
                               (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                         (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                         (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
                (@coe.{1 1} (@units.{0} int int.monoid) int
                   (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                      (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                   (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
             (@coe.{1 v+1} int R
                (@coe_to_lift.{1 v+1} int R
                   (@coe_base.{1 v+1} int R
                      (@int.cast_coe.{v} R
                         (@add_group.to_has_neg.{v} R
                            (@add_comm_group.to_add_group.{v} R
                               (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                         (@mul_zero_class.to_has_zero.{v} R
                            (@semiring.to_mul_zero_class.{v} R
                               (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                         (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                         (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
                (@coe.{1 1} (@units.{0} int int.monoid) int
                   (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                      (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                   (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
                      (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                         (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                            (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                               (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                         τ
                         (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                            (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                            σ)))))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             M
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                     (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                        (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                           (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                     τ
                     (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                        (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                        σ))
                  i)
               i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101      (λ _ _ _ _, (mul_right_inj _).1) (λ τ _, ⟨τ * σ, by simp⟩))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='mul_right_inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/basic.lean&#x27;, &#x27;line&#x27;: 36, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n)) _x (@finset.univ.{u} (equiv.perm.{u+1} n) (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n)) _x (@finset.univ.{u} (equiv.perm.{u+1} n) (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : right_cancel_semigroup.{u} α] (a : α) {b c : α}, iff (@eq.{u+1} α (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@right_cancel_semigroup.to_semigroup.{u} α _inst_1)) b a) (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@right_cancel_semigroup.to_semigroup.{u} α _inst_1)) c a)) (@eq.{u+1} α b c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n)) τ (@finset.univ.{u} (equiv.perm.{u+1} n) (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
τ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
⊢ @Exists.{0}
    (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
       (@finset.has_mem.{u} (equiv.perm.{u+1} n))
       (@has_mul.mul.{u} (equiv.perm.{u+1} n)
          (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
             (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          τ
          σ)
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)))
    (λ
     (ha :
       @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_mem.{u} (equiv.perm.{u+1} n))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            τ
            σ)
         (@finset.univ.{u} (equiv.perm.{u+1} n)
            (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
       @eq.{u+1} (equiv.perm.{u+1} n) τ
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@has_mul.mul.{u} (equiv.perm.{u+1} n)
               (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                  (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                     (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
               τ
               σ)
            (@has_inv.inv.{u} (equiv.perm.{u+1} n)
               (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
               σ)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  ... = det M * det N : by simp [det, mul_assoc, mul_sum, mul_comm, mul_left_comm]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='matrix.det'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='matrix.det'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='matrix.det'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.mul_sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='mul_left_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 626, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 46, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {n : Type u} [_inst_1 : fintype.{u} n] [_inst_2 : decidable_eq.{u+1} n] {R : Type v} [_inst_3 : comm_ring.{v} R], @matrix.{u v} n n _inst_1 _inst_1 R → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {n : Type u} [_inst_1 : fintype.{u} n] [_inst_2 : decidable_eq.{u+1} n] {R : Type v} [_inst_3 : comm_ring.{v} R], @matrix.{u v} n n _inst_1 _inst_1 R → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : Type ?l_1} [_inst_1 : fintype.{?l_1} n] [_inst_2 : decidable_eq.{?l_1+1} n] {R : Type ?l_2} [_inst_3 : comm_ring.{?l_2} R], @matrix.{?l_1 ?l_2} n n _inst_1 _inst_1 R → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : semigroup.{?l_1} α] (a b c : α), @eq.{?l_1+1} α (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α _inst_1) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α _inst_1) a b) c) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α _inst_1) a (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {s : finset.{?l_1} α} {f : α → β} {b : β} [_inst_1 : semiring.{?l_2} β], @eq.{?l_2+1} β (@has_mul.mul.{?l_2} β (@mul_zero_class.to_has_mul.{?l_2} β (@semiring.to_mul_zero_class.{?l_2} β _inst_1)) b (@finset.sum.{?l_1 ?l_2} α β (@semiring.to_add_comm_monoid.{?l_2} β _inst_1) s f)) (@finset.sum.{?l_1 ?l_2} α β (@semiring.to_add_comm_monoid.{?l_2} β _inst_1) s (λ (x : α), @has_mul.mul.{?l_2} β (@mul_zero_class.to_has_mul.{?l_2} β (@semiring.to_mul_zero_class.{?l_2} β _inst_1)) b (f x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : comm_semigroup.{?l_1} α] (a b : α), @eq.{?l_1+1} α (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) a b) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : comm_semigroup.{?l_1} α] (a b c : α), @eq.{?l_1+1} α (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) a (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) b c)) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) b (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@comm_semigroup.to_semigroup.{?l_1} α _inst_1)) a c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The determinant of a matrix given by the Leibniz formula.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The determinant of a matrix given by the Leibniz formula.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The determinant of a matrix given by the Leibniz formula.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @finset.sum.{u v} (equiv.perm.{u+1} n) R
            (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
            (λ (τ : equiv.perm.{u+1} n),
               @has_mul.mul.{v} R
                 (@mul_zero_class.to_has_mul.{v} R
                    (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                 (@has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (@finset.prod.{u v} n R
                       (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
                       (@finset.univ.{u} n _inst_1)
                       (λ (i : n),
                          N
                            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ
                               i)
                            i))
                    (@has_mul.mul.{v} R
                       (@mul_zero_class.to_has_mul.{v} R
                          (@semiring.to_mul_zero_class.{v} R
                             (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                       (@coe.{1 v+1} int R
                          (@coe_to_lift.{1 v+1} int R
                             (@coe_base.{1 v+1} int R
                                (@int.cast_coe.{v} R
                                   (@add_group.to_has_neg.{v} R
                                      (@add_comm_group.to_add_group.{v} R
                                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                                   (@mul_zero_class.to_has_zero.{v} R
                                      (@semiring.to_mul_zero_class.{v} R
                                         (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                                   (@distrib.to_has_add.{v} R
                                      (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
                          (@coe.{1 1} (@units.{0} int int.monoid) int
                             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
                       (@coe.{1 v+1} int R
                          (@coe_to_lift.{1 v+1} int R
                             (@coe_base.{1 v+1} int R
                                (@int.cast_coe.{v} R
                                   (@add_group.to_has_neg.{v} R
                                      (@add_comm_group.to_add_group.{v} R
                                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                                   (@mul_zero_class.to_has_zero.{v} R
                                      (@semiring.to_mul_zero_class.{v} R
                                         (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                                   (@distrib.to_has_add.{v} R
                                      (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
                          (@coe.{1 1} (@units.{0} int int.monoid) int
                             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ)))))
                 (@finset.prod.{u v} n R
                    (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
                    (@finset.univ.{u} n _inst_1)
                    (λ (i : n),
                       M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ i)
                         i)))))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 M)
       (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 N))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M N : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ : equiv.perm.{u+1} n),
          @finset.sum.{u v} (equiv.perm.{u+1} n) R
            (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
            (λ (τ : equiv.perm.{u+1} n),
               @has_mul.mul.{v} R
                 (@mul_zero_class.to_has_mul.{v} R
                    (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                 (@has_mul.mul.{v} R
                    (@mul_zero_class.to_has_mul.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (@finset.prod.{u v} n R
                       (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
                       (@finset.univ.{u} n _inst_1)
                       (λ (i : n),
                          N
                            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ
                               i)
                            i))
                    (@has_mul.mul.{v} R
                       (@mul_zero_class.to_has_mul.{v} R
                          (@semiring.to_mul_zero_class.{v} R
                             (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                       (@coe.{1 v+1} int R
                          (@coe_to_lift.{1 v+1} int R
                             (@coe_base.{1 v+1} int R
                                (@int.cast_coe.{v} R
                                   (@add_group.to_has_neg.{v} R
                                      (@add_comm_group.to_add_group.{v} R
                                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                                   (@mul_zero_class.to_has_zero.{v} R
                                      (@semiring.to_mul_zero_class.{v} R
                                         (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                                   (@distrib.to_has_add.{v} R
                                      (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
                          (@coe.{1 1} (@units.{0} int int.monoid) int
                             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
                       (@coe.{1 v+1} int R
                          (@coe_to_lift.{1 v+1} int R
                             (@coe_base.{1 v+1} int R
                                (@int.cast_coe.{v} R
                                   (@add_group.to_has_neg.{v} R
                                      (@add_comm_group.to_add_group.{v} R
                                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                                   (@mul_zero_class.to_has_zero.{v} R
                                      (@semiring.to_mul_zero_class.{v} R
                                         (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                                   (@distrib.to_has_add.{v} R
                                      (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
                          (@coe.{1 1} (@units.{0} int int.monoid) int
                             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ)))))
                 (@finset.prod.{u v} n R
                    (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
                    (@finset.univ.{u} n _inst_1)
                    (λ (i : n),
                       M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ i)
                         i)))))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 M)
       (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 N))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  instance : is_monoid_hom (det : matrix n n R → R) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='is_monoid_hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='matrix.det'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='matrix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/hom.lean&#x27;, &#x27;line&#x27;: 110, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/basic.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : monoid.{u} α] [_inst_2 : monoid.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {n : Type u} [_inst_1 : fintype.{u} n] [_inst_2 : decidable_eq.{u+1} n] {R : Type v} [_inst_3 : comm_ring.{v} R], @matrix.{u v} n n _inst_1 _inst_1 R → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (m n : Type u) [_inst_1 : fintype.{u} m] [_inst_2 : fintype.{u} n], Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Predicate for monoid homomorphisms (deprecated -- use the bundled `monoid_hom` version).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The determinant of a matrix given by the Leibniz formula.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n)
         (λ (a b : equiv.perm.{u+1} n),
            @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@has_add.add.{v} R
       (@add_semigroup.to_has_add.{v} R
          (@add_monoid.to_add_semigroup.{v} R
             (@add_comm_monoid.to_add_monoid.{v} R
                (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@has_mul.mul.{v} R
          (@mul_zero_class.to_has_mul.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
          (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
             (@finset.univ.{u} n _inst_1)
             (λ (i : n),
                M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) i)))
       (@has_mul.mul.{v} R
          (@mul_zero_class.to_has_mul.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                   (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                      (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                         (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                            (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                      (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
                      σ))))
          (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
             (@finset.univ.{u} n _inst_1)
             (λ (i_1 : n),
                M
                  (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                     (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                        (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                           (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                              (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                        (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
                        σ)
                     i_1)
                  i_1))))
    (@has_add.add.{v} R
       (@add_semigroup.to_has_add.{v} R
          (@add_monoid.to_add_semigroup.{v} R
             (@add_group.to_add_monoid.{v} R
                (@add_comm_group.to_add_group.{v} R
                   (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@has_mul.mul.{v} R
          (@mul_zero_class.to_has_mul.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@coe.{?l_1 v+1} ?m_2 R ?m_3
             (@coe.{1 ?l_1} (@units.{0} int int.monoid) ?m_2 ?m_4
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
          (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
             (@finset.univ.{u} n _inst_1)
             (λ (i : n),
                M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) i)))
       (@has_neg.neg.{v} R
          (@add_group.to_has_neg.{v} R
             (@add_comm_group.to_add_group.{v} R (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@has_mul.mul.{v} R
             (@mul_zero_class.to_has_mul.{v} R
                (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
             (@coe.{?l_1 v+1} ?m_2 R ?m_3
                (@coe.{1 ?l_1} (@units.{0} int int.monoid) ?m_2 ?m_4
                   (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
             (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
                (@finset.univ.{u} n _inst_1)
                (λ (i : n),
                   M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
                     i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  { map_one := det_one,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='matrix.det_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 40, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='∀ {n : Type u} [_inst_1 : fintype.{u} n] [_inst_2 : decidable_eq.{u+1} n] {R : Type v} [_inst_3 : comm_ring.{v} R], @eq.{v+1} R (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 (@has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R) (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b) (@mul_zero_class.to_has_zero.{v} R (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))) (@has_one.one.{v} R (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106    map_mul := det_mul }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='matrix.det_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 64, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='∀ {n : Type u} [_inst_1 : fintype.{u} n] [_inst_2 : decidable_eq.{u+1} n] {R : Type v} [_inst_3 : comm_ring.{v} R] (M N : @matrix.{u v} n n _inst_1 _inst_1 R), @eq.{v+1} R (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 (@has_mul.mul.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R) (@matrix.has_mul.{u v} n _inst_1 R (@mul_zero_class.to_has_mul.{v} R (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) M N)) (@has_mul.mul.{v} R (@mul_zero_class.to_has_mul.{v} R (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 M) (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 N))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  /-- Transposing a matrix preserves the determinant. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  @[simp] lemma det_transpose (M : matrix n n R) : M.transpose.det = M.det :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='matrix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='matrix.transpose'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='matrix.det'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='matrix.det'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/basic.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/basic.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Π (m n : Type u) [_inst_1 : fintype.{u} m] [_inst_2 : fintype.{u} n], Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {m n : Type u} [_inst_2 : fintype.{u} m] [_inst_3 : fintype.{u} n] {α : Type v}, @matrix.{u v} m n _inst_2 _inst_3 α → @matrix.{u v} n m _inst_3 _inst_2 α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : Type u} [_inst_1 : fintype.{u} n] [_inst_2 : decidable_eq.{u+1} n] {R : Type v} [_inst_3 : comm_ring.{v} R], @matrix.{u v} n n _inst_1 _inst_1 R → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : Type u} [_inst_1 : fintype.{u} n] [_inst_2 : decidable_eq.{u+1} n] {R : Type v} [_inst_3 : comm_ring.{v} R], @matrix.{u v} n n _inst_1 _inst_1 R → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='orange'><a title='The determinant of a matrix given by the Leibniz formula.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The determinant of a matrix given by the Leibniz formula.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (@matrix.transpose.{u v} n n _inst_1 _inst_1 R M))
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 M)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111    apply sum_bij (λ σ _, σ⁻¹),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='finset.sum_bij'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='has_inv.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 277, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 313, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} {γ : Type u} [_inst_1 : add_comm_monoid.{v} β] {s : finset.{u} α} {t : finset.{u} γ} {f : α → β} {g : γ → β} (i : Π (a : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s → γ), (∀ (a : α) (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @has_mem.mem.{u u} γ (finset.{u} γ) (@finset.has_mem.{u} γ) (i a ha) t) → (∀ (a : α) (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @eq.{v+1} β (f a) (g (i a ha))) → (∀ (a₁ a₂ : α) (ha₁ : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a₁ s) (ha₂ : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a₂ s), @eq.{u+1} γ (i a₁ ha₁) (i a₂ ha₂) → @eq.{u+1} α a₁ a₂) → (∀ (b : γ), @has_mem.mem.{u u} γ (finset.{u} γ) (@finset.has_mem.{u} γ) b t → @Exists.{u+1} α (λ (a : α), @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s) (λ (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @eq.{u+1} γ b (i a ha)))) → @eq.{v+1} β (@finset.sum.{u v} α β _inst_1 s f) (@finset.sum.{u v} γ β _inst_1 t g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_inv.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (@matrix.transpose.{u v} n n _inst_1 _inst_1 R M))
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 M)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='5 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ ∀ (a : equiv.perm.{u+1} n)
  (ha :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1))),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      ((λ (σ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            σ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  _inst_1
                  _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
         a
         ha)
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ ∀ (a : equiv.perm.{u+1} n)
  (ha :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1))),
    @eq.{v+1} R
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} int R
            (@coe_to_lift.{1 v+1} int R
               (@coe_base.{1 v+1} int R
                  (@int.cast_coe.{v} R
                     (@add_group.to_has_neg.{v} R
                        (@add_comm_group.to_add_group.{v} R
                           (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                     (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
            (@coe.{1 1} (@units.{0} int int.monoid) int
               (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                  (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
               (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 a)))
         (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
            (@finset.univ.{u} n _inst_1)
            (λ (i : n),
               @matrix.transpose.{u v} n n _inst_1 _inst_1 R M
                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) a i)
                 i)))
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} int R
            (@coe_to_lift.{1 v+1} int R
               (@coe_base.{1 v+1} int R
                  (@int.cast_coe.{v} R
                     (@add_group.to_has_neg.{v} R
                        (@add_comm_group.to_add_group.{v} R
                           (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                     (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
            (@coe.{1 1} (@units.{0} int int.monoid) int
               (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                  (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
               (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                  ((λ (σ : equiv.perm.{u+1} n)
                    (_x :
                      @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                        (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                        σ
                        (@finset.univ.{u} (equiv.perm.{u+1} n)
                           (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                              (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                              _inst_1
                              _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
                     a
                     ha))))
         (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
            (@finset.univ.{u} n _inst_1)
            (λ (i : n),
               M
                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                    ((λ (σ : equiv.perm.{u+1} n)
                      (_x :
                        @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                          (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                          σ
                          (@finset.univ.{u} (equiv.perm.{u+1} n)
                             (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                                (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                                _inst_1
                                _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
                       a
                       ha)
                    i)
                 i)))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ ∀ (a₁ a₂ : equiv.perm.{u+1} n)
  (ha₁ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₁
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1)))
  (ha₂ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₂
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1))),
    @eq.{u+1} (equiv.perm.{u+1} n)
      ((λ (σ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            σ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  _inst_1
                  _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
         a₁
         ha₁)
      ((λ (σ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            σ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  _inst_1
                  _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
         a₂
         ha₂) →
    @eq.{u+1} (equiv.perm.{u+1} n) a₁ a₂

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ ∀ (b : equiv.perm.{u+1} n),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      b
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1)) →
    @Exists.{u+1} (equiv.perm.{u+1} n)
      (λ (a : equiv.perm.{u+1} n),
         @Exists.{0}
           (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
              (@finset.has_mem.{u} (equiv.perm.{u+1} n))
              a
              (@finset.univ.{u} (equiv.perm.{u+1} n)
                 (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                    (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                    _inst_1
                    _inst_1)))
           (λ
            (ha :
              @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                a
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      _inst_1
                      _inst_1))),
              @eq.{u+1} (equiv.perm.{u+1} n) b
                ((λ (σ : equiv.perm.{u+1} n)
                  (_x :
                    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                      (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                      σ
                      (@finset.univ.{u} (equiv.perm.{u+1} n)
                         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                            _inst_1
                            _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
                   a
                   ha)))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ has_inv.{u} (equiv.perm.{u+1} n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112    { intros σ _, apply mem_univ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='finset.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : fintype.{u} α] (x : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x (@finset.univ.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='5 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ ∀ (a : equiv.perm.{u+1} n)
  (ha :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1))),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      ((λ (σ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            σ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  _inst_1
                  _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
         a
         ha)
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ ∀ (a : equiv.perm.{u+1} n)
  (ha :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1))),
    @eq.{v+1} R
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} int R
            (@coe_to_lift.{1 v+1} int R
               (@coe_base.{1 v+1} int R
                  (@int.cast_coe.{v} R
                     (@add_group.to_has_neg.{v} R
                        (@add_comm_group.to_add_group.{v} R
                           (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                     (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
            (@coe.{1 1} (@units.{0} int int.monoid) int
               (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                  (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
               (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 a)))
         (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
            (@finset.univ.{u} n _inst_1)
            (λ (i : n),
               @matrix.transpose.{u v} n n _inst_1 _inst_1 R M
                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) a i)
                 i)))
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} int R
            (@coe_to_lift.{1 v+1} int R
               (@coe_base.{1 v+1} int R
                  (@int.cast_coe.{v} R
                     (@add_group.to_has_neg.{v} R
                        (@add_comm_group.to_add_group.{v} R
                           (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                     (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
            (@coe.{1 1} (@units.{0} int int.monoid) int
               (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                  (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
               (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                  ((λ (σ : equiv.perm.{u+1} n)
                    (_x :
                      @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                        (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                        σ
                        (@finset.univ.{u} (equiv.perm.{u+1} n)
                           (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                              (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                              _inst_1
                              _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
                     a
                     ha))))
         (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
            (@finset.univ.{u} n _inst_1)
            (λ (i : n),
               M
                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                    ((λ (σ : equiv.perm.{u+1} n)
                      (_x :
                        @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                          (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                          σ
                          (@finset.univ.{u} (equiv.perm.{u+1} n)
                             (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                                (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                                _inst_1
                                _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
                       a
                       ha)
                    i)
                 i)))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ ∀ (a₁ a₂ : equiv.perm.{u+1} n)
  (ha₁ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₁
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1)))
  (ha₂ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₂
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1))),
    @eq.{u+1} (equiv.perm.{u+1} n)
      ((λ (σ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            σ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  _inst_1
                  _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
         a₁
         ha₁)
      ((λ (σ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            σ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  _inst_1
                  _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
         a₂
         ha₂) →
    @eq.{u+1} (equiv.perm.{u+1} n) a₁ a₂

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ ∀ (b : equiv.perm.{u+1} n),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      b
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1)) →
    @Exists.{u+1} (equiv.perm.{u+1} n)
      (λ (a : equiv.perm.{u+1} n),
         @Exists.{0}
           (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
              (@finset.has_mem.{u} (equiv.perm.{u+1} n))
              a
              (@finset.univ.{u} (equiv.perm.{u+1} n)
                 (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                    (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                    _inst_1
                    _inst_1)))
           (λ
            (ha :
              @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                a
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      _inst_1
                      _inst_1))),
              @eq.{u+1} (equiv.perm.{u+1} n) b
                ((λ (σ : equiv.perm.{u+1} n)
                  (_x :
                    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                      (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                      σ
                      (@finset.univ.{u} (equiv.perm.{u+1} n)
                         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                            _inst_1
                            _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
                   a
                   ha)))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ has_inv.{u} (equiv.perm.{u+1} n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ ∀ (a : equiv.perm.{u+1} n)
  (ha :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1))),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      ((λ (σ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            σ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  _inst_1
                  _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
         a
         ha)
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    ((λ (σ : equiv.perm.{u+1} n)
      (_x :
        @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
          (@finset.has_mem.{u} (equiv.perm.{u+1} n))
          σ
          (@finset.univ.{u} (equiv.perm.{u+1} n)
             (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                _inst_1
                _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
       σ
       ha)
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ ∀ (a : equiv.perm.{u+1} n)
  (ha :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1))),
    @eq.{v+1} R
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} int R
            (@coe_to_lift.{1 v+1} int R
               (@coe_base.{1 v+1} int R
                  (@int.cast_coe.{v} R
                     (@add_group.to_has_neg.{v} R
                        (@add_comm_group.to_add_group.{v} R
                           (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                     (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
            (@coe.{1 1} (@units.{0} int int.monoid) int
               (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                  (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
               (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 a)))
         (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
            (@finset.univ.{u} n _inst_1)
            (λ (i : n),
               @matrix.transpose.{u v} n n _inst_1 _inst_1 R M
                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) a i)
                 i)))
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} int R
            (@coe_to_lift.{1 v+1} int R
               (@coe_base.{1 v+1} int R
                  (@int.cast_coe.{v} R
                     (@add_group.to_has_neg.{v} R
                        (@add_comm_group.to_add_group.{v} R
                           (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                     (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
            (@coe.{1 1} (@units.{0} int int.monoid) int
               (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                  (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
               (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                  ((λ (σ : equiv.perm.{u+1} n)
                    (_x :
                      @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                        (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                        σ
                        (@finset.univ.{u} (equiv.perm.{u+1} n)
                           (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                              (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                              _inst_1
                              _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
                     a
                     ha))))
         (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
            (@finset.univ.{u} n _inst_1)
            (λ (i : n),
               M
                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                    ((λ (σ : equiv.perm.{u+1} n)
                      (_x :
                        @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                          (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                          σ
                          (@finset.univ.{u} (equiv.perm.{u+1} n)
                             (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                                (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                                _inst_1
                                _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
                       a
                       ha)
                    i)
                 i)))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ ∀ (a₁ a₂ : equiv.perm.{u+1} n)
  (ha₁ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₁
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1)))
  (ha₂ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₂
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1))),
    @eq.{u+1} (equiv.perm.{u+1} n)
      ((λ (σ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            σ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  _inst_1
                  _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
         a₁
         ha₁)
      ((λ (σ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            σ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  _inst_1
                  _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
         a₂
         ha₂) →
    @eq.{u+1} (equiv.perm.{u+1} n) a₁ a₂

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ ∀ (b : equiv.perm.{u+1} n),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      b
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1)) →
    @Exists.{u+1} (equiv.perm.{u+1} n)
      (λ (a : equiv.perm.{u+1} n),
         @Exists.{0}
           (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
              (@finset.has_mem.{u} (equiv.perm.{u+1} n))
              a
              (@finset.univ.{u} (equiv.perm.{u+1} n)
                 (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                    (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                    _inst_1
                    _inst_1)))
           (λ
            (ha :
              @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                a
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      _inst_1
                      _inst_1))),
              @eq.{u+1} (equiv.perm.{u+1} n) b
                ((λ (σ : equiv.perm.{u+1} n)
                  (_x :
                    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                      (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                      σ
                      (@finset.univ.{u} (equiv.perm.{u+1} n)
                         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                            _inst_1
                            _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
                   a
                   ha)))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ has_inv.{u} (equiv.perm.{u+1} n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113    { intros σ _,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ ∀ (a : equiv.perm.{u+1} n)
  (ha :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1))),
    @eq.{v+1} R
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} int R
            (@coe_to_lift.{1 v+1} int R
               (@coe_base.{1 v+1} int R
                  (@int.cast_coe.{v} R
                     (@add_group.to_has_neg.{v} R
                        (@add_comm_group.to_add_group.{v} R
                           (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                     (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
            (@coe.{1 1} (@units.{0} int int.monoid) int
               (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                  (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
               (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 a)))
         (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
            (@finset.univ.{u} n _inst_1)
            (λ (i : n),
               @matrix.transpose.{u v} n n _inst_1 _inst_1 R M
                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) a i)
                 i)))
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} int R
            (@coe_to_lift.{1 v+1} int R
               (@coe_base.{1 v+1} int R
                  (@int.cast_coe.{v} R
                     (@add_group.to_has_neg.{v} R
                        (@add_comm_group.to_add_group.{v} R
                           (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                     (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
            (@coe.{1 1} (@units.{0} int int.monoid) int
               (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                  (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
               (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                  ((λ (σ : equiv.perm.{u+1} n)
                    (_x :
                      @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                        (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                        σ
                        (@finset.univ.{u} (equiv.perm.{u+1} n)
                           (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                              (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                              _inst_1
                              _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
                     a
                     ha))))
         (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
            (@finset.univ.{u} n _inst_1)
            (λ (i : n),
               M
                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                    ((λ (σ : equiv.perm.{u+1} n)
                      (_x :
                        @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                          (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                          σ
                          (@finset.univ.{u} (equiv.perm.{u+1} n)
                             (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                                (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                                _inst_1
                                _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
                       a
                       ha)
                    i)
                 i)))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ ∀ (a₁ a₂ : equiv.perm.{u+1} n)
  (ha₁ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₁
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1)))
  (ha₂ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₂
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1))),
    @eq.{u+1} (equiv.perm.{u+1} n)
      ((λ (σ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            σ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  _inst_1
                  _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
         a₁
         ha₁)
      ((λ (σ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            σ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  _inst_1
                  _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
         a₂
         ha₂) →
    @eq.{u+1} (equiv.perm.{u+1} n) a₁ a₂

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ ∀ (b : equiv.perm.{u+1} n),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      b
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1)) →
    @Exists.{u+1} (equiv.perm.{u+1} n)
      (λ (a : equiv.perm.{u+1} n),
         @Exists.{0}
           (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
              (@finset.has_mem.{u} (equiv.perm.{u+1} n))
              a
              (@finset.univ.{u} (equiv.perm.{u+1} n)
                 (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                    (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                    _inst_1
                    _inst_1)))
           (λ
            (ha :
              @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                a
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      _inst_1
                      _inst_1))),
              @eq.{u+1} (equiv.perm.{u+1} n) b
                ((λ (σ : equiv.perm.{u+1} n)
                  (_x :
                    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                      (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                      σ
                      (@finset.univ.{u} (equiv.perm.{u+1} n)
                         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                            _inst_1
                            _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
                   a
                   ha)))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
_x :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ has_inv.{u} (equiv.perm.{u+1} n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ ∀ (a : equiv.perm.{u+1} n)
  (ha :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1))),
    @eq.{v+1} R
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} int R
            (@coe_to_lift.{1 v+1} int R
               (@coe_base.{1 v+1} int R
                  (@int.cast_coe.{v} R
                     (@add_group.to_has_neg.{v} R
                        (@add_comm_group.to_add_group.{v} R
                           (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                     (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
            (@coe.{1 1} (@units.{0} int int.monoid) int
               (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                  (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
               (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 a)))
         (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
            (@finset.univ.{u} n _inst_1)
            (λ (i : n),
               @matrix.transpose.{u v} n n _inst_1 _inst_1 R M
                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) a i)
                 i)))
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} int R
            (@coe_to_lift.{1 v+1} int R
               (@coe_base.{1 v+1} int R
                  (@int.cast_coe.{v} R
                     (@add_group.to_has_neg.{v} R
                        (@add_comm_group.to_add_group.{v} R
                           (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                     (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
            (@coe.{1 1} (@units.{0} int int.monoid) int
               (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                  (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
               (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                  ((λ (σ : equiv.perm.{u+1} n)
                    (_x :
                      @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                        (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                        σ
                        (@finset.univ.{u} (equiv.perm.{u+1} n)
                           (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                              (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                              _inst_1
                              _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
                     a
                     ha))))
         (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
            (@finset.univ.{u} n _inst_1)
            (λ (i : n),
               M
                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                    ((λ (σ : equiv.perm.{u+1} n)
                      (_x :
                        @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                          (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                          σ
                          (@finset.univ.{u} (equiv.perm.{u+1} n)
                             (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                                (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                                _inst_1
                                _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
                       a
                       ha)
                    i)
                 i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @matrix.transpose.{u v} n n _inst_1 _inst_1 R M
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
               i)))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                ((λ (σ : equiv.perm.{u+1} n)
                  (_x :
                    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                      (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                      σ
                      (@finset.univ.{u} (equiv.perm.{u+1} n)
                         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                            _inst_1
                            _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
                   σ
                   ha))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             M
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  ((λ (σ : equiv.perm.{u+1} n)
                    (_x :
                      @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                        (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                        σ
                        (@finset.univ.{u} (equiv.perm.{u+1} n)
                           (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                              (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                              _inst_1
                              _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
                     σ
                     ha)
                  i)
               i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114      rw [sign_inv],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='equiv.perm.sign_inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/perm/sign.lean&#x27;, &#x27;line&#x27;: 482, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : fintype.{u} α] (f : equiv.perm.{u+1} α), @eq.{1} (@units.{0} int int.monoid) (@equiv.perm.sign.{u} α (λ (a b : α), _inst_1 a b) _inst_2 (@has_inv.inv.{u} (equiv.perm.{u+1} α) (@group.to_has_inv.{u} (equiv.perm.{u+1} α) (@equiv.perm.perm_group.{u} α)) f)) (@equiv.perm.sign.{u} α (λ (a b : α), _inst_1 a b) _inst_2 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @matrix.transpose.{u v} n n _inst_1 _inst_1 R M
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
               i)))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                ((λ (σ : equiv.perm.{u+1} n)
                  (_x :
                    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                      (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                      σ
                      (@finset.univ.{u} (equiv.perm.{u+1} n)
                         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                            _inst_1
                            _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
                   σ
                   ha))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             M
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  ((λ (σ : equiv.perm.{u+1} n)
                    (_x :
                      @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                        (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                        σ
                        (@finset.univ.{u} (equiv.perm.{u+1} n)
                           (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                              (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                              _inst_1
                              _inst_1))), @has_inv.inv.{u} (equiv.perm.{u+1} n) ?m_1[σ, _x] σ)
                     σ
                     ha)
                  i)
               i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @matrix.transpose.{u v} n n _inst_1 _inst_1 R M
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
               i)))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             M
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  ((λ (σ : equiv.perm.{u+1} n)
                    (_x :
                      @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                        (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                        σ
                        (@finset.univ.{u} (equiv.perm.{u+1} n)
                           (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                              (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                              _inst_1
                              _inst_1))),
                      @has_inv.inv.{u} (equiv.perm.{u+1} n)
                        (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                        σ)
                     σ
                     ha)
                  i)
               i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115      congr&#x27; 1,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@interactive.with_desc nat (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Same as the `congr` tactic, but takes an optional argument which gives
the depth of recursive applications. This is useful when `congr`
is too aggressive in breaking down the goal. For example, given
`⊢ f (g (x + y)) = f (g (y + x))`, `congr&#x27;` produces the goals `⊢ x = y`
and `⊢ y = x`, while `congr&#x27; 2` produces the intended `⊢ x + y = y + x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='congr&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;n?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @matrix.transpose.{u v} n n _inst_1 _inst_1 R M
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
               i)))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             M
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  ((λ (σ : equiv.perm.{u+1} n)
                    (_x :
                      @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                        (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                        σ
                        (@finset.univ.{u} (equiv.perm.{u+1} n)
                           (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                              (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                              _inst_1
                              _inst_1))),
                      @has_inv.inv.{u} (equiv.perm.{u+1} n)
                        (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                        σ)
                     σ
                     ha)
                  i)
               i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (i : n),
          @matrix.transpose.{u v} n n _inst_1 _inst_1 R M
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
            i))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (i : n),
          M
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
               ((λ (σ : equiv.perm.{u+1} n)
                 (_x :
                   @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                     (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                     σ
                     (@finset.univ.{u} (equiv.perm.{u+1} n)
                        (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                           (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                           _inst_1
                           _inst_1))),
                   @has_inv.inv.{u} (equiv.perm.{u+1} n)
                     (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                     σ)
                  σ
                  ha)
               i)
            i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116      apply prod_bij (λ i _, σ i),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='finset.prod_bij'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 277, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} {γ : Type u} [_inst_1 : comm_monoid.{v} β] {s : finset.{u} α} {t : finset.{u} γ} {f : α → β} {g : γ → β} (i : Π (a : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s → γ), (∀ (a : α) (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @has_mem.mem.{u u} γ (finset.{u} γ) (@finset.has_mem.{u} γ) (i a ha) t) → (∀ (a : α) (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @eq.{v+1} β (f a) (g (i a ha))) → (∀ (a₁ a₂ : α) (ha₁ : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a₁ s) (ha₂ : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a₂ s), @eq.{u+1} γ (i a₁ ha₁) (i a₂ ha₂) → @eq.{u+1} α a₁ a₂) → (∀ (b : γ), @has_mem.mem.{u u} γ (finset.{u} γ) (@finset.has_mem.{u} γ) b t → @Exists.{u+1} α (λ (a : α), @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s) (λ (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @eq.{u+1} γ b (i a ha)))) → @eq.{v+1} β (@finset.prod.{u v} α β _inst_1 s f) (@finset.prod.{u v} γ β _inst_1 t g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (i : n),
          @matrix.transpose.{u v} n n _inst_1 _inst_1 R M
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
            i))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (i : n),
          M
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
               ((λ (σ : equiv.perm.{u+1} n)
                 (_x :
                   @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                     (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                     σ
                     (@finset.univ.{u} (equiv.perm.{u+1} n)
                        (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                           (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                           _inst_1
                           _inst_1))),
                   @has_inv.inv.{u} (equiv.perm.{u+1} n)
                     (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                     σ)
                  σ
                  ha)
               i)
            i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ ∀ (a : n) (ha : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1)),
    @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n)
      ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
          @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
         a
         ha)
      (@finset.univ.{u} n _inst_1)

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ ∀ (a : n) (ha_1 : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1)),
    @eq.{v+1} R
      (@matrix.transpose.{u v} n n _inst_1 _inst_1 R M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ a)
         a)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            ((λ (σ : equiv.perm.{u+1} n)
              (_x :
                @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                  (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                  σ
                  (@finset.univ.{u} (equiv.perm.{u+1} n)
                     (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                        (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                        _inst_1
                        _inst_1))),
                @has_inv.inv.{u} (equiv.perm.{u+1} n)
                  (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                  σ)
               σ
               ha)
            ((λ (i : n)
              (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
                @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
               a
               ha_1))
         ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
             @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
            a
            ha_1))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ ∀ (a₁ a₂ : n)
  (ha₁ : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a₁ (@finset.univ.{u} n _inst_1))
  (ha₂ : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a₂ (@finset.univ.{u} n _inst_1)),
    @eq.{u+1} n
      ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
          @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
         a₁
         ha₁)
      ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
          @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
         a₂
         ha₂) →
    @eq.{u+1} n a₁ a₂

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ ∀ (b : n),
    @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) b (@finset.univ.{u} n _inst_1) →
    @Exists.{u+1} n
      (λ (a : n),
         @Exists.{0} (@has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1))
           (λ (ha : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1)),
              @eq.{u+1} n b
                ((λ (i : n)
                  (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
                    @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
                   a
                   ha)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117      { intros i _, apply mem_univ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='finset.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : fintype.{u} α] (x : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x (@finset.univ.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ ∀ (a : n) (ha : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1)),
    @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n)
      ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
          @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
         a
         ha)
      (@finset.univ.{u} n _inst_1)

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ ∀ (a : n) (ha_1 : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1)),
    @eq.{v+1} R
      (@matrix.transpose.{u v} n n _inst_1 _inst_1 R M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ a)
         a)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            ((λ (σ : equiv.perm.{u+1} n)
              (_x :
                @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                  (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                  σ
                  (@finset.univ.{u} (equiv.perm.{u+1} n)
                     (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                        (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                        _inst_1
                        _inst_1))),
                @has_inv.inv.{u} (equiv.perm.{u+1} n)
                  (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                  σ)
               σ
               ha)
            ((λ (i : n)
              (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
                @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
               a
               ha_1))
         ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
             @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
            a
            ha_1))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ ∀ (a₁ a₂ : n)
  (ha₁ : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a₁ (@finset.univ.{u} n _inst_1))
  (ha₂ : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a₂ (@finset.univ.{u} n _inst_1)),
    @eq.{u+1} n
      ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
          @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
         a₁
         ha₁)
      ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
          @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
         a₂
         ha₂) →
    @eq.{u+1} n a₁ a₂

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ ∀ (b : n),
    @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) b (@finset.univ.{u} n _inst_1) →
    @Exists.{u+1} n
      (λ (a : n),
         @Exists.{0} (@has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1))
           (λ (ha : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1)),
              @eq.{u+1} n b
                ((λ (i : n)
                  (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
                    @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
                   a
                   ha)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ ∀ (a : n) (ha : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1)),
    @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n)
      ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
          @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
         a
         ha)
      (@finset.univ.{u} n _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
i : n,
ha_1 : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)
⊢ @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n)
    ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
        @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
       i
       ha_1)
    (@finset.univ.{u} n _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ ∀ (a : n) (ha_1 : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1)),
    @eq.{v+1} R
      (@matrix.transpose.{u v} n n _inst_1 _inst_1 R M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ a)
         a)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            ((λ (σ : equiv.perm.{u+1} n)
              (_x :
                @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                  (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                  σ
                  (@finset.univ.{u} (equiv.perm.{u+1} n)
                     (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                        (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                        _inst_1
                        _inst_1))),
                @has_inv.inv.{u} (equiv.perm.{u+1} n)
                  (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                  σ)
               σ
               ha)
            ((λ (i : n)
              (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
                @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
               a
               ha_1))
         ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
             @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
            a
            ha_1))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ ∀ (a₁ a₂ : n)
  (ha₁ : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a₁ (@finset.univ.{u} n _inst_1))
  (ha₂ : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a₂ (@finset.univ.{u} n _inst_1)),
    @eq.{u+1} n
      ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
          @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
         a₁
         ha₁)
      ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
          @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
         a₂
         ha₂) →
    @eq.{u+1} n a₁ a₂

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ ∀ (b : n),
    @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) b (@finset.univ.{u} n _inst_1) →
    @Exists.{u+1} n
      (λ (a : n),
         @Exists.{0} (@has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1))
           (λ (ha : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1)),
              @eq.{u+1} n b
                ((λ (i : n)
                  (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
                    @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
                   a
                   ha)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118      { intros i _, simp },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ ∀ (a : n) (ha_1 : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1)),
    @eq.{v+1} R
      (@matrix.transpose.{u v} n n _inst_1 _inst_1 R M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ a)
         a)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            ((λ (σ : equiv.perm.{u+1} n)
              (_x :
                @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                  (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                  σ
                  (@finset.univ.{u} (equiv.perm.{u+1} n)
                     (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                        (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                        _inst_1
                        _inst_1))),
                @has_inv.inv.{u} (equiv.perm.{u+1} n)
                  (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                  σ)
               σ
               ha)
            ((λ (i : n)
              (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
                @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
               a
               ha_1))
         ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
             @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
            a
            ha_1))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ ∀ (a₁ a₂ : n)
  (ha₁ : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a₁ (@finset.univ.{u} n _inst_1))
  (ha₂ : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a₂ (@finset.univ.{u} n _inst_1)),
    @eq.{u+1} n
      ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
          @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
         a₁
         ha₁)
      ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
          @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
         a₂
         ha₂) →
    @eq.{u+1} n a₁ a₂

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ ∀ (b : n),
    @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) b (@finset.univ.{u} n _inst_1) →
    @Exists.{u+1} n
      (λ (a : n),
         @Exists.{0} (@has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1))
           (λ (ha : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1)),
              @eq.{u+1} n b
                ((λ (i : n)
                  (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
                    @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
                   a
                   ha)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ ∀ (a : n) (ha_1 : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1)),
    @eq.{v+1} R
      (@matrix.transpose.{u v} n n _inst_1 _inst_1 R M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ a)
         a)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            ((λ (σ : equiv.perm.{u+1} n)
              (_x :
                @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                  (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                  σ
                  (@finset.univ.{u} (equiv.perm.{u+1} n)
                     (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                        (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                        _inst_1
                        _inst_1))),
                @has_inv.inv.{u} (equiv.perm.{u+1} n)
                  (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                  σ)
               σ
               ha)
            ((λ (i : n)
              (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
                @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
               a
               ha_1))
         ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
             @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
            a
            ha_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
i : n,
ha_1 : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)
⊢ @eq.{v+1} R
    (@matrix.transpose.{u v} n n _inst_1 _inst_1 R M
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
       i)
    (M
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          ((λ (σ : equiv.perm.{u+1} n)
            (_x :
              @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                σ
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      _inst_1
                      _inst_1))),
              @has_inv.inv.{u} (equiv.perm.{u+1} n)
                (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                σ)
             σ
             ha)
          ((λ (i : n)
            (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
              @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
             i
             ha_1))
       ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
           @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
          i
          ha_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ ∀ (a₁ a₂ : n)
  (ha₁ : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a₁ (@finset.univ.{u} n _inst_1))
  (ha₂ : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a₂ (@finset.univ.{u} n _inst_1)),
    @eq.{u+1} n
      ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
          @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
         a₁
         ha₁)
      ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
          @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
         a₂
         ha₂) →
    @eq.{u+1} n a₁ a₂

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ ∀ (b : n),
    @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) b (@finset.univ.{u} n _inst_1) →
    @Exists.{u+1} n
      (λ (a : n),
         @Exists.{0} (@has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1))
           (λ (ha : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1)),
              @eq.{u+1} n b
                ((λ (i : n)
                  (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
                    @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
                   a
                   ha)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119      { intros i j _ _ h, simp at h, assumption },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ ∀ (a₁ a₂ : n)
  (ha₁ : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a₁ (@finset.univ.{u} n _inst_1))
  (ha₂ : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a₂ (@finset.univ.{u} n _inst_1)),
    @eq.{u+1} n
      ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
          @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
         a₁
         ha₁)
      ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
          @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
         a₂
         ha₂) →
    @eq.{u+1} n a₁ a₂

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ ∀ (b : n),
    @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) b (@finset.univ.{u} n _inst_1) →
    @Exists.{u+1} n
      (λ (a : n),
         @Exists.{0} (@has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1))
           (λ (ha : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1)),
              @eq.{u+1} n b
                ((λ (i : n)
                  (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
                    @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
                   a
                   ha)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ ∀ (a₁ a₂ : n)
  (ha₁ : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a₁ (@finset.univ.{u} n _inst_1))
  (ha₂ : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a₂ (@finset.univ.{u} n _inst_1)),
    @eq.{u+1} n
      ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
          @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
         a₁
         ha₁)
      ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
          @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
         a₂
         ha₂) →
    @eq.{u+1} n a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
i j : n,
ha₁ : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1),
ha₂ : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) j (@finset.univ.{u} n _inst_1),
h :
  @eq.{u+1} n
    ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
        @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
       i
       ha₁)
    ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
        @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
       j
       ha₂)
⊢ @eq.{u+1} n i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
i j : n,
ha₁ : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1),
ha₂ : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) j (@finset.univ.{u} n _inst_1),
h : @eq.{u+1} n i j
⊢ @eq.{u+1} n i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ ∀ (b : n),
    @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) b (@finset.univ.{u} n _inst_1) →
    @Exists.{u+1} n
      (λ (a : n),
         @Exists.{0} (@has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1))
           (λ (ha : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1)),
              @eq.{u+1} n b
                ((λ (i : n)
                  (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
                    @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
                   a
                   ha)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120      { intros i _, use σ⁻¹ i, finish } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/finish.lean&#x27;, &#x27;line&#x27;: 558, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (option.{0} (list.{0} pexpr)) (λ (a : option.{0} (list.{0} pexpr)), @option.has_reflect (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(list.{0} pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} pexpr) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} pexpr) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.pexpr_list_or_texpr)) → opt_param.{1} auto.auto_config {use_simp := bool.tt, classical := bool.tt, max_ematch_rounds := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`finish [h1,...,hn] using [e1,...,en]` negates the goal, normalizes hypotheses
(by splitting conjunctions, eliminating existentials, pushing negations inwards,
and calling `simp` with the supplied lemmas `h1,...,hn`), and then tries `contradiction`.

If this fails, it will create an SMT state and repeatedly use `ematch`
(using `ematch` lemmas in the environment, universally quantified assumptions,
and the supplied lemmas `e1,...,en`) and congruence closure.

`finish` is complete for propositional logic.

Either of the supplied simp lemmas or the supplied ematch lemmas are optional.

`finish` will fail if it does not close the goal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='finish'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(using ([expr, ...] | expr))?&#x27;, &#x27;auto.auto_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ ∀ (b : n),
    @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) b (@finset.univ.{u} n _inst_1) →
    @Exists.{u+1} n
      (λ (a : n),
         @Exists.{0} (@has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1))
           (λ (ha : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1)),
              @eq.{u+1} n b
                ((λ (i : n)
                  (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
                    @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
                   a
                   ha)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
i : n,
H : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)
⊢ @Exists.{u+1} n
    (λ (a : n),
       @Exists.{0} (@has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1))
         (λ (ha : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) a (@finset.univ.{u} n _inst_1)),
            @eq.{u+1} n i
              ((λ (i : n)
                (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
                  @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
                 a
                 ha)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
i : n,
H : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)
⊢ @Exists.{0}
    (@has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n)
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          (@has_inv.inv.{u} (equiv.perm.{u+1} n)
             (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
             σ)
          i)
       (@finset.univ.{u} n _inst_1))
    (λ
     (ha :
       @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n)
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@has_inv.inv.{u} (equiv.perm.{u+1} n)
               (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
               σ)
            i)
         (@finset.univ.{u} n _inst_1)),
       @eq.{u+1} n i
         ((λ (i : n) (_x : @has_mem.mem.{u u} n (finset.{u} n) (@finset.has_mem.{u} n) i (@finset.univ.{u} n _inst_1)),
             @coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
               (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                  (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                  σ)
               i)
            ha))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ ∀ (a₁ a₂ : equiv.perm.{u+1} n)
  (ha₁ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₁
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1)))
  (ha₂ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₂
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1))),
    @eq.{u+1} (equiv.perm.{u+1} n)
      ((λ (σ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            σ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  _inst_1
                  _inst_1))),
          @has_inv.inv.{u} (equiv.perm.{u+1} n)
            (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
            σ)
         a₁
         ha₁)
      ((λ (σ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            σ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  _inst_1
                  _inst_1))),
          @has_inv.inv.{u} (equiv.perm.{u+1} n)
            (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
            σ)
         a₂
         ha₂) →
    @eq.{u+1} (equiv.perm.{u+1} n) a₁ a₂

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ ∀ (b : equiv.perm.{u+1} n),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      b
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1)) →
    @Exists.{u+1} (equiv.perm.{u+1} n)
      (λ (a : equiv.perm.{u+1} n),
         @Exists.{0}
           (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
              (@finset.has_mem.{u} (equiv.perm.{u+1} n))
              a
              (@finset.univ.{u} (equiv.perm.{u+1} n)
                 (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                    (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                    _inst_1
                    _inst_1)))
           (λ
            (ha :
              @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                a
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      _inst_1
                      _inst_1))),
              @eq.{u+1} (equiv.perm.{u+1} n) b
                ((λ (σ : equiv.perm.{u+1} n)
                  (_x :
                    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                      (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                      σ
                      (@finset.univ.{u} (equiv.perm.{u+1} n)
                         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                            _inst_1
                            _inst_1))),
                    @has_inv.inv.{u} (equiv.perm.{u+1} n)
                      (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                      σ)
                   a
                   ha)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121    { intros σ σ&#x27; _ _ h, simp at h, assumption },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ ∀ (a₁ a₂ : equiv.perm.{u+1} n)
  (ha₁ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₁
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1)))
  (ha₂ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₂
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1))),
    @eq.{u+1} (equiv.perm.{u+1} n)
      ((λ (σ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            σ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  _inst_1
                  _inst_1))),
          @has_inv.inv.{u} (equiv.perm.{u+1} n)
            (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
            σ)
         a₁
         ha₁)
      ((λ (σ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            σ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  _inst_1
                  _inst_1))),
          @has_inv.inv.{u} (equiv.perm.{u+1} n)
            (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
            σ)
         a₂
         ha₂) →
    @eq.{u+1} (equiv.perm.{u+1} n) a₁ a₂

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ ∀ (b : equiv.perm.{u+1} n),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      b
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1)) →
    @Exists.{u+1} (equiv.perm.{u+1} n)
      (λ (a : equiv.perm.{u+1} n),
         @Exists.{0}
           (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
              (@finset.has_mem.{u} (equiv.perm.{u+1} n))
              a
              (@finset.univ.{u} (equiv.perm.{u+1} n)
                 (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                    (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                    _inst_1
                    _inst_1)))
           (λ
            (ha :
              @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                a
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      _inst_1
                      _inst_1))),
              @eq.{u+1} (equiv.perm.{u+1} n) b
                ((λ (σ : equiv.perm.{u+1} n)
                  (_x :
                    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                      (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                      σ
                      (@finset.univ.{u} (equiv.perm.{u+1} n)
                         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                            _inst_1
                            _inst_1))),
                    @has_inv.inv.{u} (equiv.perm.{u+1} n)
                      (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                      σ)
                   a
                   ha)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ ∀ (a₁ a₂ : equiv.perm.{u+1} n)
  (ha₁ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₁
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1)))
  (ha₂ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₂
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1))),
    @eq.{u+1} (equiv.perm.{u+1} n)
      ((λ (σ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            σ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  _inst_1
                  _inst_1))),
          @has_inv.inv.{u} (equiv.perm.{u+1} n)
            (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
            σ)
         a₁
         ha₁)
      ((λ (σ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            σ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  _inst_1
                  _inst_1))),
          @has_inv.inv.{u} (equiv.perm.{u+1} n)
            (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
            σ)
         a₂
         ha₂) →
    @eq.{u+1} (equiv.perm.{u+1} n) a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ σ&#x27; : equiv.perm.{u+1} n,
ha₁ :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
ha₂ :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ&#x27;
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
h :
  @eq.{u+1} (equiv.perm.{u+1} n)
    ((λ (σ : equiv.perm.{u+1} n)
      (_x :
        @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
          (@finset.has_mem.{u} (equiv.perm.{u+1} n))
          σ
          (@finset.univ.{u} (equiv.perm.{u+1} n)
             (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                _inst_1
                _inst_1))),
        @has_inv.inv.{u} (equiv.perm.{u+1} n)
          (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
          σ)
       σ
       ha₁)
    ((λ (σ : equiv.perm.{u+1} n)
      (_x :
        @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
          (@finset.has_mem.{u} (equiv.perm.{u+1} n))
          σ
          (@finset.univ.{u} (equiv.perm.{u+1} n)
             (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                _inst_1
                _inst_1))),
        @has_inv.inv.{u} (equiv.perm.{u+1} n)
          (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
          σ)
       σ&#x27;
       ha₂)
⊢ @eq.{u+1} (equiv.perm.{u+1} n) σ σ&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ σ&#x27; : equiv.perm.{u+1} n,
ha₁ :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
ha₂ :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ&#x27;
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
h : @eq.{u+1} (equiv.perm.{u+1} n) σ σ&#x27;
⊢ @eq.{u+1} (equiv.perm.{u+1} n) σ σ&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ ∀ (b : equiv.perm.{u+1} n),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      b
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1)) →
    @Exists.{u+1} (equiv.perm.{u+1} n)
      (λ (a : equiv.perm.{u+1} n),
         @Exists.{0}
           (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
              (@finset.has_mem.{u} (equiv.perm.{u+1} n))
              a
              (@finset.univ.{u} (equiv.perm.{u+1} n)
                 (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                    (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                    _inst_1
                    _inst_1)))
           (λ
            (ha :
              @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                a
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      _inst_1
                      _inst_1))),
              @eq.{u+1} (equiv.perm.{u+1} n) b
                ((λ (σ : equiv.perm.{u+1} n)
                  (_x :
                    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                      (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                      σ
                      (@finset.univ.{u} (equiv.perm.{u+1} n)
                         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                            _inst_1
                            _inst_1))),
                    @has_inv.inv.{u} (equiv.perm.{u+1} n)
                      (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                      σ)
                   a
                   ha)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122    { intros σ _, use σ⁻¹, finish }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/finish.lean&#x27;, &#x27;line&#x27;: 558, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (option.{0} (list.{0} pexpr)) (λ (a : option.{0} (list.{0} pexpr)), @option.has_reflect (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(list.{0} pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} pexpr) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} pexpr) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.pexpr_list_or_texpr)) → opt_param.{1} auto.auto_config {use_simp := bool.tt, classical := bool.tt, max_ematch_rounds := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`finish [h1,...,hn] using [e1,...,en]` negates the goal, normalizes hypotheses
(by splitting conjunctions, eliminating existentials, pushing negations inwards,
and calling `simp` with the supplied lemmas `h1,...,hn`), and then tries `contradiction`.

If this fails, it will create an SMT state and repeatedly use `ematch`
(using `ematch` lemmas in the environment, universally quantified assumptions,
and the supplied lemmas `e1,...,en`) and congruence closure.

`finish` is complete for propositional logic.

Either of the supplied simp lemmas or the supplied ematch lemmas are optional.

`finish` will fail if it does not close the goal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='finish'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(using ([expr, ...] | expr))?&#x27;, &#x27;auto.auto_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ ∀ (b : equiv.perm.{u+1} n),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      b
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1)) →
    @Exists.{u+1} (equiv.perm.{u+1} n)
      (λ (a : equiv.perm.{u+1} n),
         @Exists.{0}
           (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
              (@finset.has_mem.{u} (equiv.perm.{u+1} n))
              a
              (@finset.univ.{u} (equiv.perm.{u+1} n)
                 (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                    (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                    _inst_1
                    _inst_1)))
           (λ
            (ha :
              @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                a
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      _inst_1
                      _inst_1))),
              @eq.{u+1} (equiv.perm.{u+1} n) b
                ((λ (σ : equiv.perm.{u+1} n)
                  (_x :
                    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                      (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                      σ
                      (@finset.univ.{u} (equiv.perm.{u+1} n)
                         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                            _inst_1
                            _inst_1))),
                    @has_inv.inv.{u} (equiv.perm.{u+1} n)
                      (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                      σ)
                   a
                   ha)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @Exists.{u+1} (equiv.perm.{u+1} n)
    (λ (a : equiv.perm.{u+1} n),
       @Exists.{0}
         (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            a
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  _inst_1
                  _inst_1)))
         (λ
          (ha :
            @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
              (@finset.has_mem.{u} (equiv.perm.{u+1} n))
              a
              (@finset.univ.{u} (equiv.perm.{u+1} n)
                 (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                    (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                    _inst_1
                    _inst_1))),
            @eq.{u+1} (equiv.perm.{u+1} n) σ
              ((λ (σ : equiv.perm.{u+1} n)
                (_x :
                  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                    (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                    σ
                    (@finset.univ.{u} (equiv.perm.{u+1} n)
                       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                          _inst_1
                          _inst_1))),
                  @has_inv.inv.{u} (equiv.perm.{u+1} n)
                    (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                    σ)
                 a
                 ha)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @Exists.{0}
    (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
       (@finset.has_mem.{u} (equiv.perm.{u+1} n))
       (@has_inv.inv.{u} (equiv.perm.{u+1} n)
          (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
          σ)
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
             (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
             _inst_1
             _inst_1)))
    (λ
     (ha :
       @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_mem.{u} (equiv.perm.{u+1} n))
         (@has_inv.inv.{u} (equiv.perm.{u+1} n)
            (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
            σ)
         (@finset.univ.{u} (equiv.perm.{u+1} n)
            (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
               (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
               _inst_1
               _inst_1))),
       @eq.{u+1} (equiv.perm.{u+1} n) σ
         ((λ (σ : equiv.perm.{u+1} n)
           (_x :
             @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
               (@finset.has_mem.{u} (equiv.perm.{u+1} n))
               σ
               (@finset.univ.{u} (equiv.perm.{u+1} n)
                  (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                     (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                     _inst_1
                     _inst_1))),
             @has_inv.inv.{u} (equiv.perm.{u+1} n)
               (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
               σ)
            (@has_inv.inv.{u} (equiv.perm.{u+1} n)
               (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
               σ)
            ha))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  /-- The determinant of a permutation matrix equals its sign. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  @[simp] lemma det_permutation (σ : perm n) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='equiv.perm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Sort u_1 → Sort (max 1 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`perm α` is the type of bijections from `α` to itself.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127    matrix.det (σ.to_pequiv.to_matrix : matrix n n R) = σ.sign := begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='matrix.det'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='equiv.to_pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='pequiv.to_matrix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='matrix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='equiv.perm.sign'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pequiv.lean&#x27;, &#x27;line&#x27;: 317, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/pequiv.lean&#x27;, &#x27;line&#x27;: 47, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/basic.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/perm/sign.lean&#x27;, &#x27;line&#x27;: 464, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {n : Type u} [_inst_1 : fintype.{u} n] [_inst_2 : decidable_eq.{u+1} n] {R : Type v} [_inst_3 : comm_ring.{v} R], @matrix.{u v} n n _inst_1 _inst_1 R → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, equiv.{u+1 u+1} α β → pequiv.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {m n : Type u} [_inst_3 : fintype.{u} m] [_inst_4 : fintype.{u} n] [_inst_7 : decidable_eq.{u+1} m] [_inst_8 : decidable_eq.{u+1} n] {α : Type v} [_inst_9 : has_one.{v} α] [_inst_10 : has_zero.{v} α], pequiv.{u u} m n → @matrix.{u v} m n _inst_3 _inst_4 α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (m n : Type u) [_inst_1 : fintype.{u} m] [_inst_2 : fintype.{u} n], Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : fintype.{u} α], equiv.perm.{u+1} α → @units.{0} int int.monoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The determinant of a matrix given by the Leibniz formula.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`to_matrix` returns a matrix containing ones and zeros. `f.to_matrix i j` is `1` if
 `f i = some j` and `0` otherwise'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                </code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (@pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
          (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
          (@mul_zero_class.to_has_zero.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@equiv.to_pequiv.{u u} n n σ)))
    (@coe.{1 v+1} (@units.{0} int int.monoid) R
       (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
          (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
       (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128    suffices : matrix.det (σ.to_pequiv.to_matrix) = ↑σ.sign * det (1 : matrix n n R), { simp [this] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='equiv.to_pequiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='matrix.det'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='matrix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/pequiv.lean&#x27;, &#x27;line&#x27;: 317, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/perm/sign.lean&#x27;, &#x27;line&#x27;: 464, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/basic.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α β : Type u}, equiv.{u+1 u+1} α β → pequiv.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {a : Type} {b : Type v} [_inst_1 : has_lift_t.{1 v+1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : Type u} [_inst_1 : fintype.{u} n] [_inst_2 : decidable_eq.{u+1} n] {R : Type v} [_inst_3 : comm_ring.{v} R], @matrix.{u v} n n _inst_1 _inst_1 R → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (m n : Type u) [_inst_1 : fintype.{u} m] [_inst_2 : fintype.{u} n], Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} R (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 (@pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))) (@mul_zero_class.to_has_zero.{v} R (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (@equiv.to_pequiv.{u u} n n σ))) (@has_mul.mul.{v} R (@mul_zero_class.to_has_mul.{v} R (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (@coe.{1 v+1} (@units.{0} int int.monoid) R (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid) (@coe_base.{1 v+1} int R (@int.cast_coe.{v} R (@add_group.to_has_neg.{v} R (@add_comm_group.to_add_group.{v} R (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (@mul_zero_class.to_has_zero.{v} R (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))) (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))) (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)) (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 (@has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R) (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b) (@mul_zero_class.to_has_zero.{v} R (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`to_matrix` returns a matrix containing ones and zeros. `f.to_matrix i j` is `1` if
 `f i = some j` and `0` otherwise'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The determinant of a matrix given by the Leibniz formula.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (@pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
          (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
          (@mul_zero_class.to_has_zero.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@equiv.to_pequiv.{u u} n n σ)))
    (@coe.{1 v+1} (@units.{0} int int.monoid) R
       (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
          (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
       (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n,
this :
  @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (@pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
          (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
          (@mul_zero_class.to_has_zero.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@equiv.to_pequiv.{u u} n n σ)))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} (@units.{0} int int.monoid) R
          (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
             (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
       (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
          (@has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
             (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (@pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
          (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
          (@mul_zero_class.to_has_zero.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@equiv.to_pequiv.{u u} n n σ)))
    (@coe.{1 v+1} (@units.{0} int int.monoid) R
       (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
          (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
       (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (@pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
          (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
          (@mul_zero_class.to_has_zero.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@equiv.to_pequiv.{u u} n n σ)))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} (@units.{0} int int.monoid) R
          (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
             (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
       (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
          (@has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
             (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n,
this :
  @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (@pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
          (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
          (@mul_zero_class.to_has_zero.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@equiv.to_pequiv.{u u} n n σ)))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} (@units.{0} int int.monoid) R
          (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
             (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
       (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
          (@has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
             (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (@pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
          (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
          (@mul_zero_class.to_has_zero.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@equiv.to_pequiv.{u u} n n σ)))
    (@coe.{1 v+1} (@units.{0} int int.monoid) R
       (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
          (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
       (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (@pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
          (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
          (@mul_zero_class.to_has_zero.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@equiv.to_pequiv.{u u} n n σ)))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} (@units.{0} int int.monoid) R
          (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
             (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
       (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
          (@has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
             (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129    unfold det,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (@pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
          (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
          (@mul_zero_class.to_has_zero.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@equiv.to_pequiv.{u u} n n σ)))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} (@units.{0} int int.monoid) R
          (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
             (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
       (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
          (@has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
             (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ_1 : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ_1)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (i : n),
                  @pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
                    (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                    (@mul_zero_class.to_has_zero.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (@equiv.to_pequiv.{u u} n n σ)
                    (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ_1 i)
                    i))))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} (@units.{0} int int.monoid) R
          (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
             (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
       (@finset.sum.{u v} (equiv.perm.{u+1} n) R
          (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
          (@finset.univ.{u} (equiv.perm.{u+1} n)
             (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
          (λ (σ : equiv.perm.{u+1} n),
             @has_mul.mul.{v} R
               (@mul_zero_class.to_has_mul.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (@coe.{1 v+1} int R
                  (@coe_to_lift.{1 v+1} int R
                     (@coe_base.{1 v+1} int R
                        (@int.cast_coe.{v} R
                           (@add_group.to_has_neg.{v} R
                              (@add_comm_group.to_add_group.{v} R
                                 (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                           (@mul_zero_class.to_has_zero.{v} R
                              (@semiring.to_mul_zero_class.{v} R
                                 (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                           (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                           (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
                  (@coe.{1 1} (@units.{0} int int.monoid) int
                     (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                        (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                     (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
               (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
                  (@finset.univ.{u} n _inst_1)
                  (λ (i : n),
                     @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
                       (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                          (@mul_zero_class.to_has_zero.{v} R
                             (@semiring.to_mul_zero_class.{v} R
                                (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                          (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
                       i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130    rw mul_sum,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='finset.mul_sum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 626, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} {s : finset.{u} α} {f : α → β} {b : β} [_inst_1 : semiring.{v} β], @eq.{v+1} β (@has_mul.mul.{v} β (@mul_zero_class.to_has_mul.{v} β (@semiring.to_mul_zero_class.{v} β _inst_1)) b (@finset.sum.{u v} α β (@semiring.to_add_comm_monoid.{v} β _inst_1) s f)) (@finset.sum.{u v} α β (@semiring.to_add_comm_monoid.{v} β _inst_1) s (λ (x : α), @has_mul.mul.{v} β (@mul_zero_class.to_has_mul.{v} β (@semiring.to_mul_zero_class.{v} β _inst_1)) b (f x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ_1 : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ_1)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (i : n),
                  @pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
                    (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                    (@mul_zero_class.to_has_zero.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (@equiv.to_pequiv.{u u} n n σ)
                    (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ_1 i)
                    i))))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} (@units.{0} int int.monoid) R
          (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
             (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
       (@finset.sum.{u v} (equiv.perm.{u+1} n) R
          (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
          (@finset.univ.{u} (equiv.perm.{u+1} n)
             (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
          (λ (σ : equiv.perm.{u+1} n),
             @has_mul.mul.{v} R
               (@mul_zero_class.to_has_mul.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (@coe.{1 v+1} int R
                  (@coe_to_lift.{1 v+1} int R
                     (@coe_base.{1 v+1} int R
                        (@int.cast_coe.{v} R
                           (@add_group.to_has_neg.{v} R
                              (@add_comm_group.to_add_group.{v} R
                                 (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                           (@mul_zero_class.to_has_zero.{v} R
                              (@semiring.to_mul_zero_class.{v} R
                                 (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                           (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                           (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
                  (@coe.{1 1} (@units.{0} int int.monoid) int
                     (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                        (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                     (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
               (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
                  (@finset.univ.{u} n _inst_1)
                  (λ (i : n),
                     @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
                       (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                          (@mul_zero_class.to_has_zero.{v} R
                             (@semiring.to_mul_zero_class.{v} R
                                (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                          (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
                       i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ_1 : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ_1)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (i : n),
                  @pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
                    (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                    (@mul_zero_class.to_has_zero.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (@equiv.to_pequiv.{u u} n n σ)
                    (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ_1 i)
                    i))))
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (x : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} (@units.{0} int int.monoid) R
               (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
                  (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
                     (@coe_base.{1 v+1} int R
                        (@int.cast_coe.{v} R
                           (@add_group.to_has_neg.{v} R
                              (@add_comm_group.to_add_group.{v} R
                                 (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                           (@mul_zero_class.to_has_zero.{v} R
                              (@semiring.to_mul_zero_class.{v} R
                                 (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                           (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                           (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
               (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
            (@has_mul.mul.{v} R
               (@mul_zero_class.to_has_mul.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (@coe.{1 v+1} int R
                  (@coe_to_lift.{1 v+1} int R
                     (@coe_base.{1 v+1} int R
                        (@int.cast_coe.{v} R
                           (@add_group.to_has_neg.{v} R
                              (@add_comm_group.to_add_group.{v} R
                                 (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                           (@mul_zero_class.to_has_zero.{v} R
                              (@semiring.to_mul_zero_class.{v} R
                                 (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                           (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                           (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
                  (@coe.{1 1} (@units.{0} int int.monoid) int
                     (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                        (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                     (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 x)))
               (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
                  (@finset.univ.{u} n _inst_1)
                  (λ (i : n),
                     @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
                       (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                          (@mul_zero_class.to_has_zero.{v} R
                             (@semiring.to_mul_zero_class.{v} R
                                (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                          (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) x i)
                       i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131    apply sum_bij (λ τ _, σ * τ),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='finset.sum_bij'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 277, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} {γ : Type u} [_inst_1 : add_comm_monoid.{v} β] {s : finset.{u} α} {t : finset.{u} γ} {f : α → β} {g : γ → β} (i : Π (a : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s → γ), (∀ (a : α) (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @has_mem.mem.{u u} γ (finset.{u} γ) (@finset.has_mem.{u} γ) (i a ha) t) → (∀ (a : α) (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @eq.{v+1} β (f a) (g (i a ha))) → (∀ (a₁ a₂ : α) (ha₁ : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a₁ s) (ha₂ : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a₂ s), @eq.{u+1} γ (i a₁ ha₁) (i a₂ ha₂) → @eq.{u+1} α a₁ a₂) → (∀ (b : γ), @has_mem.mem.{u u} γ (finset.{u} γ) (@finset.has_mem.{u} γ) b t → @Exists.{u+1} α (λ (a : α), @Exists.{0} (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s) (λ (ha : @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s), @eq.{u+1} γ b (i a ha)))) → @eq.{v+1} β (@finset.sum.{u v} α β _inst_1 s f) (@finset.sum.{u v} γ β _inst_1 t g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (σ_1 : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ_1)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (i : n),
                  @pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
                    (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                    (@mul_zero_class.to_has_zero.{v} R
                       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (@equiv.to_pequiv.{u u} n n σ)
                    (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ_1 i)
                    i))))
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
       (λ (x : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} (@units.{0} int int.monoid) R
               (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
                  (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
                     (@coe_base.{1 v+1} int R
                        (@int.cast_coe.{v} R
                           (@add_group.to_has_neg.{v} R
                              (@add_comm_group.to_add_group.{v} R
                                 (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                           (@mul_zero_class.to_has_zero.{v} R
                              (@semiring.to_mul_zero_class.{v} R
                                 (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                           (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                           (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
               (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
            (@has_mul.mul.{v} R
               (@mul_zero_class.to_has_mul.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (@coe.{1 v+1} int R
                  (@coe_to_lift.{1 v+1} int R
                     (@coe_base.{1 v+1} int R
                        (@int.cast_coe.{v} R
                           (@add_group.to_has_neg.{v} R
                              (@add_comm_group.to_add_group.{v} R
                                 (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                           (@mul_zero_class.to_has_zero.{v} R
                              (@semiring.to_mul_zero_class.{v} R
                                 (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                           (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                           (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
                  (@coe.{1 1} (@units.{0} int int.monoid) int
                     (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                        (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                     (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 x)))
               (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
                  (@finset.univ.{u} n _inst_1)
                  (λ (i : n),
                     @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
                       (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                          (@mul_zero_class.to_has_zero.{v} R
                             (@semiring.to_mul_zero_class.{v} R
                                (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                          (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) x i)
                       i)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ ∀ (a : equiv.perm.{u+1} n)
  (ha :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      ((λ (τ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            τ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
          @has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            σ
            τ)
         a
         ha)
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ ∀ (a : equiv.perm.{u+1} n)
  (ha :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
    @eq.{v+1} R
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} int R
            (@coe_to_lift.{1 v+1} int R
               (@coe_base.{1 v+1} int R
                  (@int.cast_coe.{v} R
                     (@add_group.to_has_neg.{v} R
                        (@add_comm_group.to_add_group.{v} R
                           (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                     (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
            (@coe.{1 1} (@units.{0} int int.monoid) int
               (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                  (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
               (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 a)))
         (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
            (@finset.univ.{u} n _inst_1)
            (λ (i : n),
               @pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
                 (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                 (@mul_zero_class.to_has_zero.{v} R
                    (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                 (@equiv.to_pequiv.{u u} n n σ)
                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) a i)
                 i)))
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} (@units.{0} int int.monoid) R
            (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
               (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
            (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
         (@has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
                     ((λ (τ : equiv.perm.{u+1} n)
                       (_x :
                         @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                           (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                           τ
                           (@finset.univ.{u} (equiv.perm.{u+1} n)
                              (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                                 _inst_1))),
                         @has_mul.mul.{u} (equiv.perm.{u+1} n)
                           (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                              (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                                 (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                           σ
                           τ)
                        a
                        ha))))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (i : n),
                  @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
                    (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                       (@mul_zero_class.to_has_zero.{v} R
                          (@semiring.to_mul_zero_class.{v} R
                             (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                       (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                       ((λ (τ : equiv.perm.{u+1} n)
                         (_x :
                           @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                             (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                             τ
                             (@finset.univ.{u} (equiv.perm.{u+1} n)
                                (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b)
                                   _inst_1
                                   _inst_1))),
                           @has_mul.mul.{u} (equiv.perm.{u+1} n)
                             (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                                (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                                   (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                             σ
                             τ)
                          a
                          ha)
                       i)
                    i))))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ ∀ (a₁ a₂ : equiv.perm.{u+1} n)
  (ha₁ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₁
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)))
  (ha₂ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₂
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
    @eq.{u+1} (equiv.perm.{u+1} n)
      ((λ (τ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            τ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
          @has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            σ
            τ)
         a₁
         ha₁)
      ((λ (τ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            τ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
          @has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            σ
            τ)
         a₂
         ha₂) →
    @eq.{u+1} (equiv.perm.{u+1} n) a₁ a₂

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ ∀ (b : equiv.perm.{u+1} n),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      b
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)) →
    @Exists.{u+1} (equiv.perm.{u+1} n)
      (λ (a : equiv.perm.{u+1} n),
         @Exists.{0}
           (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
              (@finset.has_mem.{u} (equiv.perm.{u+1} n))
              a
              (@finset.univ.{u} (equiv.perm.{u+1} n)
                 (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)))
           (λ
            (ha :
              @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                a
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
              @eq.{u+1} (equiv.perm.{u+1} n) b
                ((λ (τ : equiv.perm.{u+1} n)
                  (_x :
                    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                      (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                      τ
                      (@finset.univ.{u} (equiv.perm.{u+1} n)
                         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                            _inst_1))),
                    @has_mul.mul.{u} (equiv.perm.{u+1} n)
                      (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                         (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                            (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                      σ
                      τ)
                   a
                   ha)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132    { intros τ _, apply mem_univ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='finset.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : fintype.{u} α] (x : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x (@finset.univ.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ ∀ (a : equiv.perm.{u+1} n)
  (ha :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      ((λ (τ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            τ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
          @has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            σ
            τ)
         a
         ha)
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ ∀ (a : equiv.perm.{u+1} n)
  (ha :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
    @eq.{v+1} R
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} int R
            (@coe_to_lift.{1 v+1} int R
               (@coe_base.{1 v+1} int R
                  (@int.cast_coe.{v} R
                     (@add_group.to_has_neg.{v} R
                        (@add_comm_group.to_add_group.{v} R
                           (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                     (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
            (@coe.{1 1} (@units.{0} int int.monoid) int
               (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                  (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
               (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 a)))
         (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
            (@finset.univ.{u} n _inst_1)
            (λ (i : n),
               @pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
                 (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                 (@mul_zero_class.to_has_zero.{v} R
                    (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                 (@equiv.to_pequiv.{u u} n n σ)
                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) a i)
                 i)))
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} (@units.{0} int int.monoid) R
            (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
               (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
            (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
         (@has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
                     ((λ (τ : equiv.perm.{u+1} n)
                       (_x :
                         @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                           (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                           τ
                           (@finset.univ.{u} (equiv.perm.{u+1} n)
                              (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                                 _inst_1))),
                         @has_mul.mul.{u} (equiv.perm.{u+1} n)
                           (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                              (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                                 (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                           σ
                           τ)
                        a
                        ha))))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (i : n),
                  @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
                    (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                       (@mul_zero_class.to_has_zero.{v} R
                          (@semiring.to_mul_zero_class.{v} R
                             (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                       (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                       ((λ (τ : equiv.perm.{u+1} n)
                         (_x :
                           @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                             (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                             τ
                             (@finset.univ.{u} (equiv.perm.{u+1} n)
                                (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b)
                                   _inst_1
                                   _inst_1))),
                           @has_mul.mul.{u} (equiv.perm.{u+1} n)
                             (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                                (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                                   (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                             σ
                             τ)
                          a
                          ha)
                       i)
                    i))))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ ∀ (a₁ a₂ : equiv.perm.{u+1} n)
  (ha₁ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₁
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)))
  (ha₂ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₂
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
    @eq.{u+1} (equiv.perm.{u+1} n)
      ((λ (τ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            τ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
          @has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            σ
            τ)
         a₁
         ha₁)
      ((λ (τ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            τ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
          @has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            σ
            τ)
         a₂
         ha₂) →
    @eq.{u+1} (equiv.perm.{u+1} n) a₁ a₂

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ ∀ (b : equiv.perm.{u+1} n),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      b
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)) →
    @Exists.{u+1} (equiv.perm.{u+1} n)
      (λ (a : equiv.perm.{u+1} n),
         @Exists.{0}
           (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
              (@finset.has_mem.{u} (equiv.perm.{u+1} n))
              a
              (@finset.univ.{u} (equiv.perm.{u+1} n)
                 (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)))
           (λ
            (ha :
              @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                a
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
              @eq.{u+1} (equiv.perm.{u+1} n) b
                ((λ (τ : equiv.perm.{u+1} n)
                  (_x :
                    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                      (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                      τ
                      (@finset.univ.{u} (equiv.perm.{u+1} n)
                         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                            _inst_1))),
                    @has_mul.mul.{u} (equiv.perm.{u+1} n)
                      (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                         (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                            (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                      σ
                      τ)
                   a
                   ha)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ ∀ (a : equiv.perm.{u+1} n)
  (ha :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      ((λ (τ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            τ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
          @has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            σ
            τ)
         a
         ha)
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
⊢ @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    ((λ (τ : equiv.perm.{u+1} n)
      (_x :
        @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
          (@finset.has_mem.{u} (equiv.perm.{u+1} n))
          τ
          (@finset.univ.{u} (equiv.perm.{u+1} n)
             (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
        @has_mul.mul.{u} (equiv.perm.{u+1} n)
          (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
             (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          σ
          τ)
       τ
       ha)
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ ∀ (a : equiv.perm.{u+1} n)
  (ha :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
    @eq.{v+1} R
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} int R
            (@coe_to_lift.{1 v+1} int R
               (@coe_base.{1 v+1} int R
                  (@int.cast_coe.{v} R
                     (@add_group.to_has_neg.{v} R
                        (@add_comm_group.to_add_group.{v} R
                           (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                     (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
            (@coe.{1 1} (@units.{0} int int.monoid) int
               (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                  (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
               (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 a)))
         (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
            (@finset.univ.{u} n _inst_1)
            (λ (i : n),
               @pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
                 (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                 (@mul_zero_class.to_has_zero.{v} R
                    (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                 (@equiv.to_pequiv.{u u} n n σ)
                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) a i)
                 i)))
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} (@units.{0} int int.monoid) R
            (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
               (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
            (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
         (@has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
                     ((λ (τ : equiv.perm.{u+1} n)
                       (_x :
                         @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                           (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                           τ
                           (@finset.univ.{u} (equiv.perm.{u+1} n)
                              (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                                 _inst_1))),
                         @has_mul.mul.{u} (equiv.perm.{u+1} n)
                           (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                              (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                                 (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                           σ
                           τ)
                        a
                        ha))))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (i : n),
                  @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
                    (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                       (@mul_zero_class.to_has_zero.{v} R
                          (@semiring.to_mul_zero_class.{v} R
                             (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                       (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                       ((λ (τ : equiv.perm.{u+1} n)
                         (_x :
                           @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                             (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                             τ
                             (@finset.univ.{u} (equiv.perm.{u+1} n)
                                (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b)
                                   _inst_1
                                   _inst_1))),
                           @has_mul.mul.{u} (equiv.perm.{u+1} n)
                             (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                                (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                                   (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                             σ
                             τ)
                          a
                          ha)
                       i)
                    i))))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ ∀ (a₁ a₂ : equiv.perm.{u+1} n)
  (ha₁ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₁
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)))
  (ha₂ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₂
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
    @eq.{u+1} (equiv.perm.{u+1} n)
      ((λ (τ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            τ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
          @has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            σ
            τ)
         a₁
         ha₁)
      ((λ (τ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            τ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
          @has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            σ
            τ)
         a₂
         ha₂) →
    @eq.{u+1} (equiv.perm.{u+1} n) a₁ a₂

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ ∀ (b : equiv.perm.{u+1} n),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      b
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)) →
    @Exists.{u+1} (equiv.perm.{u+1} n)
      (λ (a : equiv.perm.{u+1} n),
         @Exists.{0}
           (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
              (@finset.has_mem.{u} (equiv.perm.{u+1} n))
              a
              (@finset.univ.{u} (equiv.perm.{u+1} n)
                 (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)))
           (λ
            (ha :
              @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                a
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
              @eq.{u+1} (equiv.perm.{u+1} n) b
                ((λ (τ : equiv.perm.{u+1} n)
                  (_x :
                    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                      (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                      τ
                      (@finset.univ.{u} (equiv.perm.{u+1} n)
                         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                            _inst_1))),
                    @has_mul.mul.{u} (equiv.perm.{u+1} n)
                      (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                         (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                            (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                      σ
                      τ)
                   a
                   ha)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133    { intros τ _,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ ∀ (a : equiv.perm.{u+1} n)
  (ha :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
    @eq.{v+1} R
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} int R
            (@coe_to_lift.{1 v+1} int R
               (@coe_base.{1 v+1} int R
                  (@int.cast_coe.{v} R
                     (@add_group.to_has_neg.{v} R
                        (@add_comm_group.to_add_group.{v} R
                           (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                     (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
            (@coe.{1 1} (@units.{0} int int.monoid) int
               (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                  (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
               (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 a)))
         (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
            (@finset.univ.{u} n _inst_1)
            (λ (i : n),
               @pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
                 (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                 (@mul_zero_class.to_has_zero.{v} R
                    (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                 (@equiv.to_pequiv.{u u} n n σ)
                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) a i)
                 i)))
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} (@units.{0} int int.monoid) R
            (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
               (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
            (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
         (@has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
                     ((λ (τ : equiv.perm.{u+1} n)
                       (_x :
                         @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                           (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                           τ
                           (@finset.univ.{u} (equiv.perm.{u+1} n)
                              (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                                 _inst_1))),
                         @has_mul.mul.{u} (equiv.perm.{u+1} n)
                           (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                              (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                                 (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                           σ
                           τ)
                        a
                        ha))))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (i : n),
                  @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
                    (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                       (@mul_zero_class.to_has_zero.{v} R
                          (@semiring.to_mul_zero_class.{v} R
                             (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                       (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                       ((λ (τ : equiv.perm.{u+1} n)
                         (_x :
                           @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                             (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                             τ
                             (@finset.univ.{u} (equiv.perm.{u+1} n)
                                (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b)
                                   _inst_1
                                   _inst_1))),
                           @has_mul.mul.{u} (equiv.perm.{u+1} n)
                             (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                                (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                                   (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                             σ
                             τ)
                          a
                          ha)
                       i)
                    i))))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ ∀ (a₁ a₂ : equiv.perm.{u+1} n)
  (ha₁ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₁
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)))
  (ha₂ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₂
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
    @eq.{u+1} (equiv.perm.{u+1} n)
      ((λ (τ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            τ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
          @has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            σ
            τ)
         a₁
         ha₁)
      ((λ (τ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            τ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
          @has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            σ
            τ)
         a₂
         ha₂) →
    @eq.{u+1} (equiv.perm.{u+1} n) a₁ a₂

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ ∀ (b : equiv.perm.{u+1} n),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      b
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)) →
    @Exists.{u+1} (equiv.perm.{u+1} n)
      (λ (a : equiv.perm.{u+1} n),
         @Exists.{0}
           (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
              (@finset.has_mem.{u} (equiv.perm.{u+1} n))
              a
              (@finset.univ.{u} (equiv.perm.{u+1} n)
                 (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)))
           (λ
            (ha :
              @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                a
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
              @eq.{u+1} (equiv.perm.{u+1} n) b
                ((λ (τ : equiv.perm.{u+1} n)
                  (_x :
                    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                      (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                      τ
                      (@finset.univ.{u} (equiv.perm.{u+1} n)
                         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                            _inst_1))),
                    @has_mul.mul.{u} (equiv.perm.{u+1} n)
                      (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                         (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                            (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                      σ
                      τ)
                   a
                   ha)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ ∀ (a : equiv.perm.{u+1} n)
  (ha :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
    @eq.{v+1} R
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} int R
            (@coe_to_lift.{1 v+1} int R
               (@coe_base.{1 v+1} int R
                  (@int.cast_coe.{v} R
                     (@add_group.to_has_neg.{v} R
                        (@add_comm_group.to_add_group.{v} R
                           (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                     (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
            (@coe.{1 1} (@units.{0} int int.monoid) int
               (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                  (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
               (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 a)))
         (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
            (@finset.univ.{u} n _inst_1)
            (λ (i : n),
               @pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
                 (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                 (@mul_zero_class.to_has_zero.{v} R
                    (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                 (@equiv.to_pequiv.{u u} n n σ)
                 (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) a i)
                 i)))
      (@has_mul.mul.{v} R
         (@mul_zero_class.to_has_mul.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe.{1 v+1} (@units.{0} int int.monoid) R
            (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
               (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
            (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
         (@has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
                     ((λ (τ : equiv.perm.{u+1} n)
                       (_x :
                         @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                           (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                           τ
                           (@finset.univ.{u} (equiv.perm.{u+1} n)
                              (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                                 _inst_1))),
                         @has_mul.mul.{u} (equiv.perm.{u+1} n)
                           (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                              (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                                 (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                           σ
                           τ)
                        a
                        ha))))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (i : n),
                  @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
                    (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                       (@mul_zero_class.to_has_zero.{v} R
                          (@semiring.to_mul_zero_class.{v} R
                             (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                       (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                    (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                       ((λ (τ : equiv.perm.{u+1} n)
                         (_x :
                           @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                             (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                             τ
                             (@finset.univ.{u} (equiv.perm.{u+1} n)
                                (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b)
                                   _inst_1
                                   _inst_1))),
                           @has_mul.mul.{u} (equiv.perm.{u+1} n)
                             (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                                (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                                   (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                             σ
                             τ)
                          a
                          ha)
                       i)
                    i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ)))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
               (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (@equiv.to_pequiv.{u u} n n σ)
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ i)
               i)))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} (@units.{0} int int.monoid) R
          (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
             (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
       (@has_mul.mul.{v} R
          (@mul_zero_class.to_has_mul.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
                   ((λ (τ : equiv.perm.{u+1} n)
                     (_x :
                       @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                         (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                         τ
                         (@finset.univ.{u} (equiv.perm.{u+1} n)
                            (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                               _inst_1))),
                       @has_mul.mul.{u} (equiv.perm.{u+1} n)
                         (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                            (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                               (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                         σ
                         τ)
                      τ
                      ha))))
          (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
             (@finset.univ.{u} n _inst_1)
             (λ (i : n),
                @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
                  (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                  (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                     ((λ (τ : equiv.perm.{u+1} n)
                       (_x :
                         @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                           (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                           τ
                           (@finset.univ.{u} (equiv.perm.{u+1} n)
                              (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                                 _inst_1))),
                         @has_mul.mul.{u} (equiv.perm.{u+1} n)
                           (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                              (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                                 (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                           σ
                           τ)
                        τ
                        ha)
                     i)
                  i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134      conv_lhs { rw [←one_mul (sign τ), ←int.units_pow_two (sign σ)] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='one_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.perm.sign'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='int.units_pow_two'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.perm.sign'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/converter/interactive.lean&#x27;, &#x27;line&#x27;: 123, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/perm/sign.lean&#x27;, &#x27;line&#x27;: 464, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 690, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/perm/sign.lean&#x27;, &#x27;line&#x27;: 464, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/converter/interactive.lean&#x27;, &#x27;line&#x27;: 123, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : monoid.{0} α] (a : α), @eq.{1} α (@has_mul.mul.{0} α (@semigroup.to_has_mul.{0} α (@monoid.to_semigroup.{0} α _inst_1)) (@has_one.one.{0} α (@monoid.to_has_one.{0} α _inst_1)) a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : fintype.{u} α], equiv.perm.{u+1} α → @units.{0} int int.monoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (u : @units.{0} int int.monoid), @eq.{1} (@units.{0} int int.monoid) (@has_pow.pow.{0 0} (@units.{0} int int.monoid) nat (@monoid.has_pow.{0} (@units.{0} int int.monoid) (@group.to_monoid.{0} (@units.{0} int int.monoid) (@units.group.{0} int int.monoid))) u (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))) (@has_one.one.{0} (@units.{0} int int.monoid) (@units.has_one.{0} int int.monoid))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : fintype.{u} α], equiv.perm.{u+1} α → @units.{0} int int.monoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='conv_lhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv_lhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ)))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
               (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (@equiv.to_pequiv.{u u} n n σ)
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ i)
               i)))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} (@units.{0} int int.monoid) R
          (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
             (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
       (@has_mul.mul.{v} R
          (@mul_zero_class.to_has_mul.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
                   ((λ (τ : equiv.perm.{u+1} n)
                     (_x :
                       @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                         (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                         τ
                         (@finset.univ.{u} (equiv.perm.{u+1} n)
                            (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                               _inst_1))),
                       @has_mul.mul.{u} (equiv.perm.{u+1} n)
                         (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                            (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                               (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                         σ
                         τ)
                      τ
                      ha))))
          (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
             (@finset.univ.{u} n _inst_1)
             (λ (i : n),
                @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
                  (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                  (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                     ((λ (τ : equiv.perm.{u+1} n)
                       (_x :
                         @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                           (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                           τ
                           (@finset.univ.{u} (equiv.perm.{u+1} n)
                              (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                                 _inst_1))),
                         @has_mul.mul.{u} (equiv.perm.{u+1} n)
                           (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                              (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                                 (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                           σ
                           τ)
                        τ
                        ha)
                     i)
                  i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
| @has_mul.mul.{v} R
    (@mul_zero_class.to_has_mul.{v} R
       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
    (@coe.{1 v+1} int R
       (@coe_to_lift.{1 v+1} int R
          (@coe_base.{1 v+1} int R
             (@int.cast_coe.{v} R
                (@add_group.to_has_neg.{v} R
                   (@add_comm_group.to_add_group.{v} R
                      (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@coe.{1 1} (@units.{0} int int.monoid) int
          (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
             (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ)))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (i : n),
          @pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
            (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
            (@mul_zero_class.to_has_zero.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@equiv.to_pequiv.{u u} n n σ)
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ i)
            i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
| @has_mul.mul.{v} R
    (@mul_zero_class.to_has_mul.{v} R
       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
    (@coe.{1 v+1} int R
       (@coe_to_lift.{1 v+1} int R
          (@coe_base.{1 v+1} int R
             (@int.cast_coe.{v} R
                (@add_group.to_has_neg.{v} R
                   (@add_comm_group.to_add_group.{v} R
                      (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@coe.{1 1} (@units.{0} int int.monoid) int
          (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
             (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
          (@has_mul.mul.{0} (@units.{0} int int.monoid)
             (@semigroup.to_has_mul.{0} (@units.{0} int int.monoid)
                (@monoid.to_semigroup.{0} (@units.{0} int int.monoid)
                   (@group.to_monoid.{0} (@units.{0} int int.monoid) (@units.group.{0} int int.monoid))))
             (@has_one.one.{0} (@units.{0} int int.monoid)
                (@monoid.to_has_one.{0} (@units.{0} int int.monoid)
                   (@group.to_monoid.{0} (@units.{0} int int.monoid) (@units.group.{0} int int.monoid))))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ))))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (i : n),
          @pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
            (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
            (@mul_zero_class.to_has_zero.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@equiv.to_pequiv.{u u} n n σ)
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ i)
            i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
| @has_mul.mul.{v} R
    (@mul_zero_class.to_has_mul.{v} R
       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
    (@coe.{1 v+1} int R
       (@coe_to_lift.{1 v+1} int R
          (@coe_base.{1 v+1} int R
             (@int.cast_coe.{v} R
                (@add_group.to_has_neg.{v} R
                   (@add_comm_group.to_add_group.{v} R
                      (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@coe.{1 1} (@units.{0} int int.monoid) int
          (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
             (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ)))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (i : n),
          @pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
            (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
            (@mul_zero_class.to_has_zero.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@equiv.to_pequiv.{u u} n n σ)
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ i)
            i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
| @has_mul.mul.{v} R
    (@mul_zero_class.to_has_mul.{v} R
       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
    (@coe.{1 v+1} int R
       (@coe_to_lift.{1 v+1} int R
          (@coe_base.{1 v+1} int R
             (@int.cast_coe.{v} R
                (@add_group.to_has_neg.{v} R
                   (@add_comm_group.to_add_group.{v} R
                      (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@coe.{1 1} (@units.{0} int int.monoid) int
          (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
             (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
          (@has_mul.mul.{0} (@units.{0} int int.monoid)
             (@semigroup.to_has_mul.{0} (@units.{0} int int.monoid)
                (@monoid.to_semigroup.{0} (@units.{0} int int.monoid)
                   (@group.to_monoid.{0} (@units.{0} int int.monoid) (@units.group.{0} int int.monoid))))
             (@has_pow.pow.{0 0} (@units.{0} int int.monoid) nat
                (@monoid.has_pow.{0} (@units.{0} int int.monoid)
                   (@group.to_monoid.{0} (@units.{0} int int.monoid) (@units.group.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)
                (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ))))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (i : n),
          @pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
            (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
            (@mul_zero_class.to_has_zero.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@equiv.to_pequiv.{u u} n n σ)
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ i)
            i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@has_mul.mul.{0} (@units.{0} int int.monoid)
                (@semigroup.to_has_mul.{0} (@units.{0} int int.monoid)
                   (@monoid.to_semigroup.{0} (@units.{0} int int.monoid)
                      (@group.to_monoid.{0} (@units.{0} int int.monoid) (@units.group.{0} int int.monoid))))
                (@has_pow.pow.{0 0} (@units.{0} int int.monoid) nat
                   (@monoid.has_pow.{0} (@units.{0} int int.monoid)
                      (@group.to_monoid.{0} (@units.{0} int int.monoid) (@units.group.{0} int int.monoid)))
                   (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)
                   (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
               (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (@equiv.to_pequiv.{u u} n n σ)
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ i)
               i)))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} (@units.{0} int int.monoid) R
          (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
             (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
       (@has_mul.mul.{v} R
          (@mul_zero_class.to_has_mul.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
                   ((λ (τ : equiv.perm.{u+1} n)
                     (_x :
                       @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                         (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                         τ
                         (@finset.univ.{u} (equiv.perm.{u+1} n)
                            (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                               _inst_1))),
                       @has_mul.mul.{u} (equiv.perm.{u+1} n)
                         (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                            (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                               (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                         σ
                         τ)
                      τ
                      ha))))
          (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
             (@finset.univ.{u} n _inst_1)
             (λ (i : n),
                @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
                  (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                  (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                     ((λ (τ : equiv.perm.{u+1} n)
                       (_x :
                         @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                           (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                           τ
                           (@finset.univ.{u} (equiv.perm.{u+1} n)
                              (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                                 _inst_1))),
                         @has_mul.mul.{u} (equiv.perm.{u+1} n)
                           (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                              (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                                 (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                           σ
                           τ)
                        τ
                        ha)
                     i)
                  i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135      conv_rhs { rw [←mul_assoc, coe_coe, sign_mul, units.coe_mul, int.cast_mul, ←mul_assoc] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='mul_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='coe_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.perm.sign_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='units.coe_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='int.cast_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='mul_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/converter/interactive.lean&#x27;, &#x27;line&#x27;: 128, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/perm/sign.lean&#x27;, &#x27;line&#x27;: 473, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/units.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/int/basic.lean&#x27;, &#x27;line&#x27;: 1128, &#x27;column&#x27;: 27}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/converter/interactive.lean&#x27;, &#x27;line&#x27;: 128, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : semigroup.{v} α] (a b c : α), @eq.{v+1} α (@has_mul.mul.{v} α (@semigroup.to_has_mul.{v} α _inst_1) (@has_mul.mul.{v} α (@semigroup.to_has_mul.{v} α _inst_1) a b) c) (@has_mul.mul.{v} α (@semigroup.to_has_mul.{v} α _inst_1) a (@has_mul.mul.{v} α (@semigroup.to_has_mul.{v} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type} {γ : Type v} [_inst_1 : has_coe.{1 1} α β] [_inst_2 : has_coe_t.{1 v+1} β γ] (a : α), @eq.{v+1} γ (@coe.{1 v+1} α γ (@coe_to_lift.{1 v+1} α γ (@coe_trans.{1 1 v+1} α β γ _inst_1 _inst_2)) a) (@coe.{1 v+1} β γ (@coe_to_lift.{1 v+1} β γ _inst_2) (@coe.{1 1} α β (@coe_to_lift.{1 1} α β (@coe_base.{1 1} α β _inst_1)) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : fintype.{u} α] (f g : equiv.perm.{u+1} α), @eq.{1} (@units.{0} int int.monoid) (@equiv.perm.sign.{u} α (λ (a b : α), _inst_1 a b) _inst_2 (@has_mul.mul.{u} (equiv.perm.{u+1} α) (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} α) (@monoid.to_semigroup.{u} (equiv.perm.{u+1} α) (@group.to_monoid.{u} (equiv.perm.{u+1} α) (@equiv.perm.perm_group.{u} α)))) f g)) (@has_mul.mul.{0} (@units.{0} int int.monoid) (@units.has_mul.{0} int int.monoid) (@equiv.perm.sign.{u} α (λ (a b : α), _inst_1 a b) _inst_2 f) (@equiv.perm.sign.{u} α (λ (a b : α), _inst_1 a b) _inst_2 g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : monoid.{0} α] (a b : @units.{0} α _inst_1), @eq.{1} α (@coe.{1 1} (@units.{0} α _inst_1) α (@coe_to_lift.{1 1} (@units.{0} α _inst_1) α (@coe_base.{1 1} (@units.{0} α _inst_1) α (@units.has_coe.{0} α _inst_1))) (@has_mul.mul.{0} (@units.{0} α _inst_1) (@units.has_mul.{0} α _inst_1) a b)) (@has_mul.mul.{0} α (@semigroup.to_has_mul.{0} α (@monoid.to_semigroup.{0} α _inst_1)) (@coe.{1 1} (@units.{0} α _inst_1) α (@coe_to_lift.{1 1} (@units.{0} α _inst_1) α (@coe_base.{1 1} (@units.{0} α _inst_1) α (@units.has_coe.{0} α _inst_1))) a) (@coe.{1 1} (@units.{0} α _inst_1) α (@coe_to_lift.{1 1} (@units.{0} α _inst_1) α (@coe_base.{1 1} (@units.{0} α _inst_1) α (@units.has_coe.{0} α _inst_1))) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : ring.{v} α] (m n : int), @eq.{v+1} α (@coe.{1 v+1} int α (@coe_to_lift.{1 v+1} int α (@coe_base.{1 v+1} int α (@int.cast_coe.{v} α (@add_group.to_has_neg.{v} α (@add_comm_group.to_add_group.{v} α (@ring.to_add_comm_group.{v} α _inst_1))) (@mul_zero_class.to_has_zero.{v} α (@semiring.to_mul_zero_class.{v} α (@ring.to_semiring.{v} α _inst_1))) (@monoid.to_has_one.{v} α (@ring.to_monoid.{v} α _inst_1)) (@distrib.to_has_add.{v} α (@ring.to_distrib.{v} α _inst_1))))) (@has_mul.mul.{0} int int.has_mul m n)) (@has_mul.mul.{v} α (@mul_zero_class.to_has_mul.{v} α (@semiring.to_mul_zero_class.{v} α (@ring.to_semiring.{v} α _inst_1))) (@coe.{1 v+1} int α (@coe_to_lift.{1 v+1} int α (@coe_base.{1 v+1} int α (@int.cast_coe.{v} α (@add_group.to_has_neg.{v} α (@add_comm_group.to_add_group.{v} α (@ring.to_add_comm_group.{v} α _inst_1))) (@mul_zero_class.to_has_zero.{v} α (@semiring.to_mul_zero_class.{v} α (@ring.to_semiring.{v} α _inst_1))) (@monoid.to_has_one.{v} α (@ring.to_monoid.{v} α _inst_1)) (@distrib.to_has_add.{v} α (@ring.to_distrib.{v} α _inst_1))))) m) (@coe.{1 v+1} int α (@coe_to_lift.{1 v+1} int α (@coe_base.{1 v+1} int α (@int.cast_coe.{v} α (@add_group.to_has_neg.{v} α (@add_comm_group.to_add_group.{v} α (@ring.to_add_comm_group.{v} α _inst_1))) (@mul_zero_class.to_has_zero.{v} α (@semiring.to_mul_zero_class.{v} α (@ring.to_semiring.{v} α _inst_1))) (@monoid.to_has_one.{v} α (@ring.to_monoid.{v} α _inst_1)) (@distrib.to_has_add.{v} α (@ring.to_distrib.{v} α _inst_1))))) n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : semigroup.{v} α] (a b c : α), @eq.{v+1} α (@has_mul.mul.{v} α (@semigroup.to_has_mul.{v} α _inst_1) (@has_mul.mul.{v} α (@semigroup.to_has_mul.{v} α _inst_1) a b) c) (@has_mul.mul.{v} α (@semigroup.to_has_mul.{v} α _inst_1) a (@has_mul.mul.{v} α (@semigroup.to_has_mul.{v} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='Add an instance to &quot;undo&quot; coercion transitivity into a chain of coercions, because
  most simp lemmas are stated with respect to simple coercions and will not match when
  part of a chain.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='conv_rhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv_rhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@has_mul.mul.{0} (@units.{0} int int.monoid)
                (@semigroup.to_has_mul.{0} (@units.{0} int int.monoid)
                   (@monoid.to_semigroup.{0} (@units.{0} int int.monoid)
                      (@group.to_monoid.{0} (@units.{0} int int.monoid) (@units.group.{0} int int.monoid))))
                (@has_pow.pow.{0 0} (@units.{0} int int.monoid) nat
                   (@monoid.has_pow.{0} (@units.{0} int int.monoid)
                      (@group.to_monoid.{0} (@units.{0} int int.monoid) (@units.group.{0} int int.monoid)))
                   (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)
                   (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
               (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (@equiv.to_pequiv.{u u} n n σ)
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ i)
               i)))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} (@units.{0} int int.monoid) R
          (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
             (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
       (@has_mul.mul.{v} R
          (@mul_zero_class.to_has_mul.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
                   ((λ (τ : equiv.perm.{u+1} n)
                     (_x :
                       @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                         (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                         τ
                         (@finset.univ.{u} (equiv.perm.{u+1} n)
                            (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                               _inst_1))),
                       @has_mul.mul.{u} (equiv.perm.{u+1} n)
                         (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                            (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                               (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                         σ
                         τ)
                      τ
                      ha))))
          (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
             (@finset.univ.{u} n _inst_1)
             (λ (i : n),
                @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
                  (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                     (@mul_zero_class.to_has_zero.{v} R
                        (@semiring.to_mul_zero_class.{v} R
                           (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                     (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                  (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                     ((λ (τ : equiv.perm.{u+1} n)
                       (_x :
                         @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                           (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                           τ
                           (@finset.univ.{u} (equiv.perm.{u+1} n)
                              (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                                 _inst_1))),
                         @has_mul.mul.{u} (equiv.perm.{u+1} n)
                           (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                              (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                                 (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                           σ
                           τ)
                        τ
                        ha)
                     i)
                  i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
| @has_mul.mul.{v} R
    (@mul_zero_class.to_has_mul.{v} R
       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
    (@coe.{1 v+1} (@units.{0} int int.monoid) R
       (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
          (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
       (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
                ((λ (τ : equiv.perm.{u+1} n)
                  (_x :
                    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                      (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                      τ
                      (@finset.univ.{u} (equiv.perm.{u+1} n)
                         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                            _inst_1))),
                    @has_mul.mul.{u} (equiv.perm.{u+1} n)
                      (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                         (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                            (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                      σ
                      τ)
                   τ
                   ha))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
               (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                  (@mul_zero_class.to_has_zero.{v} R
                     (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                  (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  ((λ (τ : equiv.perm.{u+1} n)
                    (_x :
                      @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                        (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                        τ
                        (@finset.univ.{u} (equiv.perm.{u+1} n)
                           (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                              _inst_1))),
                      @has_mul.mul.{u} (equiv.perm.{u+1} n)
                        (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                           (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                              (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                        σ
                        τ)
                     τ
                     ha)
                  i)
               i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
| @has_mul.mul.{v} R
    (@semigroup.to_has_mul.{v} R
       (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
    (@has_mul.mul.{v} R
       (@semigroup.to_has_mul.{v} R
          (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} (@units.{0} int int.monoid) R
          (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
             (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
                ((λ (τ : equiv.perm.{u+1} n)
                  (_x :
                    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                      (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                      τ
                      (@finset.univ.{u} (equiv.perm.{u+1} n)
                         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                            _inst_1))),
                    @has_mul.mul.{u} (equiv.perm.{u+1} n)
                      (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                         (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                            (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                      σ
                      τ)
                   τ
                   ha)))))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (i : n),
          @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
            (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
               ((λ (τ : equiv.perm.{u+1} n)
                 (_x :
                   @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                     (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                     τ
                     (@finset.univ.{u} (equiv.perm.{u+1} n)
                        (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                           _inst_1))),
                   @has_mul.mul.{u} (equiv.perm.{u+1} n)
                     (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                        (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                           (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                     σ
                     τ)
                  τ
                  ha)
               i)
            i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
| @has_mul.mul.{v} R
    (@semigroup.to_has_mul.{v} R
       (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
    (@has_mul.mul.{v} R
       (@semigroup.to_has_mul.{v} R
          (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
                ((λ (τ : equiv.perm.{u+1} n)
                  (_x :
                    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                      (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                      τ
                      (@finset.univ.{u} (equiv.perm.{u+1} n)
                         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                            _inst_1))),
                    @has_mul.mul.{u} (equiv.perm.{u+1} n)
                      (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                         (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                            (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                      σ
                      τ)
                   τ
                   ha)))))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (i : n),
          @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
            (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
               ((λ (τ : equiv.perm.{u+1} n)
                 (_x :
                   @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                     (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                     τ
                     (@finset.univ.{u} (equiv.perm.{u+1} n)
                        (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                           _inst_1))),
                   @has_mul.mul.{u} (equiv.perm.{u+1} n)
                     (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                        (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                           (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                     σ
                     τ)
                  τ
                  ha)
               i)
            i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
| @has_mul.mul.{v} R
    (@semigroup.to_has_mul.{v} R
       (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
    (@has_mul.mul.{v} R
       (@semigroup.to_has_mul.{v} R
          (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@has_mul.mul.{0} (@units.{0} int int.monoid) (@units.has_mul.{0} int int.monoid)
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ)))))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (i : n),
          @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
            (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
               ((λ (τ : equiv.perm.{u+1} n)
                 (_x :
                   @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                     (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                     τ
                     (@finset.univ.{u} (equiv.perm.{u+1} n)
                        (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                           _inst_1))),
                   @has_mul.mul.{u} (equiv.perm.{u+1} n)
                     (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                        (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                           (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                     σ
                     τ)
                  τ
                  ha)
               i)
            i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
| @has_mul.mul.{v} R
    (@semigroup.to_has_mul.{v} R
       (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
    (@has_mul.mul.{v} R
       (@semigroup.to_has_mul.{v} R
          (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@has_mul.mul.{0} int (@semigroup.to_has_mul.{0} int (@monoid.to_semigroup.{0} int int.monoid))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ)))))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (i : n),
          @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
            (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
               ((λ (τ : equiv.perm.{u+1} n)
                 (_x :
                   @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                     (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                     τ
                     (@finset.univ.{u} (equiv.perm.{u+1} n)
                        (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                           _inst_1))),
                   @has_mul.mul.{u} (equiv.perm.{u+1} n)
                     (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                        (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                           (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                     σ
                     τ)
                  τ
                  ha)
               i)
            i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
| @has_mul.mul.{v} R
    (@semigroup.to_has_mul.{v} R
       (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
    (@has_mul.mul.{v} R
       (@semigroup.to_has_mul.{v} R
          (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
       (@has_mul.mul.{v} R
          (@mul_zero_class.to_has_mul.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ)))))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (i : n),
          @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
            (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
               ((λ (τ : equiv.perm.{u+1} n)
                 (_x :
                   @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                     (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                     τ
                     (@finset.univ.{u} (equiv.perm.{u+1} n)
                        (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                           _inst_1))),
                   @has_mul.mul.{u} (equiv.perm.{u+1} n)
                     (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                        (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                           (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                     σ
                     τ)
                  τ
                  ha)
               i)
            i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
| @has_mul.mul.{v} R
    (@mul_zero_class.to_has_mul.{v} R
       (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
    (@coe.{1 v+1} (@units.{0} int int.monoid) R
       (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
          (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
       (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1
                ((λ (τ : equiv.perm.{u+1} n)
                  (_x :
                    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                      (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                      τ
                      (@finset.univ.{u} (equiv.perm.{u+1} n)
                         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                            _inst_1))),
                    @has_mul.mul.{u} (equiv.perm.{u+1} n)
                      (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                         (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                            (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                      σ
                      τ)
                   τ
                   ha))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
               (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                  (@mul_zero_class.to_has_zero.{v} R
                     (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                  (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  ((λ (τ : equiv.perm.{u+1} n)
                    (_x :
                      @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                        (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                        τ
                        (@finset.univ.{u} (equiv.perm.{u+1} n)
                           (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                              _inst_1))),
                      @has_mul.mul.{u} (equiv.perm.{u+1} n)
                        (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                           (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                              (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                        σ
                        τ)
                     τ
                     ha)
                  i)
               i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
| @has_mul.mul.{v} R
    (@semigroup.to_has_mul.{v} R
       (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
    (@has_mul.mul.{v} R
       (@semigroup.to_has_mul.{v} R
          (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@has_mul.mul.{v} R
          (@semigroup.to_has_mul.{v} R
             (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ))))
    (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
       (@finset.univ.{u} n _inst_1)
       (λ (i : n),
          @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
            (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
               ((λ (τ : equiv.perm.{u+1} n)
                 (_x :
                   @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                     (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                     τ
                     (@finset.univ.{u} (equiv.perm.{u+1} n)
                        (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                           _inst_1))),
                   @has_mul.mul.{u} (equiv.perm.{u+1} n)
                     (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                        (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                           (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                     σ
                     τ)
                  τ
                  ha)
               i)
            i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@has_mul.mul.{0} (@units.{0} int int.monoid)
                (@semigroup.to_has_mul.{0} (@units.{0} int int.monoid)
                   (@monoid.to_semigroup.{0} (@units.{0} int int.monoid)
                      (@group.to_monoid.{0} (@units.{0} int int.monoid) (@units.group.{0} int int.monoid))))
                (@has_pow.pow.{0 0} (@units.{0} int int.monoid) nat
                   (@monoid.has_pow.{0} (@units.{0} int int.monoid)
                      (@group.to_monoid.{0} (@units.{0} int int.monoid) (@units.group.{0} int int.monoid)))
                   (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)
                   (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
               (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (@equiv.to_pequiv.{u u} n n σ)
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ i)
               i)))
    (@has_mul.mul.{v} R
       (@semigroup.to_has_mul.{v} R
          (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@has_mul.mul.{v} R
          (@semigroup.to_has_mul.{v} R
             (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@has_mul.mul.{v} R
             (@semigroup.to_has_mul.{v} R
                (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
             (@coe.{1 v+1} int R
                (@coe_to_lift.{1 v+1} int R
                   (@coe_base.{1 v+1} int R
                      (@int.cast_coe.{v} R
                         (@add_group.to_has_neg.{v} R
                            (@add_comm_group.to_add_group.{v} R
                               (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                         (@mul_zero_class.to_has_zero.{v} R
                            (@semiring.to_mul_zero_class.{v} R
                               (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                         (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                         (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
                (@coe.{1 1} (@units.{0} int int.monoid) int
                   (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                      (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                   (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
             (@coe.{1 v+1} int R
                (@coe_to_lift.{1 v+1} int R
                   (@coe_base.{1 v+1} int R
                      (@int.cast_coe.{v} R
                         (@add_group.to_has_neg.{v} R
                            (@add_comm_group.to_add_group.{v} R
                               (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                         (@mul_zero_class.to_has_zero.{v} R
                            (@semiring.to_mul_zero_class.{v} R
                               (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                         (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                         (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
                (@coe.{1 1} (@units.{0} int int.monoid) int
                   (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                      (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                   (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
               (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                  (@mul_zero_class.to_has_zero.{v} R
                     (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                  (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  ((λ (τ : equiv.perm.{u+1} n)
                    (_x :
                      @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                        (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                        τ
                        (@finset.univ.{u} (equiv.perm.{u+1} n)
                           (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                              _inst_1))),
                      @has_mul.mul.{u} (equiv.perm.{u+1} n)
                        (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                           (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                              (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                        σ
                        τ)
                     τ
                     ha)
                  i)
               i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136      congr,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1543, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@has_mul.mul.{0} (@units.{0} int int.monoid)
                (@semigroup.to_has_mul.{0} (@units.{0} int int.monoid)
                   (@monoid.to_semigroup.{0} (@units.{0} int int.monoid)
                      (@group.to_monoid.{0} (@units.{0} int int.monoid) (@units.group.{0} int int.monoid))))
                (@has_pow.pow.{0 0} (@units.{0} int int.monoid) nat
                   (@monoid.has_pow.{0} (@units.{0} int int.monoid)
                      (@group.to_monoid.{0} (@units.{0} int int.monoid) (@units.group.{0} int int.monoid)))
                   (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)
                   (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
               (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
               (@mul_zero_class.to_has_zero.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (@equiv.to_pequiv.{u u} n n σ)
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ i)
               i)))
    (@has_mul.mul.{v} R
       (@semigroup.to_has_mul.{v} R
          (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@has_mul.mul.{v} R
          (@semigroup.to_has_mul.{v} R
             (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@has_mul.mul.{v} R
             (@semigroup.to_has_mul.{v} R
                (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
             (@coe.{1 v+1} int R
                (@coe_to_lift.{1 v+1} int R
                   (@coe_base.{1 v+1} int R
                      (@int.cast_coe.{v} R
                         (@add_group.to_has_neg.{v} R
                            (@add_comm_group.to_add_group.{v} R
                               (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                         (@mul_zero_class.to_has_zero.{v} R
                            (@semiring.to_mul_zero_class.{v} R
                               (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                         (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                         (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
                (@coe.{1 1} (@units.{0} int int.monoid) int
                   (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                      (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                   (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
             (@coe.{1 v+1} int R
                (@coe_to_lift.{1 v+1} int R
                   (@coe_base.{1 v+1} int R
                      (@int.cast_coe.{v} R
                         (@add_group.to_has_neg.{v} R
                            (@add_comm_group.to_add_group.{v} R
                               (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                         (@mul_zero_class.to_has_zero.{v} R
                            (@semiring.to_mul_zero_class.{v} R
                               (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                         (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                         (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
                (@coe.{1 1} (@units.{0} int int.monoid) int
                   (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                      (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                   (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
               (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
                  (@mul_zero_class.to_has_zero.{v} R
                     (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                  (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  ((λ (τ : equiv.perm.{u+1} n)
                    (_x :
                      @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                        (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                        τ
                        (@finset.univ.{u} (equiv.perm.{u+1} n)
                           (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                              _inst_1))),
                      @has_mul.mul.{u} (equiv.perm.{u+1} n)
                        (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                           (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                              (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                        σ
                        τ)
                     τ
                     ha)
                  i)
               i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
⊢ @eq.{v+1} R
    (@coe.{1 v+1} int R
       (@coe_to_lift.{1 v+1} int R
          (@coe_base.{1 v+1} int R
             (@int.cast_coe.{v} R
                (@add_group.to_has_neg.{v} R
                   (@add_comm_group.to_add_group.{v} R
                      (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@coe.{1 1} (@units.{0} int int.monoid) int
          (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
             (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
          (@has_mul.mul.{0} (@units.{0} int int.monoid)
             (@semigroup.to_has_mul.{0} (@units.{0} int int.monoid)
                (@monoid.to_semigroup.{0} (@units.{0} int int.monoid)
                   (@group.to_monoid.{0} (@units.{0} int int.monoid) (@units.group.{0} int int.monoid))))
             (@has_pow.pow.{0 0} (@units.{0} int int.monoid) nat
                (@monoid.has_pow.{0} (@units.{0} int int.monoid)
                   (@group.to_monoid.{0} (@units.{0} int int.monoid) (@units.group.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)
                (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ))))
    (@has_mul.mul.{v} R
       (@semigroup.to_has_mul.{v} R
          (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@has_mul.mul.{v} R
          (@semigroup.to_has_mul.{v} R
             (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ))))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
⊢ @eq.{(max (u+1) (v+1))} (n → R)
    (λ (i : n),
       @pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
         (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
         (@mul_zero_class.to_has_zero.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@equiv.to_pequiv.{u u} n n σ)
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ i)
         i)
    (λ (i : n),
       @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
         (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
            (@mul_zero_class.to_has_zero.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            ((λ (τ : equiv.perm.{u+1} n)
              (_x :
                @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                  (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                  τ
                  (@finset.univ.{u} (equiv.perm.{u+1} n)
                     (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                        _inst_1))),
                @has_mul.mul.{u} (equiv.perm.{u+1} n)
                  (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  σ
                  τ)
               τ
               ha)
            i)
         i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137      { norm_num },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_num.lean&#x27;, &#x27;line&#x27;: 472, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' Normalize numerical expressions. Supports the operations
  `+` `-` `*` `/` `^` and `%` over numerical types such as
`ℕ`, `ℤ`, `ℚ`, `ℝ`, `ℂ` and some general algebraic types,
and can prove goals of the form `A = B`, `A ≠ B`, `A &lt; B` and `A ≤ B`,
where `A` and `B` are numerical expressions.
It also has a relatively simple primality prover.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='norm_num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
⊢ @eq.{v+1} R
    (@coe.{1 v+1} int R
       (@coe_to_lift.{1 v+1} int R
          (@coe_base.{1 v+1} int R
             (@int.cast_coe.{v} R
                (@add_group.to_has_neg.{v} R
                   (@add_comm_group.to_add_group.{v} R
                      (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@coe.{1 1} (@units.{0} int int.monoid) int
          (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
             (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
          (@has_mul.mul.{0} (@units.{0} int int.monoid)
             (@semigroup.to_has_mul.{0} (@units.{0} int int.monoid)
                (@monoid.to_semigroup.{0} (@units.{0} int int.monoid)
                   (@group.to_monoid.{0} (@units.{0} int int.monoid) (@units.group.{0} int int.monoid))))
             (@has_pow.pow.{0 0} (@units.{0} int int.monoid) nat
                (@monoid.has_pow.{0} (@units.{0} int int.monoid)
                   (@group.to_monoid.{0} (@units.{0} int int.monoid) (@units.group.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)
                (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ))))
    (@has_mul.mul.{v} R
       (@semigroup.to_has_mul.{v} R
          (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@has_mul.mul.{v} R
          (@semigroup.to_has_mul.{v} R
             (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ))))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
⊢ @eq.{(max (u+1) (v+1))} (n → R)
    (λ (i : n),
       @pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
         (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
         (@mul_zero_class.to_has_zero.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@equiv.to_pequiv.{u u} n n σ)
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ i)
         i)
    (λ (i : n),
       @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
         (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
            (@mul_zero_class.to_has_zero.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            ((λ (τ : equiv.perm.{u+1} n)
              (_x :
                @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                  (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                  τ
                  (@finset.univ.{u} (equiv.perm.{u+1} n)
                     (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                        _inst_1))),
                @has_mul.mul.{u} (equiv.perm.{u+1} n)
                  (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  σ
                  τ)
               τ
               ha)
            i)
         i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
⊢ @eq.{v+1} R
    (@coe.{1 v+1} int R
       (@coe_to_lift.{1 v+1} int R
          (@coe_base.{1 v+1} int R
             (@int.cast_coe.{v} R
                (@add_group.to_has_neg.{v} R
                   (@add_comm_group.to_add_group.{v} R
                      (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@coe.{1 1} (@units.{0} int int.monoid) int
          (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
             (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
          (@has_mul.mul.{0} (@units.{0} int int.monoid)
             (@semigroup.to_has_mul.{0} (@units.{0} int int.monoid)
                (@monoid.to_semigroup.{0} (@units.{0} int int.monoid)
                   (@group.to_monoid.{0} (@units.{0} int int.monoid) (@units.group.{0} int int.monoid))))
             (@has_pow.pow.{0 0} (@units.{0} int int.monoid) nat
                (@monoid.has_pow.{0} (@units.{0} int int.monoid)
                   (@group.to_monoid.{0} (@units.{0} int int.monoid) (@units.group.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)
                (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ))))
    (@has_mul.mul.{v} R
       (@semigroup.to_has_mul.{v} R
          (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@has_mul.mul.{v} R
          (@semigroup.to_has_mul.{v} R
             (@monoid.to_semigroup.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 τ))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
⊢ @eq.{(max (u+1) (v+1))} (n → R)
    (λ (i : n),
       @pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
         (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
         (@mul_zero_class.to_has_zero.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@equiv.to_pequiv.{u u} n n σ)
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ i)
         i)
    (λ (i : n),
       @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
         (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
            (@mul_zero_class.to_has_zero.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            ((λ (τ : equiv.perm.{u+1} n)
              (_x :
                @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                  (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                  τ
                  (@finset.univ.{u} (equiv.perm.{u+1} n)
                     (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                        _inst_1))),
                @has_mul.mul.{u} (equiv.perm.{u+1} n)
                  (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  σ
                  τ)
               τ
               ha)
            i)
         i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138      { ext i, apply pequiv.equiv_to_pequiv_to_matrix } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='pequiv.equiv_to_pequiv_to_matrix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/pequiv.lean&#x27;, &#x27;line&#x27;: 136, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : Type u} [_inst_4 : fintype.{u} n] [_inst_8 : decidable_eq.{u+1} n] {α : Type v} [_inst_9 : has_one.{v} α] [_inst_10 : has_zero.{v} α] (σ : equiv.{u+1 u+1} n n) (i j : n), @eq.{v+1} α (@pequiv.to_matrix.{u v} n n _inst_4 _inst_4 (λ (a b : n), _inst_8 a b) (λ (a b : n), _inst_8 a b) α _inst_9 _inst_10 (@equiv.to_pequiv.{u u} n n σ) i j) (@has_one.one.{(max u v)} (@matrix.{u v} n n _inst_4 _inst_4 α) (@matrix.has_one.{u v} n _inst_4 α (λ (a b : n), _inst_8 a b) _inst_10 _inst_9) (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='We can also define permutation matrices by permuting the rows of the identity matrix.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
⊢ @eq.{(max (u+1) (v+1))} (n → R)
    (λ (i : n),
       @pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
         (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
         (@mul_zero_class.to_has_zero.{v} R
            (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@equiv.to_pequiv.{u u} n n σ)
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ i)
         i)
    (λ (i : n),
       @has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
         (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
            (@mul_zero_class.to_has_zero.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            ((λ (τ : equiv.perm.{u+1} n)
              (_x :
                @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                  (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                  τ
                  (@finset.univ.{u} (equiv.perm.{u+1} n)
                     (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                        _inst_1))),
                @has_mul.mul.{u} (equiv.perm.{u+1} n)
                  (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                     (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                        (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                  σ
                  τ)
               τ
               ha)
            i)
         i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
ha :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
i : n
⊢ @eq.{v+1} R
    (@pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
       (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@equiv.to_pequiv.{u u} n n σ)
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) τ i)
       i)
    (@has_one.one.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
       (@matrix.has_one.{u v} n _inst_1 R (λ (a b : n), _inst_2 a b)
          (@mul_zero_class.to_has_zero.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          ((λ (τ : equiv.perm.{u+1} n)
            (_x :
              @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                τ
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
              @has_mul.mul.{u} (equiv.perm.{u+1} n)
                (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                σ
                τ)
             τ
             ha)
          i)
       i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ ∀ (a₁ a₂ : equiv.perm.{u+1} n)
  (ha₁ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₁
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)))
  (ha₂ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₂
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
    @eq.{u+1} (equiv.perm.{u+1} n)
      ((λ (τ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            τ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
          @has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            σ
            τ)
         a₁
         ha₁)
      ((λ (τ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            τ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
          @has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            σ
            τ)
         a₂
         ha₂) →
    @eq.{u+1} (equiv.perm.{u+1} n) a₁ a₂

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ ∀ (b : equiv.perm.{u+1} n),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      b
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)) →
    @Exists.{u+1} (equiv.perm.{u+1} n)
      (λ (a : equiv.perm.{u+1} n),
         @Exists.{0}
           (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
              (@finset.has_mem.{u} (equiv.perm.{u+1} n))
              a
              (@finset.univ.{u} (equiv.perm.{u+1} n)
                 (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)))
           (λ
            (ha :
              @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                a
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
              @eq.{u+1} (equiv.perm.{u+1} n) b
                ((λ (τ : equiv.perm.{u+1} n)
                  (_x :
                    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                      (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                      τ
                      (@finset.univ.{u} (equiv.perm.{u+1} n)
                         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                            _inst_1))),
                    @has_mul.mul.{u} (equiv.perm.{u+1} n)
                      (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                         (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                            (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                      σ
                      τ)
                   a
                   ha)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139    { intros τ τ&#x27; _ _, exact (mul_left_inj σ).mp },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='mul_left_inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/basic.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : left_cancel_semigroup.{u} α] (a : α) {b c : α}, iff (@eq.{u+1} α (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@left_cancel_semigroup.to_semigroup.{u} α _inst_1)) a b) (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@left_cancel_semigroup.to_semigroup.{u} α _inst_1)) a c)) (@eq.{u+1} α b c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ ∀ (a₁ a₂ : equiv.perm.{u+1} n)
  (ha₁ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₁
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)))
  (ha₂ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₂
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
    @eq.{u+1} (equiv.perm.{u+1} n)
      ((λ (τ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            τ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
          @has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            σ
            τ)
         a₁
         ha₁)
      ((λ (τ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            τ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
          @has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            σ
            τ)
         a₂
         ha₂) →
    @eq.{u+1} (equiv.perm.{u+1} n) a₁ a₂

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ ∀ (b : equiv.perm.{u+1} n),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      b
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)) →
    @Exists.{u+1} (equiv.perm.{u+1} n)
      (λ (a : equiv.perm.{u+1} n),
         @Exists.{0}
           (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
              (@finset.has_mem.{u} (equiv.perm.{u+1} n))
              a
              (@finset.univ.{u} (equiv.perm.{u+1} n)
                 (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)))
           (λ
            (ha :
              @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                a
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
              @eq.{u+1} (equiv.perm.{u+1} n) b
                ((λ (τ : equiv.perm.{u+1} n)
                  (_x :
                    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                      (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                      τ
                      (@finset.univ.{u} (equiv.perm.{u+1} n)
                         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                            _inst_1))),
                    @has_mul.mul.{u} (equiv.perm.{u+1} n)
                      (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                         (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                            (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                      σ
                      τ)
                   a
                   ha)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ ∀ (a₁ a₂ : equiv.perm.{u+1} n)
  (ha₁ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₁
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)))
  (ha₂ :
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      a₂
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
    @eq.{u+1} (equiv.perm.{u+1} n)
      ((λ (τ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            τ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
          @has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            σ
            τ)
         a₁
         ha₁)
      ((λ (τ : equiv.perm.{u+1} n)
        (_x :
          @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            τ
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
          @has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            σ
            τ)
         a₂
         ha₂) →
    @eq.{u+1} (equiv.perm.{u+1} n) a₁ a₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ τ&#x27; : equiv.perm.{u+1} n,
ha₁ :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)),
ha₂ :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ&#x27;
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
⊢ @eq.{u+1} (equiv.perm.{u+1} n)
    ((λ (τ : equiv.perm.{u+1} n)
      (_x :
        @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
          (@finset.has_mem.{u} (equiv.perm.{u+1} n))
          τ
          (@finset.univ.{u} (equiv.perm.{u+1} n)
             (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
        @has_mul.mul.{u} (equiv.perm.{u+1} n)
          (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
             (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          σ
          τ)
       τ
       ha₁)
    ((λ (τ : equiv.perm.{u+1} n)
      (_x :
        @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
          (@finset.has_mem.{u} (equiv.perm.{u+1} n))
          τ
          (@finset.univ.{u} (equiv.perm.{u+1} n)
             (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
        @has_mul.mul.{u} (equiv.perm.{u+1} n)
          (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
             (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          σ
          τ)
       τ&#x27;
       ha₂) →
  @eq.{u+1} (equiv.perm.{u+1} n) τ τ&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ ∀ (b : equiv.perm.{u+1} n),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      b
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)) →
    @Exists.{u+1} (equiv.perm.{u+1} n)
      (λ (a : equiv.perm.{u+1} n),
         @Exists.{0}
           (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
              (@finset.has_mem.{u} (equiv.perm.{u+1} n))
              a
              (@finset.univ.{u} (equiv.perm.{u+1} n)
                 (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)))
           (λ
            (ha :
              @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                a
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
              @eq.{u+1} (equiv.perm.{u+1} n) b
                ((λ (τ : equiv.perm.{u+1} n)
                  (_x :
                    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                      (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                      τ
                      (@finset.univ.{u} (equiv.perm.{u+1} n)
                         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                            _inst_1))),
                    @has_mul.mul.{u} (equiv.perm.{u+1} n)
                      (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                         (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                            (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                      σ
                      τ)
                   a
                   ha)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140    { intros τ _, use σ⁻¹ * τ, use (mem_univ _), exact (mul_inv_cancel_left _ _).symm }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_inv.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='finset.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='mul_inv_cancel_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 313, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 122, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_inv.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : fintype.{?l_1} α] (x : α), @has_mem.mem.{?l_1 ?l_1} α (finset.{?l_1} α) (@finset.has_mem.{?l_1} α) x (@finset.univ.{?l_1} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : group.{u} α] (a b : α), @eq.{u+1} α (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α (@group.to_monoid.{u} α _inst_1))) a (@has_mul.mul.{u} α (@semigroup.to_has_mul.{u} α (@monoid.to_semigroup.{u} α (@group.to_monoid.{u} α _inst_1))) (@has_inv.inv.{u} α (@group.to_has_inv.{u} α _inst_1) a) b)) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n
⊢ ∀ (b : equiv.perm.{u+1} n),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      b
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)) →
    @Exists.{u+1} (equiv.perm.{u+1} n)
      (λ (a : equiv.perm.{u+1} n),
         @Exists.{0}
           (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
              (@finset.has_mem.{u} (equiv.perm.{u+1} n))
              a
              (@finset.univ.{u} (equiv.perm.{u+1} n)
                 (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)))
           (λ
            (ha :
              @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                a
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
              @eq.{u+1} (equiv.perm.{u+1} n) b
                ((λ (τ : equiv.perm.{u+1} n)
                  (_x :
                    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                      (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                      τ
                      (@finset.univ.{u} (equiv.perm.{u+1} n)
                         (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                            _inst_1))),
                    @has_mul.mul.{u} (equiv.perm.{u+1} n)
                      (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                         (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                            (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                      σ
                      τ)
                   a
                   ha)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
⊢ @Exists.{u+1} (equiv.perm.{u+1} n)
    (λ (a : equiv.perm.{u+1} n),
       @Exists.{0}
         (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
            (@finset.has_mem.{u} (equiv.perm.{u+1} n))
            a
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)))
         (λ
          (ha :
            @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
              (@finset.has_mem.{u} (equiv.perm.{u+1} n))
              a
              (@finset.univ.{u} (equiv.perm.{u+1} n)
                 (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
            @eq.{u+1} (equiv.perm.{u+1} n) τ
              ((λ (τ : equiv.perm.{u+1} n)
                (_x :
                  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                    (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                    τ
                    (@finset.univ.{u} (equiv.perm.{u+1} n)
                       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1
                          _inst_1))),
                  @has_mul.mul.{u} (equiv.perm.{u+1} n)
                    (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                       (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                          (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                    σ
                    τ)
                 a
                 ha)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
⊢ @Exists.{0}
    (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
       (@finset.has_mem.{u} (equiv.perm.{u+1} n))
       (@has_mul.mul.{u} (equiv.perm.{u+1} n)
          (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
             (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          (@has_inv.inv.{u} (equiv.perm.{u+1} n)
             (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
             σ)
          τ)
       (@finset.univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)))
    (λ
     (ha :
       @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_mem.{u} (equiv.perm.{u+1} n))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@has_inv.inv.{u} (equiv.perm.{u+1} n)
               (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
               σ)
            τ)
         (@finset.univ.{u} (equiv.perm.{u+1} n)
            (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
       @eq.{u+1} (equiv.perm.{u+1} n) τ
         ((λ (τ : equiv.perm.{u+1} n)
           (_x :
             @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
               (@finset.has_mem.{u} (equiv.perm.{u+1} n))
               τ
               (@finset.univ.{u} (equiv.perm.{u+1} n)
                  (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
             @has_mul.mul.{u} (equiv.perm.{u+1} n)
               (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                  (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                     (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
               σ
               τ)
            (@has_mul.mul.{u} (equiv.perm.{u+1} n)
               (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                  (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                     (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
               (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                  (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                  σ)
               τ)
            ha))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ τ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    τ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))
⊢ @eq.{u+1} (equiv.perm.{u+1} n) τ
    ((λ (τ : equiv.perm.{u+1} n)
      (_x :
        @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
          (@finset.has_mem.{u} (equiv.perm.{u+1} n))
          τ
          (@finset.univ.{u} (equiv.perm.{u+1} n)
             (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1))),
        @has_mul.mul.{u} (equiv.perm.{u+1} n)
          (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
             (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          σ
          τ)
       (@has_mul.mul.{u} (equiv.perm.{u+1} n)
          (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
             (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          (@has_inv.inv.{u} (equiv.perm.{u+1} n)
             (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
             σ)
          τ)
       (@finset.mem_univ.{u} (equiv.perm.{u+1} n)
          (@equiv.fintype.{u u} n n (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) _inst_1 _inst_1)
          (@has_mul.mul.{u} (equiv.perm.{u+1} n)
             (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                   (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
             (@has_inv.inv.{u} (equiv.perm.{u+1} n)
                (@group.to_has_inv.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))
                σ)
             τ)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143  /-- Permuting the columns changes the sign of the determinant. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144  lemma det_permute (σ : perm n) (M : matrix n n R) : matrix.det (λ i, M (σ i)) = σ.sign * M.det :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='equiv.perm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='matrix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='matrix.det'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='equiv.perm.sign'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='matrix.det'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/basic.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/perm/sign.lean&#x27;, &#x27;line&#x27;: 464, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Sort u_1 → Sort (max 1 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π (m n : Type u) [_inst_1 : fintype.{u} m] [_inst_2 : fintype.{u} n], Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {n : Type u} [_inst_1 : fintype.{u} n] [_inst_2 : decidable_eq.{u+1} n] {R : Type v} [_inst_3 : comm_ring.{v} R], @matrix.{u v} n n _inst_1 _inst_1 R → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : fintype.{u} α], equiv.perm.{u+1} α → @units.{0} int int.monoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v} [c : has_mul.{v} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : Type u} [_inst_1 : fintype.{u} n] [_inst_2 : decidable_eq.{u+1} n] {R : Type v} [_inst_3 : comm_ring.{v} R], @matrix.{u v} n n _inst_1 _inst_1 R → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='`perm α` is the type of bijections from `α` to itself.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The determinant of a matrix given by the Leibniz formula.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The determinant of a matrix given by the Leibniz formula.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145  by rw [←det_permutation, ←det_mul, pequiv.to_pequiv_mul_matrix]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='matrix.det_permutation'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='matrix.det_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pequiv.to_pequiv_mul_matrix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 126, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 64, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/pequiv.lean&#x27;, &#x27;line&#x27;: 79, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : Type u} [_inst_1 : fintype.{u} n] [_inst_2 : decidable_eq.{u+1} n] {R : Type v} [_inst_3 : comm_ring.{v} R] (σ : equiv.perm.{u+1} n), @eq.{v+1} R (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 (@pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))) (@mul_zero_class.to_has_zero.{v} R (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (@equiv.to_pequiv.{u u} n n σ))) (@coe.{1 v+1} (@units.{0} int int.monoid) R (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid) (@coe_base.{1 v+1} int R (@int.cast_coe.{v} R (@add_group.to_has_neg.{v} R (@add_comm_group.to_add_group.{v} R (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (@mul_zero_class.to_has_zero.{v} R (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3))) (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))) (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : Type u} [_inst_1 : fintype.{u} n] [_inst_2 : decidable_eq.{u+1} n] {R : Type v} [_inst_3 : comm_ring.{v} R] (M N : @matrix.{u v} n n _inst_1 _inst_1 R), @eq.{v+1} R (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 (@has_mul.mul.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R) (@matrix.has_mul.{u v} n _inst_1 R (@mul_zero_class.to_has_mul.{v} R (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) M N)) (@has_mul.mul.{v} R (@mul_zero_class.to_has_mul.{v} R (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))) (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 M) (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 N))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {n : Type u} [_inst_4 : fintype.{u} n] [_inst_8 : decidable_eq.{u+1} n] {α : Type v} [_inst_9 : semiring.{v} α] (f : equiv.{u+1 u+1} n n) (M : @matrix.{u v} n n _inst_4 _inst_4 α), @eq.{(max u v)+1} (@matrix.{u v} n n _inst_4 _inst_4 α) (@has_mul.mul.{(max u v)} (@matrix.{u v} n n _inst_4 _inst_4 α) (@matrix.has_mul.{u v} n _inst_4 α (@mul_zero_class.to_has_mul.{v} α (@semiring.to_mul_zero_class.{v} α _inst_9)) (@semiring.to_add_comm_monoid.{v} α _inst_9)) (@pequiv.to_matrix.{u v} n n _inst_4 _inst_4 (λ (a b : n), _inst_8 a b) (λ (a b : n), _inst_8 a b) α (@monoid.to_has_one.{v} α (@semiring.to_monoid.{v} α _inst_9)) (@mul_zero_class.to_has_zero.{v} α (@semiring.to_mul_zero_class.{v} α _inst_9)) (@equiv.to_pequiv.{u u} n n f)) M) (λ (i : n), M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.{u+1 u+1} n n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) f i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The determinant of a permutation matrix equals its sign.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (λ (i : n), M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} (@units.{0} int int.monoid) R
          (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
             (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
       (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 M))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (λ (i : n), M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
          (@pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
             (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
             (@mul_zero_class.to_has_zero.{v} R
                (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
             (@equiv.to_pequiv.{u u} n n σ)))
       (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 M))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (λ (i : n), M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)))
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (@has_mul.mul.{(max u v)} (@matrix.{u v} n n _inst_1 _inst_1 R)
          (@matrix.has_mul.{u v} n _inst_1 R
             (@mul_zero_class.to_has_mul.{v} R
                (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@pequiv.to_matrix.{u v} n n _inst_1 _inst_1 (λ (a b : n), _inst_2 a b) (λ (a b : n), _inst_2 a b) R
             (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
             (@mul_zero_class.to_has_zero.{v} R
                (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
             (@equiv.to_pequiv.{u u} n n σ))
          M))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (λ (i : n), M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} (@units.{0} int int.monoid) R
          (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
             (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
       (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 M))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
σ : equiv.perm.{u+1} n,
M : @matrix.{u v} n n _inst_1 _inst_1 R
⊢ @eq.{v+1} R
    (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3
       (λ (i : n), M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} (@units.{0} int int.monoid) R
          (@coe_to_lift.{1 v+1} (@units.{0} int int.monoid) R
             (@coe_trans.{1 1 v+1} (@units.{0} int int.monoid) int R (@units.has_coe.{0} int int.monoid)
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))))
          (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))
       (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 M))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147  section det_zero</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148  /-! ### `det_zero` section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150    Prove that a matrix with a repeated column has determinant equal to zero.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154    `mod_swap i j` contains permutations up to swapping `i` and `j`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156    We use this to partition permutations in the expression for the determinant,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157    such that each partitions sums up to `0`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159  def mod_swap {n : Type u} [decidable_eq n] (i j : n) : setoid (perm n) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='decidable_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='setoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.perm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/setoid.lean&#x27;, &#x27;line&#x27;: 10, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Sort u → Sort (max 1 u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Sort u_1 → Sort (max 1 u_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                               </code><font color='orange'><a title='`perm α` is the type of bijections from `α` to itself.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160  ⟨ λ σ τ, σ = τ ∨ σ = swap i j * τ,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='or'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.swap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 846, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : decidable_eq.{u+1} α], α → α → equiv.perm.{u+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`swap a b` is the permutation that swaps `a` and `b` and
 leaves other values as is.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161    λ σ, or.inl (refl σ),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='or.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/classes.lean&#x27;, &#x27;line&#x27;: 136, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b : Prop}, a → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} {r : α → α → Prop} [_inst_1 : is_refl.{u} α r] (a : α), r a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162    λ σ τ h, or.cases_on h (λ h, or.inl h.symm) (λ h, or.inr (by rw [h, swap_mul_self_mul])),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='or.cases_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='or.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='or.inr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.perm.swap_mul_self_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/perm/sign.lean&#x27;, &#x27;line&#x27;: 169, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='(λ (σ τ : equiv.perm.{u+1} n), or (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ τ) (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ (@has_mul.mul.{u} (equiv.perm.{u+1} n) (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n) (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n) (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))) (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j) τ))) σ τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b C : Prop}, or a b → (a → C) → (b → C) → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='(λ (σ τ : equiv.perm.{u+1} n), or (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ τ) (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ (@has_mul.mul.{u} (equiv.perm.{u+1} n) (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n) (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n) (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))) (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j) τ))) σ τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b : Prop}, a → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a b : α}, @eq.{(max 1 (u+1))} α a b → @eq.{(max 1 (u+1))} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ (@has_mul.mul.{u} (equiv.perm.{u+1} n) (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n) (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n) (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))) (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j) τ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b : Prop}, b → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ (@has_mul.mul.{u} (equiv.perm.{u+1} n) (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n) (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n) (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))) (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j) τ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : decidable_eq.{u+1} α] (i j : α) (σ : equiv.perm.{u+1} α), @eq.{u+1} (equiv.perm.{u+1} α) (@has_mul.mul.{u} (equiv.perm.{u+1} α) (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} α) (@monoid.to_semigroup.{u} (equiv.perm.{u+1} α) (@group.to_monoid.{u} (equiv.perm.{u+1} α) (@equiv.perm.perm_group.{u} α)))) (@equiv.swap.{u+1} α (λ (a b : α), _inst_1 a b) i j) (@has_mul.mul.{u} (equiv.perm.{u+1} α) (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} α) (@monoid.to_semigroup.{u} (equiv.perm.{u+1} α) (@group.to_monoid.{u} (equiv.perm.{u+1} α) (@equiv.perm.perm_group.{u} α)))) (@equiv.swap.{u+1} α (λ (a b : α), _inst_1 a b) i j) σ)) σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                               </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Multiplying a permutation with `swap i j` twice gives the original permutation.

 This specialization of `swap_mul_self` is useful when using cosets of permutations.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                               </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                               </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                              </code><font color='lime'><a title='n : Type u,
_inst_4 : decidable_eq.{u+1} n,
i j : n,
σ τ : equiv.perm.{u+1} n,
h :
  (λ (σ τ : equiv.perm.{u+1} n),
     or (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ τ)
       (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ
          (@has_mul.mul.{u} (equiv.perm.{u+1} n)
             (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                   (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
             (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j)
             τ)))
    σ
    τ,
h :
  @eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ
    (@has_mul.mul.{u} (equiv.perm.{u+1} n)
       (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
          (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
             (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
       (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j)
       τ)
⊢ @eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) τ
    (@has_mul.mul.{u} (equiv.perm.{u+1} n)
       (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
          (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
             (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
       (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j)
       σ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_4 : decidable_eq.{u+1} n,
i j : n,
σ τ : equiv.perm.{u+1} n,
h :
  (λ (σ τ : equiv.perm.{u+1} n),
     or (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ τ)
       (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ
          (@has_mul.mul.{u} (equiv.perm.{u+1} n)
             (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                   (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
             (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j)
             τ)))
    σ
    τ,
h :
  @eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ
    (@has_mul.mul.{u} (equiv.perm.{u+1} n)
       (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
          (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
             (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
       (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j)
       τ)
⊢ @eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) τ
    (@has_mul.mul.{u} (equiv.perm.{u+1} n)
       (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
          (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
             (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
       (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j)
       (@has_mul.mul.{u} (equiv.perm.{u+1} n)
          (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
             (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j)
          τ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163    λ σ τ υ hστ hτυ, by cases hστ; cases hτυ; try {rw [hστ, hτυ, swap_mul_self_mul]}; finish⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='υ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hστ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hτυ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='hστ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hτυ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='hστ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hτυ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.perm.swap_mul_self_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 851, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/perm/sign.lean&#x27;, &#x27;line&#x27;: 169, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 851, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/finish.lean&#x27;, &#x27;line&#x27;: 558, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='(λ (σ τ : equiv.perm.{u+1} n), or (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ τ) (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ (@has_mul.mul.{u} (equiv.perm.{u+1} n) (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n) (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n) (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))) (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j) τ))) σ τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='(λ (σ τ : equiv.perm.{u+1} n), or (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ τ) (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ (@has_mul.mul.{u} (equiv.perm.{u+1} n) (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n) (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n) (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))) (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j) τ))) τ υ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='(λ (σ τ : equiv.perm.{u+1} n), or (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ τ) (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ (@has_mul.mul.{u} (equiv.perm.{u+1} n) (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n) (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n) (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))) (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j) τ))) σ τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='(λ (σ τ : equiv.perm.{u+1} n), or (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ τ) (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ (@has_mul.mul.{u} (equiv.perm.{u+1} n) (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n) (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n) (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))) (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j) τ))) τ υ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) τ υ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : decidable_eq.{?l_1+1} α] (i j : α) (σ : equiv.perm.{?l_1+1} α), @eq.{?l_1+1} (equiv.perm.{?l_1+1} α) (@has_mul.mul.{?l_1} (equiv.perm.{?l_1+1} α) (@semigroup.to_has_mul.{?l_1} (equiv.perm.{?l_1+1} α) (@monoid.to_semigroup.{?l_1} (equiv.perm.{?l_1+1} α) (@group.to_monoid.{?l_1} (equiv.perm.{?l_1+1} α) (@equiv.perm.perm_group.{?l_1} α)))) (@equiv.swap.{?l_1+1} α (λ (a b : α), _inst_1 a b) i j) (@has_mul.mul.{?l_1} (equiv.perm.{?l_1+1} α) (@semigroup.to_has_mul.{?l_1} (equiv.perm.{?l_1+1} α) (@monoid.to_semigroup.{?l_1} (equiv.perm.{?l_1+1} α) (@group.to_monoid.{?l_1} (equiv.perm.{?l_1+1} α) (@equiv.perm.perm_group.{?l_1} α)))) (@equiv.swap.{?l_1+1} α (λ (a b : α), _inst_1 a b) i j) σ)) σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (option.{0} (list.{0} pexpr)) (λ (a : option.{0} (list.{0} pexpr)), @option.has_reflect (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(list.{0} pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} pexpr) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} pexpr) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.pexpr_list_or_texpr)) → opt_param.{1} auto.auto_config {use_simp := bool.tt, classical := bool.tt, max_ematch_rounds := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`try { t }` tries to apply tactic `t`, but succeeds whether or not `t` succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Multiplying a permutation with `swap i j` twice gives the original permutation.

 This specialization of `swap_mul_self` is useful when using cosets of permutations.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`try { t }` tries to apply tactic `t`, but succeeds whether or not `t` succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`finish [h1,...,hn] using [e1,...,en]` negates the goal, normalizes hypotheses
(by splitting conjunctions, eliminating existentials, pushing negations inwards,
and calling `simp` with the supplied lemmas `h1,...,hn`), and then tries `contradiction`.

If this fails, it will create an SMT state and repeatedly use `ematch`
(using `ematch` lemmas in the environment, universally quantified assumptions,
and the supplied lemmas `e1,...,en`) and congruence closure.

`finish` is complete for propositional logic.

Either of the supplied simp lemmas or the supplied ematch lemmas are optional.

`finish` will fail if it does not close the goal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='try'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='try'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='finish'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(using ([expr, ...] | expr))?&#x27;, &#x27;auto.auto_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='lime'><a title='n : Type u,
_inst_4 : decidable_eq.{u+1} n,
i j : n,
σ τ υ : equiv.perm.{u+1} n,
hστ :
  (λ (σ τ : equiv.perm.{u+1} n),
     or (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ τ)
       (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ
          (@has_mul.mul.{u} (equiv.perm.{u+1} n)
             (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                   (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
             (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j)
             τ)))
    σ
    τ,
hτυ :
  (λ (σ τ : equiv.perm.{u+1} n),
     or (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ τ)
       (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ
          (@has_mul.mul.{u} (equiv.perm.{u+1} n)
             (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                   (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
             (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j)
             τ)))
    τ
    υ
⊢ or (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ υ)
    (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ
       (@has_mul.mul.{u} (equiv.perm.{u+1} n)
          (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
             (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j)
          υ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
n : Type u,
_inst_4 : decidable_eq.{u+1} n,
i j : n,
σ τ υ : equiv.perm.{u+1} n,
hστ : @eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ τ,
hτυ : @eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) τ υ
⊢ or (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ υ)
    (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ
       (@has_mul.mul.{u} (equiv.perm.{u+1} n)
          (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
             (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j)
          υ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_4 : decidable_eq.{u+1} n,
i j : n,
σ τ υ : equiv.perm.{u+1} n,
hστ : @eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ τ,
hτυ : @eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) τ υ
⊢ or (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) τ υ)
    (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) τ
       (@has_mul.mul.{u} (equiv.perm.{u+1} n)
          (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
             (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j)
          υ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_4 : decidable_eq.{u+1} n,
i j : n,
σ τ υ : equiv.perm.{u+1} n,
hστ : @eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ τ,
hτυ : @eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) τ υ
⊢ or (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) υ υ)
    (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) υ
       (@has_mul.mul.{u} (equiv.perm.{u+1} n)
          (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
             (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j)
          υ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_4 : decidable_eq.{u+1} n,
i j : n,
σ τ υ : equiv.perm.{u+1} n,
hστ :
  @eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ
    (@has_mul.mul.{u} (equiv.perm.{u+1} n)
       (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
          (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
             (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
       (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j)
       τ),
hτυ :
  @eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) τ
    (@has_mul.mul.{u} (equiv.perm.{u+1} n)
       (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
          (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
             (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
       (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j)
       υ)
⊢ or (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) υ υ)
    (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) υ
       (@has_mul.mul.{u} (equiv.perm.{u+1} n)
          (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
             (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j)
          υ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
n : Type u,
_inst_4 : decidable_eq.{u+1} n,
i j : n,
σ τ υ : equiv.perm.{u+1} n,
hστ :
  @eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ
    (@has_mul.mul.{u} (equiv.perm.{u+1} n)
       (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
          (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
             (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
       (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j)
       τ),
hτυ :
  @eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) τ
    (@has_mul.mul.{u} (equiv.perm.{u+1} n)
       (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
          (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
             (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
       (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j)
       υ)
⊢ or (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) υ υ)
    (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) υ
       (@has_mul.mul.{u} (equiv.perm.{u+1} n)
          (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
             (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j)
          υ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_4 : decidable_eq.{u+1} n,
i j : n,
σ τ υ : equiv.perm.{u+1} n,
hστ :
  (λ (σ τ : equiv.perm.{u+1} n),
     or (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ τ)
       (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ
          (@has_mul.mul.{u} (equiv.perm.{u+1} n)
             (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                   (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
             (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j)
             τ)))
    σ
    τ,
hτυ :
  (λ (σ τ : equiv.perm.{u+1} n),
     or (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ τ)
       (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ
          (@has_mul.mul.{u} (equiv.perm.{u+1} n)
             (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                   (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
             (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j)
             τ)))
    τ
    υ
⊢ or (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ υ)
    (@eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) σ
       (@has_mul.mul.{u} (equiv.perm.{u+1} n)
          (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
             (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          (@equiv.swap.{u+1} n (λ (a b : n), _inst_4 a b) i j)
          υ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  instance (i j : n) : decidable_rel (mod_swap i j).r := λ σ τ, or.decidable</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='decidable_rel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='matrix.mod_swap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='setoid.r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='τ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='or.decidable'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 272, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 159, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/setoid.lean&#x27;, &#x27;line&#x27;: 10, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 691, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Sort u}, (α → α → Prop) → Sort (max u 1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {n : Type u} [_inst_4 : decidable_eq.{u+1} n], n → n → setoid.{(max 1 (u+1))} (equiv.perm.{u+1} n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : setoid.{(max 1 (u+1))} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {p q : Prop} [_inst_1 : decidable p] [_inst_2 : decidable q], decidable (or p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='`mod_swap i j` contains permutations up to swapping `i` and `j`.

We use this to partition permutations in the expression for the determinant,
such that each partitions sums up to `0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167  variables {M : matrix n n R} {i j : n}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='matrix'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/matrix/basic.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Π (m n : Type u) [_inst_1 : fintype.{u} m] [_inst_2 : fintype.{u} n], Type v → Type (max u v)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169  /-- If a matrix has a repeated column, the determinant will be zero. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170  theorem det_zero_of_column_eq (i_ne_j : i ≠ j) (hij : M i = M j) : M.det = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='matrix.det'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 20, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u v)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {n : Type u} [_inst_1 : fintype.{u} n] [_inst_2 : decidable_eq.{u+1} n] {R : Type v} [_inst_3 : comm_ring.{v} R], @matrix.{u v} n n _inst_1 _inst_1 R → R'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                    </code><font color='orange'><a title='The determinant of a matrix given by the Leibniz formula.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j)
⊢ @eq.{v+1} R (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 M)
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172    have swap_invariant : ∀ k, M (swap i j k) = M k,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='equiv.swap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 846, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : decidable_eq.{u+1} α], α → α → equiv.perm.{u+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type (max u v)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`swap a b` is the permutation that swaps `a` and `b` and
 leaves other values as is.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j)
⊢ @eq.{v+1} R (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 M)
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j)
⊢ ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k)

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k)
⊢ @eq.{v+1} R (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 M)
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173    { intros k,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j)
⊢ ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k)

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k)
⊢ @eq.{v+1} R (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 M)
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j)
⊢ ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
k : n
⊢ @eq.{(max (u+1) (v+1))} (n → R)
    (M
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
          k))
    (M k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174      rw [swap_apply_def],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='equiv.swap_apply_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 855, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : decidable_eq.{u+1} α] (a b x : α), @eq.{u+1} α (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} α) (@equiv.has_coe_to_fun.{u+1 u+1} α α) (@equiv.swap.{u+1} α (λ (a b : α), _inst_1 a b) a b) x) (@ite.{u+1} (@eq.{u+1} α x a) (_inst_1 x a) α b (@ite.{u+1} (@eq.{u+1} α x b) (_inst_1 x b) α a x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
k : n
⊢ @eq.{(max (u+1) (v+1))} (n → R)
    (M
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
          k))
    (M k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
k : n
⊢ @eq.{(max (u+1) (v+1))} (n → R)
    (M (@ite.{u+1} (@eq.{u+1} n k i) (_inst_2 k i) n j (@ite.{u+1} (@eq.{u+1} n k j) (_inst_2 k j) n i k)))
    (M k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175      by_cases k = i, { rw [if_pos h, h, ←hij] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='if_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hij'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 839, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], c → ∀ {α : Type u} {t e : α}, @eq.{u+1} α (@ite.{u+1} c h α t e) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} n k i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} n k i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u+1) (v+1))} (n → R) (M i) (M j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
k : n
⊢ @eq.{(max (u+1) (v+1))} (n → R)
    (M (@ite.{u+1} (@eq.{u+1} n k i) (_inst_2 k i) n j (@ite.{u+1} (@eq.{u+1} n k j) (_inst_2 k j) n i k)))
    (M k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
k : n,
h : @eq.{u+1} n k i
⊢ @eq.{(max (u+1) (v+1))} (n → R)
    (M (@ite.{u+1} (@eq.{u+1} n k i) (_inst_2 k i) n j (@ite.{u+1} (@eq.{u+1} n k j) (_inst_2 k j) n i k)))
    (M k)

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
k : n,
h : not (@eq.{u+1} n k i)
⊢ @eq.{(max (u+1) (v+1))} (n → R)
    (M (@ite.{u+1} (@eq.{u+1} n k i) (_inst_2 k i) n j (@ite.{u+1} (@eq.{u+1} n k j) (_inst_2 k j) n i k)))
    (M k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
k : n,
h : @eq.{u+1} n k i
⊢ @eq.{(max (u+1) (v+1))} (n → R)
    (M (@ite.{u+1} (@eq.{u+1} n k i) (_inst_2 k i) n j (@ite.{u+1} (@eq.{u+1} n k j) (_inst_2 k j) n i k)))
    (M k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
k : n,
h : @eq.{u+1} n k i
⊢ @eq.{(max (u+1) (v+1))} (n → R) (M j) (M k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
k : n,
h : @eq.{u+1} n k i
⊢ @eq.{(max (u+1) (v+1))} (n → R) (M j) (M i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
k : n,
h : @eq.{u+1} n k i
⊢ @eq.{(max (u+1) (v+1))} (n → R)
    (M (@ite.{u+1} (@eq.{u+1} n k i) (_inst_2 k i) n j (@ite.{u+1} (@eq.{u+1} n k j) (_inst_2 k j) n i k)))
    (M k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
k : n,
h : not (@eq.{u+1} n k i)
⊢ @eq.{(max (u+1) (v+1))} (n → R)
    (M (@ite.{u+1} (@eq.{u+1} n k i) (_inst_2 k i) n j (@ite.{u+1} (@eq.{u+1} n k j) (_inst_2 k j) n i k)))
    (M k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176      rw [if_neg h],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='if_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], not c → ∀ {α : Type u} {t e : α}, @eq.{u+1} α (@ite.{u+1} c h α t e) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@eq.{u+1} n k i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
k : n,
h : not (@eq.{u+1} n k i)
⊢ @eq.{(max (u+1) (v+1))} (n → R)
    (M (@ite.{u+1} (@eq.{u+1} n k i) (_inst_2 k i) n j (@ite.{u+1} (@eq.{u+1} n k j) (_inst_2 k j) n i k)))
    (M k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
k : n,
h : not (@eq.{u+1} n k i)
⊢ @eq.{(max (u+1) (v+1))} (n → R) (M (@ite.{u+1} (@eq.{u+1} n k j) (_inst_2 k j) n i k)) (M k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177      by_cases k = j, { rw [if_pos h, h, hij] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='k'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='if_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hij'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 839, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], c → ∀ {α : Type u} {t e : α}, @eq.{u+1} α (@ite.{u+1} c h α t e) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} n k j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u+1} n k j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u+1) (v+1))} (n → R) (M i) (M j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
k : n,
h : not (@eq.{u+1} n k i)
⊢ @eq.{(max (u+1) (v+1))} (n → R) (M (@ite.{u+1} (@eq.{u+1} n k j) (_inst_2 k j) n i k)) (M k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
k : n,
h : not (@eq.{u+1} n k i),
h : @eq.{u+1} n k j
⊢ @eq.{(max (u+1) (v+1))} (n → R) (M (@ite.{u+1} (@eq.{u+1} n k j) (_inst_2 k j) n i k)) (M k)

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
k : n,
h : not (@eq.{u+1} n k i),
h : not (@eq.{u+1} n k j)
⊢ @eq.{(max (u+1) (v+1))} (n → R) (M (@ite.{u+1} (@eq.{u+1} n k j) (_inst_2 k j) n i k)) (M k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
k : n,
h : not (@eq.{u+1} n k i),
h : @eq.{u+1} n k j
⊢ @eq.{(max (u+1) (v+1))} (n → R) (M (@ite.{u+1} (@eq.{u+1} n k j) (_inst_2 k j) n i k)) (M k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
k : n,
h : not (@eq.{u+1} n k i),
h : @eq.{u+1} n k j
⊢ @eq.{(max (u+1) (v+1))} (n → R) (M i) (M k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
k : n,
h : not (@eq.{u+1} n k i),
h : @eq.{u+1} n k j
⊢ @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
k : n,
h : not (@eq.{u+1} n k i),
h : @eq.{u+1} n k j
⊢ @eq.{(max (u+1) (v+1))} (n → R) (M (@ite.{u+1} (@eq.{u+1} n k j) (_inst_2 k j) n i k)) (M k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
k : n,
h : not (@eq.{u+1} n k i),
h : not (@eq.{u+1} n k j)
⊢ @eq.{(max (u+1) (v+1))} (n → R) (M (@ite.{u+1} (@eq.{u+1} n k j) (_inst_2 k j) n i k)) (M k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178      rw [if_neg h] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='if_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], not c → ∀ {α : Type u} {t e : α}, @eq.{u+1} α (@ite.{u+1} c h α t e) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@eq.{u+1} n k j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
k : n,
h : not (@eq.{u+1} n k i),
h : not (@eq.{u+1} n k j)
⊢ @eq.{(max (u+1) (v+1))} (n → R) (M (@ite.{u+1} (@eq.{u+1} n k j) (_inst_2 k j) n i k)) (M k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
k : n,
h : not (@eq.{u+1} n k i),
h : not (@eq.{u+1} n k j)
⊢ @eq.{(max (u+1) (v+1))} (n → R) (M (@ite.{u+1} (@eq.{u+1} n k j) (_inst_2 k j) n i k)) (M k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k)
⊢ @eq.{v+1} R (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 M)
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179  </code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k)
⊢ @eq.{v+1} R (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 M)
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180    have : ∀ σ, _root_.disjoint (_root_.singleton σ) (_root_.singleton (swap i j * σ)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='disjoint'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.swap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mul.mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/lattice.lean&#x27;, &#x27;line&#x27;: 758, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 393, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 846, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : lattice.semilattice_inf_bot.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [_inst_1 : has_emptyc.{u} γ] [_inst_2 : has_insert.{u u} α γ], α → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : decidable_eq.{u+1} α], α → α → equiv.perm.{u+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_mul.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Two elements of a lattice are disjoint if their inf is the bottom element.
 (This generalizes disjoint sets, viewed as members of the subset lattice.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`swap a b` is the permutation that swaps `a` and `b` and
 leaves other values as is.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k)
⊢ @eq.{v+1} R (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 M)
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='8 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k)
⊢ ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{?l_1} ?m_2[σ] ?m_3[σ] (@singleton.{u ?l_1} (equiv.perm.{u+1} n) ?m_2[σ] ?m_4[σ] ?m_5[σ] σ)
      (@singleton.{u ?l_1} (equiv.perm.{u+1} n) ?m_2[σ] ?m_6[σ] ?m_7[σ]
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{?l_1} ?m_2[σ] ?m_3[σ] (@singleton.{u ?l_1} (equiv.perm.{u+1} n) ?m_2[σ] ?m_4[σ] ?m_5[σ] σ)
      (@singleton.{u ?l_1} (equiv.perm.{u+1} n) ?m_2[σ] ?m_6[σ] ?m_7[σ]
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ))
⊢ @eq.{v+1} R (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 M)
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
σ : equiv.perm.{u+1} n
⊢ Type ?l_1

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
σ : equiv.perm.{u+1} n
⊢ lattice.semilattice_inf_bot.{?l_1} ?m_2

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
σ : equiv.perm.{u+1} n
⊢ has_emptyc.{?l_1} ?m_2

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
σ : equiv.perm.{u+1} n
⊢ has_insert.{u ?l_1} (equiv.perm.{u+1} n) ?m_2

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
σ : equiv.perm.{u+1} n
⊢ has_emptyc.{?l_1} ?m_2

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
σ : equiv.perm.{u+1} n
⊢ has_insert.{u ?l_1} (equiv.perm.{u+1} n) ?m_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181    { intros σ,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='8 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k)
⊢ ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{?l_1} ?m_2[σ] ?m_3[σ] (@singleton.{u ?l_1} (equiv.perm.{u+1} n) ?m_2[σ] ?m_4[σ] ?m_5[σ] σ)
      (@singleton.{u ?l_1} (equiv.perm.{u+1} n) ?m_2[σ] ?m_6[σ] ?m_7[σ]
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{?l_1} ?m_2[σ] ?m_3[σ] (@singleton.{u ?l_1} (equiv.perm.{u+1} n) ?m_2[σ] ?m_4[σ] ?m_5[σ] σ)
      (@singleton.{u ?l_1} (equiv.perm.{u+1} n) ?m_2[σ] ?m_6[σ] ?m_7[σ]
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ))
⊢ @eq.{v+1} R (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 M)
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
σ : equiv.perm.{u+1} n
⊢ Type ?l_1

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
σ : equiv.perm.{u+1} n
⊢ lattice.semilattice_inf_bot.{?l_1} ?m_2

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
σ : equiv.perm.{u+1} n
⊢ has_emptyc.{?l_1} ?m_2

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
σ : equiv.perm.{u+1} n
⊢ has_insert.{u ?l_1} (equiv.perm.{u+1} n) ?m_2

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
σ : equiv.perm.{u+1} n
⊢ has_emptyc.{?l_1} ?m_2

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
σ : equiv.perm.{u+1} n
⊢ has_insert.{u ?l_1} (equiv.perm.{u+1} n) ?m_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k)
⊢ ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{?l_1} ?m_2[σ] ?m_3[σ] (@singleton.{u ?l_1} (equiv.perm.{u+1} n) ?m_2[σ] ?m_4[σ] ?m_5[σ] σ)
      (@singleton.{u ?l_1} (equiv.perm.{u+1} n) ?m_2[σ] ?m_6[σ] ?m_7[σ]
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
σ : equiv.perm.{u+1} n
⊢ @disjoint.{?l_1} ?m_2[σ] ?m_3[σ] (@singleton.{u ?l_1} (equiv.perm.{u+1} n) ?m_2[σ] ?m_4[σ] ?m_5[σ] σ)
    (@singleton.{u ?l_1} (equiv.perm.{u+1} n) ?m_2[σ] ?m_6[σ] ?m_7[σ]
       (@has_mul.mul.{u} (equiv.perm.{u+1} n)
          (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
             (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
          σ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182      rw [finset.singleton_eq_singleton, finset.singleton_eq_singleton, disjoint_singleton],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='finset.singleton_eq_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.singleton_eq_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.disjoint_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 2050, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : decidable_eq.{u+1} α] (a : α), @eq.{u+1} (finset.{u} α) (@singleton.{u u} α (finset.{u} α) (@finset.has_emptyc.{u} α) (@finset.has_insert.{u} α (λ (a b : α), _inst_1 a b)) a) (@finset.singleton.{u} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : decidable_eq.{u+1} α] (a : α), @eq.{u+1} (finset.{u} α) (@singleton.{u u} α (finset.{u} α) (@finset.has_emptyc.{u} α) (@finset.has_insert.{u} α (λ (a b : α), _inst_1 a b)) a) (@finset.singleton.{u} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : decidable_eq.{u+1} α] {s : finset.{u} α} {a : α}, iff (@disjoint.{u} (finset.{u} α) (@finset.lattice.semilattice_inf_bot.{u} α (λ (a b : α), _inst_1 a b)) s (@finset.singleton.{u} α a)) (not (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) a s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
σ : equiv.perm.{u+1} n
⊢ @disjoint.{?l_1} ?m_2[σ] ?m_3[σ] (@singleton.{u ?l_1} (equiv.perm.{u+1} n) ?m_2[σ] ?m_4[σ] ?m_5[σ] σ)
    (@singleton.{u ?l_1} (equiv.perm.{u+1} n) ?m_2[σ] ?m_6[σ] ?m_7[σ]
       (@has_mul.mul.{u} (equiv.perm.{u+1} n)
          (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
             (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
          σ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
σ : equiv.perm.{u+1} n
⊢ @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n)) ?m_1[σ] (@finset.singleton.{u} (equiv.perm.{u+1} n) σ)
    (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) ?m_2[σ] ?m_3[σ]
       (@has_mul.mul.{u} (equiv.perm.{u+1} n)
          (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
             (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
          σ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
σ : equiv.perm.{u+1} n
⊢ @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n)) ?m_1[σ] (@finset.singleton.{u} (equiv.perm.{u+1} n) σ)
    (@finset.singleton.{u} (equiv.perm.{u+1} n)
       (@has_mul.mul.{u} (equiv.perm.{u+1} n)
          (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
             (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
          σ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
σ : equiv.perm.{u+1} n
⊢ not
    (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
       (@finset.has_mem.{u} (equiv.perm.{u+1} n))
       (@has_mul.mul.{u} (equiv.perm.{u+1} n)
          (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
             (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
          σ)
       (@finset.singleton.{u} (equiv.perm.{u+1} n) σ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183      apply (not_congr mem_singleton).mpr,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='not_congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finset.mem_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 326, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 175, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, iff a b → iff (not a) (not b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {a b : α}, iff (@has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) b (@finset.singleton.{u} α a)) (@eq.{u+1} α b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
σ : equiv.perm.{u+1} n
⊢ not
    (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
       (@finset.has_mem.{u} (equiv.perm.{u+1} n))
       (@has_mul.mul.{u} (equiv.perm.{u+1} n)
          (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
             (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
          σ)
       (@finset.singleton.{u} (equiv.perm.{u+1} n) σ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
σ : equiv.perm.{u+1} n
⊢ not
    (@eq.{u+1} (equiv.perm.{u+1} n)
       (@has_mul.mul.{u} (equiv.perm.{u+1} n)
          (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
             (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
          σ)
       σ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184      exact (not_congr swap_mul_eq_iff).mpr i_ne_j },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='not_congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.perm.swap_mul_eq_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='i_ne_j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 326, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/perm/sign.lean&#x27;, &#x27;line&#x27;: 172, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, iff a b → iff (not a) (not b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : decidable_eq.{u+1} α] {i j : α} {σ : equiv.perm.{u+1} α}, iff (@eq.{u+1} (equiv.perm.{u+1} α) (@has_mul.mul.{u} (equiv.perm.{u+1} α) (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} α) (@monoid.to_semigroup.{u} (equiv.perm.{u+1} α) (@group.to_monoid.{u} (equiv.perm.{u+1} α) (@equiv.perm.perm_group.{u} α)))) (@equiv.swap.{u+1} α (λ (a b : α), _inst_1 a b) i j) σ) σ) (@eq.{u+1} α i j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{u+1} n i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
σ : equiv.perm.{u+1} n
⊢ not
    (@eq.{u+1} (equiv.perm.{u+1} n)
       (@has_mul.mul.{u} (equiv.perm.{u+1} n)
          (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
             (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
          (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
          σ)
       σ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_1[σ] a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_2[σ] a b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_3[σ] a b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ))
⊢ @eq.{v+1} R (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 M)
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185  </code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_1[σ] a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_2[σ] a b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_3[σ] a b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ))
⊢ @eq.{v+1} R (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 M)
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186    apply finset.sum_cancels_of_partition_cancels (mod_swap i j),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='finset.sum_cancels_of_partition_cancels'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='matrix.mod_swap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 484, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 159, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} {s : finset.{u} α} {f : α → β} [_inst_1 : add_comm_monoid.{v} β] (R : setoid.{u+1} α) [_inst_2 : @decidable_rel.{u+1} α (@setoid.r.{u+1} α R)], (∀ (x : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x s → @eq.{v+1} β (@finset.sum.{u v} α β _inst_1 (@finset.filter.{u} α (λ (y : α), @has_equiv.equiv.{u+1} α (@setoid_has_equiv.{u+1} α R) y x) (λ (a : α), _inst_2 a x) s) f) (@has_zero.zero.{v} β (@add_monoid.to_has_zero.{v} β (@add_comm_monoid.to_add_monoid.{v} β _inst_1)))) → @eq.{v+1} β (@finset.sum.{u v} α β _inst_1 s f) (@has_zero.zero.{v} β (@add_monoid.to_has_zero.{v} β (@add_comm_monoid.to_add_monoid.{v} β _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {n : Type u} [_inst_4 : decidable_eq.{u+1} n], n → n → setoid.{(max 1 (u+1))} (equiv.perm.{u+1} n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`mod_swap i j` contains permutations up to swapping `i` and `j`.

We use this to partition permutations in the expression for the determinant,
such that each partitions sums up to `0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_1[σ] a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_2[σ] a b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_3[σ] a b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ))
⊢ @eq.{v+1} R (@matrix.det.{u v} n _inst_1 (λ (a b : n), _inst_2 a b) R _inst_3 M)
    (@has_zero.zero.{v} R
       (@mul_zero_class.to_has_zero.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_1[σ] a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_2[σ] a b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_3[σ] a b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ))
⊢ ∀ (x : equiv.perm.{u+1} n),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      x
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1)) →
    @eq.{v+1} R
      (@finset.sum.{u v} (equiv.perm.{u+1} n) R
         (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
         (@finset.filter.{u} (equiv.perm.{u+1} n)
            (λ (y : equiv.perm.{u+1} n),
               @has_equiv.equiv.{u+1} (equiv.perm.{u+1} n)
                 (@setoid_has_equiv.{u+1} (equiv.perm.{u+1} n) (@matrix.mod_swap.{u} n (λ (a b : n), _inst_2 a b) i j))
                 y
                 x)
            (λ (a : equiv.perm.{u+1} n),
               (λ (a b : equiv.perm.{u+1} n), @matrix.decidable_rel.{u} n _inst_1 (λ (a b : n), _inst_2 a b) i j a b)
                 a
                 x)
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  _inst_1
                  _inst_1)))
         (λ (σ : equiv.perm.{u+1} n),
            @has_mul.mul.{v} R
              (@mul_zero_class.to_has_mul.{v} R
                 (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
              (@coe.{1 v+1} int R
                 (@coe_to_lift.{1 v+1} int R
                    (@coe_base.{1 v+1} int R
                       (@int.cast_coe.{v} R
                          (@add_group.to_has_neg.{v} R
                             (@add_comm_group.to_add_group.{v} R
                                (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                          (@mul_zero_class.to_has_zero.{v} R
                             (@semiring.to_mul_zero_class.{v} R
                                (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                          (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                          (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
                 (@coe.{1 1} (@units.{0} int int.monoid) int
                    (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                       (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                    (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
              (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
                 (@finset.univ.{u} n _inst_1)
                 (λ (i : n),
                    M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
                      i))))
      (@has_zero.zero.{v} R
         (@add_monoid.to_has_zero.{v} R
            (@add_comm_monoid.to_add_monoid.{v} R
               (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187    intros σ _,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_1[σ] a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_2[σ] a b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_3[σ] a b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ))
⊢ ∀ (x : equiv.perm.{u+1} n),
    @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
      x
      (@finset.univ.{u} (equiv.perm.{u+1} n)
         (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
            _inst_1
            _inst_1)) →
    @eq.{v+1} R
      (@finset.sum.{u v} (equiv.perm.{u+1} n) R
         (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
         (@finset.filter.{u} (equiv.perm.{u+1} n)
            (λ (y : equiv.perm.{u+1} n),
               @has_equiv.equiv.{u+1} (equiv.perm.{u+1} n)
                 (@setoid_has_equiv.{u+1} (equiv.perm.{u+1} n) (@matrix.mod_swap.{u} n (λ (a b : n), _inst_2 a b) i j))
                 y
                 x)
            (λ (a : equiv.perm.{u+1} n),
               (λ (a b : equiv.perm.{u+1} n), @matrix.decidable_rel.{u} n _inst_1 (λ (a b : n), _inst_2 a b) i j a b)
                 a
                 x)
            (@finset.univ.{u} (equiv.perm.{u+1} n)
               (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                  _inst_1
                  _inst_1)))
         (λ (σ : equiv.perm.{u+1} n),
            @has_mul.mul.{v} R
              (@mul_zero_class.to_has_mul.{v} R
                 (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
              (@coe.{1 v+1} int R
                 (@coe_to_lift.{1 v+1} int R
                    (@coe_base.{1 v+1} int R
                       (@int.cast_coe.{v} R
                          (@add_group.to_has_neg.{v} R
                             (@add_comm_group.to_add_group.{v} R
                                (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                          (@mul_zero_class.to_has_zero.{v} R
                             (@semiring.to_mul_zero_class.{v} R
                                (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                          (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                          (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
                 (@coe.{1 1} (@units.{0} int int.monoid) int
                    (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                       (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                    (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
              (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
                 (@finset.univ.{u} n _inst_1)
                 (λ (i : n),
                    M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
                      i))))
      (@has_zero.zero.{v} R
         (@add_monoid.to_has_zero.{v} R
            (@add_comm_monoid.to_add_monoid.{v} R
               (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_1[σ] a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_2[σ] a b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_3[σ] a b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.filter.{u} (equiv.perm.{u+1} n)
          (λ (y : equiv.perm.{u+1} n),
             @has_equiv.equiv.{u+1} (equiv.perm.{u+1} n)
               (@setoid_has_equiv.{u+1} (equiv.perm.{u+1} n) (@matrix.mod_swap.{u} n (λ (a b : n), _inst_2 a b) i j))
               y
               σ)
          (λ (a : equiv.perm.{u+1} n),
             (λ (a b : equiv.perm.{u+1} n), @matrix.decidable_rel.{u} n _inst_1 (λ (a b : n), _inst_2 a b) i j a b) a
               σ)
          (@finset.univ.{u} (equiv.perm.{u+1} n)
             (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                _inst_1
                _inst_1)))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (i : n),
                  M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) i))))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188    erw [filter_or, filter_eq&#x27;, filter_eq&#x27;, if_pos (mem_univ σ), if_pos (mem_univ (swap i j * σ)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='finset.filter_or'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.filter_eq&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.filter_eq&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='if_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='if_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.swap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 762, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 836, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/finset.lean&#x27;, &#x27;line&#x27;: 836, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 839, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 839, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 846, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {p q : α → Prop} [_inst_1 : @decidable_pred.{u+1} α p] [_inst_2 : @decidable_pred.{u+1} α q] [_inst_3 : decidable_eq.{u+1} α] (s : finset.{u} α), @eq.{u+1} (finset.{u} α) (@finset.filter.{u} α (λ (a : α), or (p a) (q a)) (λ (a : α), @or.decidable (p a) (q a) (_inst_1 a) (_inst_2 a)) s) (@has_union.union.{u} (finset.{u} α) (@finset.has_union.{u} α (λ (a b : α), _inst_3 a b)) (@finset.filter.{u} α p (λ (a : α), _inst_1 a) s) (@finset.filter.{u} α q (λ (a : α), _inst_2 a) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type u} [_inst_4 : decidable_eq.{u+1} β] (s : finset.{u} β) (b : β), @eq.{u+1} (finset.{u} β) (@finset.filter.{u} β (λ (a : β), @eq.{u+1} β a b) (λ (a : β), _inst_4 a b) s) (@ite.{u+1} (@has_mem.mem.{u u} β (finset.{u} β) (@finset.has_mem.{u} β) b s) (@finset.decidable_mem.{u} β (λ (a b : β), _inst_4 a b) b s) (finset.{u} β) (@singleton.{u u} β (finset.{u} β) (@finset.has_emptyc.{u} β) (@finset.has_insert.{u} β (λ (a b : β), _inst_4 a b)) b) (@has_emptyc.emptyc.{u} (finset.{u} β) (@finset.has_emptyc.{u} β)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type u} [_inst_4 : decidable_eq.{u+1} β] (s : finset.{u} β) (b : β), @eq.{u+1} (finset.{u} β) (@finset.filter.{u} β (λ (a : β), @eq.{u+1} β a b) (λ (a : β), _inst_4 a b) s) (@ite.{u+1} (@has_mem.mem.{u u} β (finset.{u} β) (@finset.has_mem.{u} β) b s) (@finset.decidable_mem.{u} β (λ (a b : β), _inst_4 a b) b s) (finset.{u} β) (@singleton.{u u} β (finset.{u} β) (@finset.has_emptyc.{u} β) (@finset.has_insert.{u} β (λ (a b : β), _inst_4 a b)) b) (@has_emptyc.emptyc.{u} (finset.{u} β) (@finset.has_emptyc.{u} β)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], c → ∀ {α : Type u} {t e : α}, @eq.{u+1} α (@ite.{u+1} c h α t e) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : fintype.{u} α] (x : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x (@finset.univ.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], c → ∀ {α : Type u} {t e : α}, @eq.{u+1} α (@ite.{u+1} c h α t e) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : fintype.{u} α] (x : α), @has_mem.mem.{u u} α (finset.{u} α) (@finset.has_mem.{u} α) x (@finset.univ.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : decidable_eq.{u+1} α], α → α → equiv.perm.{u+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='After filtering out everything that does not equal a given value, at most that value remains.

This is equivalent to `filter_eq` with the equality the other way.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='After filtering out everything that does not equal a given value, at most that value remains.

This is equivalent to `filter_eq` with the equality the other way.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`swap a b` is the permutation that swaps `a` and `b` and
 leaves other values as is.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_1[σ] a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_2[σ] a b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_3[σ] a b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@finset.filter.{u} (equiv.perm.{u+1} n)
          (λ (y : equiv.perm.{u+1} n),
             @has_equiv.equiv.{u+1} (equiv.perm.{u+1} n)
               (@setoid_has_equiv.{u+1} (equiv.perm.{u+1} n) (@matrix.mod_swap.{u} n (λ (a b : n), _inst_2 a b) i j))
               y
               σ)
          (λ (a : equiv.perm.{u+1} n),
             (λ (a b : equiv.perm.{u+1} n), @matrix.decidable_rel.{u} n _inst_1 (λ (a b : n), _inst_2 a b) i j a b) a
               σ)
          (@finset.univ.{u} (equiv.perm.{u+1} n)
             (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                _inst_1
                _inst_1)))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (i : n),
                  M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) i))))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_1[σ] a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_2[σ] a b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_3[σ] a b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@has_union.union.{u} (finset.{u} (equiv.perm.{u+1} n))
          (@finset.has_union.{u} (equiv.perm.{u+1} n)
             (λ (a b : equiv.perm.{u+1} n),
                @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
          (@finset.filter.{u} (equiv.perm.{u+1} n)
             (λ (a : equiv.perm.{u+1} n), @eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) a σ)
             (λ (a : equiv.perm.{u+1} n),
                @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                  σ)
             (@finset.univ.{u} (equiv.perm.{u+1} n)
                (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                   (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                   _inst_1
                   _inst_1)))
          (@finset.filter.{u} (equiv.perm.{u+1} n)
             (λ (a : equiv.perm.{u+1} n),
                @eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) a
                  (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                     (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                        (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                           (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                     (@equiv.swap.{u+1} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) i j)
                     σ))
             (λ (a : equiv.perm.{u+1} n),
                @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                  (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                     (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                        (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                           (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                     (@equiv.swap.{u+1} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) i j)
                     σ))
             (@finset.univ.{u} (equiv.perm.{u+1} n)
                (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                   (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                   _inst_1
                   _inst_1))))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (i : n),
                  M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) i))))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_1[σ] a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_2[σ] a b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_3[σ] a b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@has_union.union.{u} (finset.{u} (equiv.perm.{u+1} n))
          (@finset.has_union.{u} (equiv.perm.{u+1} n)
             (λ (a b : equiv.perm.{u+1} n),
                @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
          (@ite.{u+1}
             (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                σ
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      _inst_1
                      _inst_1)))
             (@finset.decidable_mem.{u} (equiv.perm.{u+1} n)
                (λ (a b : equiv.perm.{u+1} n),
                   @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                     a
                     b)
                σ
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      _inst_1
                      _inst_1)))
             (finset.{u} (equiv.perm.{u+1} n))
             (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
                (@finset.has_insert.{u} (equiv.perm.{u+1} n)
                   (λ (a b : equiv.perm.{u+1} n),
                      @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1
                        (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                        a
                        b))
                σ)
             (@has_emptyc.emptyc.{u} (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))))
          (@finset.filter.{u} (equiv.perm.{u+1} n)
             (λ (a : equiv.perm.{u+1} n),
                @eq.{(max 1 (u+1))} (equiv.perm.{u+1} n) a
                  (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                     (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                        (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                           (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                     (@equiv.swap.{u+1} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) i j)
                     σ))
             (λ (a : equiv.perm.{u+1} n),
                @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                  (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                     (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                        (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                           (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                     (@equiv.swap.{u+1} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) i j)
                     σ))
             (@finset.univ.{u} (equiv.perm.{u+1} n)
                (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                   (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                   _inst_1
                   _inst_1))))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (i : n),
                  M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) i))))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_1[σ] a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_2[σ] a b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_3[σ] a b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@has_union.union.{u} (finset.{u} (equiv.perm.{u+1} n))
          (@finset.has_union.{u} (equiv.perm.{u+1} n)
             (λ (a b : equiv.perm.{u+1} n),
                @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
          (@ite.{u+1}
             (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                σ
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      _inst_1
                      _inst_1)))
             (@finset.decidable_mem.{u} (equiv.perm.{u+1} n)
                (λ (a b : equiv.perm.{u+1} n),
                   @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                     a
                     b)
                σ
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      _inst_1
                      _inst_1)))
             (finset.{u} (equiv.perm.{u+1} n))
             (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
                (@finset.has_insert.{u} (equiv.perm.{u+1} n)
                   (λ (a b : equiv.perm.{u+1} n),
                      @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1
                        (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                        a
                        b))
                σ)
             (@has_emptyc.emptyc.{u} (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))))
          (@ite.{u+1}
             (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                   (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                      (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                         (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                   (@equiv.swap.{u+1} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) i j)
                   σ)
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      _inst_1
                      _inst_1)))
             (@finset.decidable_mem.{u} (equiv.perm.{u+1} n)
                (λ (a b : equiv.perm.{u+1} n),
                   @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                     a
                     b)
                (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                   (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                      (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                         (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                   (@equiv.swap.{u+1} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) i j)
                   σ)
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      _inst_1
                      _inst_1)))
             (finset.{u} (equiv.perm.{u+1} n))
             (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
                (@finset.has_insert.{u} (equiv.perm.{u+1} n)
                   (λ (a b : equiv.perm.{u+1} n),
                      @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1
                        (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                        a
                        b))
                (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                   (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                      (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                         (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                   (@equiv.swap.{u+1} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) i j)
                   σ))
             (@has_emptyc.emptyc.{u} (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_emptyc.{u} (equiv.perm.{u+1} n)))))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (i : n),
                  M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) i))))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_1[σ] a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_2[σ] a b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_3[σ] a b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@has_union.union.{u} (finset.{u} (equiv.perm.{u+1} n))
          (@finset.has_union.{u} (equiv.perm.{u+1} n)
             (λ (a b : equiv.perm.{u+1} n),
                @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
          (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
             (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
             (@finset.has_insert.{u} (equiv.perm.{u+1} n)
                (λ (a b : equiv.perm.{u+1} n),
                   @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                     a
                     b))
             σ)
          (@ite.{u+1}
             (@has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_mem.{u} (equiv.perm.{u+1} n))
                (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                   (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                      (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                         (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                   (@equiv.swap.{u+1} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) i j)
                   σ)
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      _inst_1
                      _inst_1)))
             (@finset.decidable_mem.{u} (equiv.perm.{u+1} n)
                (λ (a b : equiv.perm.{u+1} n),
                   @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                     a
                     b)
                (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                   (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                      (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                         (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                   (@equiv.swap.{u+1} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) i j)
                   σ)
                (@finset.univ.{u} (equiv.perm.{u+1} n)
                   (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                      _inst_1
                      _inst_1)))
             (finset.{u} (equiv.perm.{u+1} n))
             (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
                (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
                (@finset.has_insert.{u} (equiv.perm.{u+1} n)
                   (λ (a b : equiv.perm.{u+1} n),
                      @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1
                        (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                        a
                        b))
                (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                   (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                      (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                         (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                   (@equiv.swap.{u+1} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) i j)
                   σ))
             (@has_emptyc.emptyc.{u} (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_emptyc.{u} (equiv.perm.{u+1} n)))))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (i : n),
                  M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) i))))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_1[σ] a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_2[σ] a b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_3[σ] a b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@has_union.union.{u} (finset.{u} (equiv.perm.{u+1} n))
          (@finset.has_union.{u} (equiv.perm.{u+1} n)
             (λ (a b : equiv.perm.{u+1} n),
                @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
          (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
             (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
             (@finset.has_insert.{u} (equiv.perm.{u+1} n)
                (λ (a b : equiv.perm.{u+1} n),
                   @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                     a
                     b))
             σ)
          (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
             (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
             (@finset.has_insert.{u} (equiv.perm.{u+1} n)
                (λ (a b : equiv.perm.{u+1} n),
                   @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                     a
                     b))
             (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                (@equiv.swap.{u+1} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) i j)
                σ)))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (i : n),
                  M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) i))))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189      sum_union (this σ), sum_singleton, sum_singleton],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='finset.sum_union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='finset.sum_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='finset.sum_singleton'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 85, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} {s₁ s₂ : finset.{u} α} {f : α → β} [_inst_1 : add_comm_monoid.{v} β] [_inst_2 : decidable_eq.{u+1} α], @disjoint.{u} (finset.{u} α) (@finset.lattice.semilattice_inf_bot.{u} α (λ (a b : α), _inst_2 a b)) s₁ s₂ → @eq.{v+1} β (@finset.sum.{u v} α β _inst_1 (@has_union.union.{u} (finset.{u} α) (@finset.has_union.{u} α (λ (a b : α), _inst_2 a b)) s₁ s₂) f) (@has_add.add.{v} β (@add_semigroup.to_has_add.{v} β (@add_monoid.to_add_semigroup.{v} β (@add_comm_monoid.to_add_monoid.{v} β _inst_1))) (@finset.sum.{u v} α β _inst_1 s₁ f) (@finset.sum.{u v} α β _inst_1 s₂ f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (σ : equiv.perm.{u+1} n), @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n)) (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b)) (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_emptyc.{u} (equiv.perm.{u+1} n)) (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), (λ (a b : equiv.perm.{u+1} n), @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a b) a b)) σ) (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_emptyc.{u} (equiv.perm.{u+1} n)) (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), (λ (a b : equiv.perm.{u+1} n), @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a b) a b)) (@has_mul.mul.{u} (equiv.perm.{u+1} n) (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n) (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n) (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n)))) (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j) σ))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} {a : α} {f : α → β} [_inst_1 : add_comm_monoid.{v} β], @eq.{v+1} β (@finset.sum.{u v} α β _inst_1 (@finset.singleton.{u} α a) f) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type v} {a : α} {f : α → β} [_inst_1 : add_comm_monoid.{v} β], @eq.{v+1} β (@finset.sum.{u v} α β _inst_1 (@finset.singleton.{u} α a) f) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_1[σ] a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_2[σ] a b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n) (λ (a b : equiv.perm.{u+1} n), ?m_3[σ] a b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@finset.sum.{u v} (equiv.perm.{u+1} n) R
       (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
       (@has_union.union.{u} (finset.{u} (equiv.perm.{u+1} n))
          (@finset.has_union.{u} (equiv.perm.{u+1} n)
             (λ (a b : equiv.perm.{u+1} n),
                @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
          (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
             (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
             (@finset.has_insert.{u} (equiv.perm.{u+1} n)
                (λ (a b : equiv.perm.{u+1} n),
                   @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                     a
                     b))
             σ)
          (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
             (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
             (@finset.has_insert.{u} (equiv.perm.{u+1} n)
                (λ (a b : equiv.perm.{u+1} n),
                   @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                     a
                     b))
             (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                (@equiv.swap.{u+1} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) i j)
                σ)))
       (λ (σ : equiv.perm.{u+1} n),
          @has_mul.mul.{v} R
            (@mul_zero_class.to_has_mul.{v} R
               (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
            (@coe.{1 v+1} int R
               (@coe_to_lift.{1 v+1} int R
                  (@coe_base.{1 v+1} int R
                     (@int.cast_coe.{v} R
                        (@add_group.to_has_neg.{v} R
                           (@add_comm_group.to_add_group.{v} R
                              (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@mul_zero_class.to_has_zero.{v} R
                           (@semiring.to_mul_zero_class.{v} R
                              (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                        (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                        (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
               (@coe.{1 1} (@units.{0} int int.monoid) int
                  (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                     (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                  (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
            (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
               (@finset.univ.{u} n _inst_1)
               (λ (i : n),
                  M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) i))))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n)
         (λ (a b : equiv.perm.{u+1} n),
            @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@has_add.add.{v} R
       (@add_semigroup.to_has_add.{v} R
          (@add_monoid.to_add_semigroup.{v} R
             (@add_comm_monoid.to_add_monoid.{v} R
                (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@finset.sum.{u v} (equiv.perm.{u+1} n) R
          (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
          (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
             (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
             (@finset.has_insert.{u} (equiv.perm.{u+1} n)
                (λ (a b : equiv.perm.{u+1} n),
                   (λ (a b : equiv.perm.{u+1} n),
                      @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1
                        (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                        a
                        b)
                     a
                     b))
             σ)
          (λ (σ : equiv.perm.{u+1} n),
             @has_mul.mul.{v} R
               (@mul_zero_class.to_has_mul.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (@coe.{1 v+1} int R
                  (@coe_to_lift.{1 v+1} int R
                     (@coe_base.{1 v+1} int R
                        (@int.cast_coe.{v} R
                           (@add_group.to_has_neg.{v} R
                              (@add_comm_group.to_add_group.{v} R
                                 (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                           (@mul_zero_class.to_has_zero.{v} R
                              (@semiring.to_mul_zero_class.{v} R
                                 (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                           (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                           (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
                  (@coe.{1 1} (@units.{0} int int.monoid) int
                     (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                        (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                     (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
               (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
                  (@finset.univ.{u} n _inst_1)
                  (λ (i : n),
                     M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
                       i))))
       (@finset.sum.{u v} (equiv.perm.{u+1} n) R
          (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
          (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
             (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
             (@finset.has_insert.{u} (equiv.perm.{u+1} n)
                (λ (a b : equiv.perm.{u+1} n),
                   (λ (a b : equiv.perm.{u+1} n),
                      @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1
                        (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                        a
                        b)
                     a
                     b))
             (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
                σ))
          (λ (σ : equiv.perm.{u+1} n),
             @has_mul.mul.{v} R
               (@mul_zero_class.to_has_mul.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (@coe.{1 v+1} int R
                  (@coe_to_lift.{1 v+1} int R
                     (@coe_base.{1 v+1} int R
                        (@int.cast_coe.{v} R
                           (@add_group.to_has_neg.{v} R
                              (@add_comm_group.to_add_group.{v} R
                                 (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                           (@mul_zero_class.to_has_zero.{v} R
                              (@semiring.to_mul_zero_class.{v} R
                                 (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                           (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                           (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
                  (@coe.{1 1} (@units.{0} int int.monoid) int
                     (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                        (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                     (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
               (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
                  (@finset.univ.{u} n _inst_1)
                  (λ (i : n),
                     M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
                       i)))))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n)
         (λ (a b : equiv.perm.{u+1} n),
            @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@has_add.add.{v} R
       (@add_semigroup.to_has_add.{v} R
          (@add_monoid.to_add_semigroup.{v} R
             (@add_comm_monoid.to_add_monoid.{v} R
                (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@has_mul.mul.{v} R
          (@mul_zero_class.to_has_mul.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
          (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
             (@finset.univ.{u} n _inst_1)
             (λ (i : n),
                M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) i)))
       (@finset.sum.{u v} (equiv.perm.{u+1} n) R
          (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
          (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
             (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
             (@finset.has_insert.{u} (equiv.perm.{u+1} n)
                (λ (a b : equiv.perm.{u+1} n),
                   (λ (a b : equiv.perm.{u+1} n),
                      @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1
                        (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
                        a
                        b)
                     a
                     b))
             (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
                σ))
          (λ (σ : equiv.perm.{u+1} n),
             @has_mul.mul.{v} R
               (@mul_zero_class.to_has_mul.{v} R
                  (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
               (@coe.{1 v+1} int R
                  (@coe_to_lift.{1 v+1} int R
                     (@coe_base.{1 v+1} int R
                        (@int.cast_coe.{v} R
                           (@add_group.to_has_neg.{v} R
                              (@add_comm_group.to_add_group.{v} R
                                 (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                           (@mul_zero_class.to_has_zero.{v} R
                              (@semiring.to_mul_zero_class.{v} R
                                 (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                           (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                           (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
                  (@coe.{1 1} (@units.{0} int int.monoid) int
                     (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                        (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                     (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
               (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
                  (@finset.univ.{u} n _inst_1)
                  (λ (i : n),
                     M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i)
                       i)))))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n)
         (λ (a b : equiv.perm.{u+1} n),
            @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@has_add.add.{v} R
       (@add_semigroup.to_has_add.{v} R
          (@add_monoid.to_add_semigroup.{v} R
             (@add_comm_monoid.to_add_monoid.{v} R
                (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@has_mul.mul.{v} R
          (@mul_zero_class.to_has_mul.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
          (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
             (@finset.univ.{u} n _inst_1)
             (λ (i : n),
                M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) i)))
       (@has_mul.mul.{v} R
          (@mul_zero_class.to_has_mul.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                   (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                      (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                         (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                            (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                      (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
                      σ))))
          (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
             (@finset.univ.{u} n _inst_1)
             (λ (i_1 : n),
                M
                  (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                     (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                        (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                           (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                              (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                        (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
                        σ)
                     i_1)
                  i_1))))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190    convert add_right_neg (↑↑(sign σ) * finset.prod univ (λ (i : n), M (σ i) i)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='add_right_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.perm.sign'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='finset.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='finset.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='M'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='σ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/perm/sign.lean&#x27;, &#x27;line&#x27;: 464, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/big_operators.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 27, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : add_group.{v} α] (a : α), @eq.{v+1} α (@has_add.add.{v} α (@add_semigroup.to_has_add.{v} α (@add_monoid.to_add_semigroup.{v} α (@add_group.to_add_monoid.{v} α _inst_1))) a (@has_neg.neg.{v} α (@add_group.to_has_neg.{v} α _inst_1) a)) (@has_zero.zero.{v} α (@add_monoid.to_has_zero.{v} α (@add_group.to_add_monoid.{v} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {a : Type} {b : Type v} [_inst_1 : has_lift_t.{1 v+1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : fintype.{u} α], equiv.perm.{u+1} α → @units.{0} int int.monoid'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : comm_monoid.{v} β], finset.{u} α → (α → β) → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [_inst_1 : fintype.{u} α], finset.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@matrix.{u v} n n _inst_1 _inst_1 R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='equiv.perm.{u+1} n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title=' `sign` of a permutation returns the signature or parity of a permutation, `1` for even
permutations, `-1` for odd permutations. It is the unique surjective group homomorphism from
`perm α` to the group with two elements.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`prod s f` is the product of `f x` as `x` ranges over the elements of the finite set `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`univ` is the universal finite set of type `finset α` implied from
 the assumption `fintype α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n)
         (λ (a b : equiv.perm.{u+1} n),
            @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@has_add.add.{v} R
       (@add_semigroup.to_has_add.{v} R
          (@add_monoid.to_add_semigroup.{v} R
             (@add_comm_monoid.to_add_monoid.{v} R
                (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@has_mul.mul.{v} R
          (@mul_zero_class.to_has_mul.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ)))
          (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
             (@finset.univ.{u} n _inst_1)
             (λ (i : n),
                M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) i)))
       (@has_mul.mul.{v} R
          (@mul_zero_class.to_has_mul.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                   (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                      (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                         (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                            (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                      (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
                      σ))))
          (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
             (@finset.univ.{u} n _inst_1)
             (λ (i_1 : n),
                M
                  (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                     (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                        (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                           (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                              (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                        (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
                        σ)
                     i_1)
                  i_1))))
    (@has_zero.zero.{v} R
       (@add_monoid.to_has_zero.{v} R
          (@add_comm_monoid.to_add_monoid.{v} R
             (@semiring.to_add_comm_monoid.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n)
         (λ (a b : equiv.perm.{u+1} n),
            @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                   (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                      (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                         (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                   (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
                   σ))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i_1 : n),
             M
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                     (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                        (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                           (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                     (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
                     σ)
                  i_1)
               i_1)))
    (@has_neg.neg.{v} R
       (@add_group.to_has_neg.{v} R
          (@add_comm_group.to_add_group.{v} R (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@has_mul.mul.{v} R
          (@mul_zero_class.to_has_mul.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
          (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
             (@finset.univ.{u} n _inst_1)
             (λ (i : n),
                M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191    rw [neg_mul_eq_neg_mul],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='neg_mul_eq_neg_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ring.lean&#x27;, &#x27;line&#x27;: 180, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [s : ring.{v} α] (a b : α), @eq.{v+1} α (@has_neg.neg.{v} α (@add_group.to_has_neg.{v} α (@add_comm_group.to_add_group.{v} α (@ring.to_add_comm_group.{v} α s))) (@has_mul.mul.{v} α (@mul_zero_class.to_has_mul.{v} α (@semiring.to_mul_zero_class.{v} α (@ring.to_semiring.{v} α s))) a b)) (@has_mul.mul.{v} α (@mul_zero_class.to_has_mul.{v} α (@semiring.to_mul_zero_class.{v} α (@ring.to_semiring.{v} α s))) (@has_neg.neg.{v} α (@add_group.to_has_neg.{v} α (@add_comm_group.to_add_group.{v} α (@ring.to_add_comm_group.{v} α s))) a) b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n)
         (λ (a b : equiv.perm.{u+1} n),
            @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                   (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                      (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                         (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                   (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
                   σ))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i_1 : n),
             M
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                     (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                        (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                           (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                     (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
                     σ)
                  i_1)
               i_1)))
    (@has_neg.neg.{v} R
       (@add_group.to_has_neg.{v} R
          (@add_comm_group.to_add_group.{v} R (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@has_mul.mul.{v} R
          (@mul_zero_class.to_has_mul.{v} R
             (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ)))
          (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
             (@finset.univ.{u} n _inst_1)
             (λ (i : n),
                M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) i))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n)
         (λ (a b : equiv.perm.{u+1} n),
            @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                   (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                      (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                         (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                   (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
                   σ))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i_1 : n),
             M
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                     (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                        (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                           (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                     (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
                     σ)
                  i_1)
               i_1)))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@has_neg.neg.{v} R
          (@add_group.to_has_neg.{v} R
             (@add_comm_group.to_add_group.{v} R (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192    congr,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1543, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n)
         (λ (a b : equiv.perm.{u+1} n),
            @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                   (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                      (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                         (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                   (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
                   σ))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i_1 : n),
             M
               (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
                  (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                     (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                        (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                           (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                     (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
                     σ)
                  i_1)
               i_1)))
    (@has_mul.mul.{v} R
       (@mul_zero_class.to_has_mul.{v} R
          (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@has_neg.neg.{v} R
          (@add_group.to_has_neg.{v} R
             (@add_comm_group.to_add_group.{v} R (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
          (@coe.{1 v+1} int R
             (@coe_to_lift.{1 v+1} int R
                (@coe_base.{1 v+1} int R
                   (@int.cast_coe.{v} R
                      (@add_group.to_has_neg.{v} R
                         (@add_comm_group.to_add_group.{v} R
                            (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@mul_zero_class.to_has_zero.{v} R
                         (@semiring.to_mul_zero_class.{v} R
                            (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                      (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                      (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
             (@coe.{1 1} (@units.{0} int int.monoid) int
                (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                   (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
                (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))))
       (@finset.prod.{u v} n R (@comm_semiring.to_comm_monoid.{v} R (@comm_ring.to_comm_semiring.{v} R _inst_3))
          (@finset.univ.{u} n _inst_1)
          (λ (i : n),
             M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n)
         (λ (a b : equiv.perm.{u+1} n),
            @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@coe.{1 v+1} int R
       (@coe_to_lift.{1 v+1} int R
          (@coe_base.{1 v+1} int R
             (@int.cast_coe.{v} R
                (@add_group.to_has_neg.{v} R
                   (@add_comm_group.to_add_group.{v} R
                      (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@coe.{1 1} (@units.{0} int int.monoid) int
          (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
             (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
          (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
             (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
                σ))))
    (@has_neg.neg.{v} R
       (@add_group.to_has_neg.{v} R
          (@add_comm_group.to_add_group.{v} R (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n)
         (λ (a b : equiv.perm.{u+1} n),
            @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{(max (u+1) (v+1))} (n → R)
    (λ (i_1 : n),
       M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@has_mul.mul.{u} (equiv.perm.{u+1} n)
               (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                  (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                     (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
               (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
               σ)
            i_1)
         i_1)
    (λ (i : n), M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193    { rw [sign_mul, sign_swap i_ne_j], norm_num },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='equiv.perm.sign_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.perm.sign_swap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i_ne_j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/perm/sign.lean&#x27;, &#x27;line&#x27;: 473, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/perm/sign.lean&#x27;, &#x27;line&#x27;: 485, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_num.lean&#x27;, &#x27;line&#x27;: 472, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : fintype.{u} α] (f g : equiv.perm.{u+1} α), @eq.{1} (@units.{0} int int.monoid) (@equiv.perm.sign.{u} α (λ (a b : α), _inst_1 a b) _inst_2 (@has_mul.mul.{u} (equiv.perm.{u+1} α) (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} α) (@monoid.to_semigroup.{u} (equiv.perm.{u+1} α) (@group.to_monoid.{u} (equiv.perm.{u+1} α) (@equiv.perm.perm_group.{u} α)))) f g)) (@has_mul.mul.{0} (@units.{0} int int.monoid) (@units.has_mul.{0} int int.monoid) (@equiv.perm.sign.{u} α (λ (a b : α), _inst_1 a b) _inst_2 f) (@equiv.perm.sign.{u} α (λ (a b : α), _inst_1 a b) _inst_2 g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : decidable_eq.{u+1} α] [_inst_2 : fintype.{u} α] {x y : α}, @ne.{u+1} α x y → @eq.{1} (@units.{0} int int.monoid) (@equiv.perm.sign.{u} α (λ (a b : α), _inst_1 a b) _inst_2 (@equiv.swap.{u+1} α (λ (a b : α), _inst_1 a b) x y)) (@has_neg.neg.{0} (@units.{0} int int.monoid) (@units.has_neg.{0} int int.ring) (@has_one.one.{0} (@units.{0} int int.monoid) (@units.has_one.{0} int int.monoid)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@ne.{u+1} n i j'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Normalize numerical expressions. Supports the operations
  `+` `-` `*` `/` `^` and `%` over numerical types such as
`ℕ`, `ℤ`, `ℚ`, `ℝ`, `ℂ` and some general algebraic types,
and can prove goals of the form `A = B`, `A ≠ B`, `A &lt; B` and `A ≤ B`,
where `A` and `B` are numerical expressions.
It also has a relatively simple primality prover.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='norm_num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n)
         (λ (a b : equiv.perm.{u+1} n),
            @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@coe.{1 v+1} int R
       (@coe_to_lift.{1 v+1} int R
          (@coe_base.{1 v+1} int R
             (@int.cast_coe.{v} R
                (@add_group.to_has_neg.{v} R
                   (@add_comm_group.to_add_group.{v} R
                      (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@coe.{1 1} (@units.{0} int int.monoid) int
          (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
             (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
          (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
             (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
                σ))))
    (@has_neg.neg.{v} R
       (@add_group.to_has_neg.{v} R
          (@add_comm_group.to_add_group.{v} R (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))))

n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n)
         (λ (a b : equiv.perm.{u+1} n),
            @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{(max (u+1) (v+1))} (n → R)
    (λ (i_1 : n),
       M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@has_mul.mul.{u} (equiv.perm.{u+1} n)
               (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                  (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                     (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
               (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
               σ)
            i_1)
         i_1)
    (λ (i : n), M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n)
         (λ (a b : equiv.perm.{u+1} n),
            @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@coe.{1 v+1} int R
       (@coe_to_lift.{1 v+1} int R
          (@coe_base.{1 v+1} int R
             (@int.cast_coe.{v} R
                (@add_group.to_has_neg.{v} R
                   (@add_comm_group.to_add_group.{v} R
                      (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@coe.{1 1} (@units.{0} int int.monoid) int
          (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
             (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
          (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
             (@has_mul.mul.{u} (equiv.perm.{u+1} n)
                (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                   (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                      (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
                (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
                σ))))
    (@has_neg.neg.{v} R
       (@add_group.to_has_neg.{v} R
          (@add_comm_group.to_add_group.{v} R (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n)
         (λ (a b : equiv.perm.{u+1} n),
            @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@coe.{1 v+1} int R
       (@coe_to_lift.{1 v+1} int R
          (@coe_base.{1 v+1} int R
             (@int.cast_coe.{v} R
                (@add_group.to_has_neg.{v} R
                   (@add_comm_group.to_add_group.{v} R
                      (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@coe.{1 1} (@units.{0} int int.monoid) int
          (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
             (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
          (@has_mul.mul.{0} (@units.{0} int int.monoid) (@units.has_mul.{0} int int.monoid)
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1
                (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ))))
    (@has_neg.neg.{v} R
       (@add_group.to_has_neg.{v} R
          (@add_comm_group.to_add_group.{v} R (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n)
         (λ (a b : equiv.perm.{u+1} n),
            @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{v+1} R
    (@coe.{1 v+1} int R
       (@coe_to_lift.{1 v+1} int R
          (@coe_base.{1 v+1} int R
             (@int.cast_coe.{v} R
                (@add_group.to_has_neg.{v} R
                   (@add_comm_group.to_add_group.{v} R
                      (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@mul_zero_class.to_has_zero.{v} R
                   (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
       (@coe.{1 1} (@units.{0} int int.monoid) int
          (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
             (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
          (@has_mul.mul.{0} (@units.{0} int int.monoid) (@units.has_mul.{0} int int.monoid)
             (@has_neg.neg.{0} (@units.{0} int int.monoid) (@units.has_neg.{0} int int.ring)
                (@has_one.one.{0} (@units.{0} int int.monoid) (@units.has_one.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) _inst_1 σ))))
    (@has_neg.neg.{v} R
       (@add_group.to_has_neg.{v} R
          (@add_comm_group.to_add_group.{v} R (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
       (@coe.{1 v+1} int R
          (@coe_to_lift.{1 v+1} int R
             (@coe_base.{1 v+1} int R
                (@int.cast_coe.{v} R
                   (@add_group.to_has_neg.{v} R
                      (@add_comm_group.to_add_group.{v} R
                         (@ring.to_add_comm_group.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@mul_zero_class.to_has_zero.{v} R
                      (@semiring.to_mul_zero_class.{v} R (@ring.to_semiring.{v} R (@comm_ring.to_ring.{v} R _inst_3))))
                   (@monoid.to_has_one.{v} R (@ring.to_monoid.{v} R (@comm_ring.to_ring.{v} R _inst_3)))
                   (@distrib.to_has_add.{v} R (@ring.to_distrib.{v} R (@comm_ring.to_ring.{v} R _inst_3))))))
          (@coe.{1 1} (@units.{0} int int.monoid) int
             (@coe_to_lift.{1 1} (@units.{0} int int.monoid) int
                (@coe_base.{1 1} (@units.{0} int int.monoid) int (@units.has_coe.{0} int int.monoid)))
             (@equiv.perm.sign.{u} n (λ (a b : n), _inst_2 a b) _inst_1 σ))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n)
         (λ (a b : equiv.perm.{u+1} n),
            @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{(max (u+1) (v+1))} (n → R)
    (λ (i_1 : n),
       M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@has_mul.mul.{u} (equiv.perm.{u+1} n)
               (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                  (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                     (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
               (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
               σ)
            i_1)
         i_1)
    (λ (i : n), M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194    ext j, rw [mul_apply, swap_invariant]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='equiv.perm.mul_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='swap_invariant'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 169, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (f g : equiv.perm.{u+1} α) (x : α), @eq.{u+1} α (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} α) (@equiv.has_coe_to_fun.{u+1 u+1} α α) (@has_mul.mul.{u} (equiv.perm.{u+1} α) (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} α) (@monoid.to_semigroup.{u} (equiv.perm.{u+1} α) (@group.to_monoid.{u} (equiv.perm.{u+1} α) (@equiv.perm.perm_group.{u} α)))) f g) x) (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} α) (@equiv.has_coe_to_fun.{u+1 u+1} α α) f (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} α) (@equiv.has_coe_to_fun.{u+1 u+1} α α) g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (k : n), @eq.{(max (u+1) (v+1))} (n → R) (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j) k)) (M k)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n)
         (λ (a b : equiv.perm.{u+1} n),
            @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1))
⊢ @eq.{(max (u+1) (v+1))} (n → R)
    (λ (i_1 : n),
       M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@has_mul.mul.{u} (equiv.perm.{u+1} n)
               (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                  (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                     (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
               (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
               σ)
            i_1)
         i_1)
    (λ (i : n), M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ i) i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n)
         (λ (a b : equiv.perm.{u+1} n),
            @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
j : n
⊢ @eq.{v+1} R
    (M
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          (@has_mul.mul.{u} (equiv.perm.{u+1} n)
             (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                   (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
             (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
             σ)
          j)
       j)
    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ j) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n)
         (λ (a b : equiv.perm.{u+1} n),
            @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
j : n
⊢ @eq.{v+1} R
    (M
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
          (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ j))
       j)
    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ j) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='n : Type u,
_inst_1 : fintype.{u} n,
_inst_2 : decidable_eq.{u+1} n,
R : Type v,
_inst_3 : comm_ring.{v} R,
M : @matrix.{u v} n n _inst_1 _inst_1 R,
i j : n,
i_ne_j : @ne.{u+1} n i j,
hij : @eq.{(max (u+1) (v+1))} (n → R) (M i) (M j),
swap_invariant :
  ∀ (k : n),
    @eq.{(max (u+1) (v+1))} (n → R)
      (M
         (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            k))
      (M k),
this :
  ∀ (σ : equiv.perm.{u+1} n),
    @disjoint.{u} (finset.{u} (equiv.perm.{u+1} n))
      (@finset.lattice.semilattice_inf_bot.{u} (equiv.perm.{u+1} n)
         (λ (a b : equiv.perm.{u+1} n),
            @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), _inst_2 a b) a b))
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         σ)
      (@singleton.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n))
         (@finset.has_emptyc.{u} (equiv.perm.{u+1} n))
         (@finset.has_insert.{u} (equiv.perm.{u+1} n)
            (λ (a b : equiv.perm.{u+1} n),
               @fintype.decidable_eq_equiv_fintype.{u u} n n _inst_1 (λ (a b : n), (λ (a b : n), _inst_2 a b) a b) a
                 b))
         (@has_mul.mul.{u} (equiv.perm.{u+1} n)
            (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
               (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                  (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
            (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
            σ)),
σ : equiv.perm.{u+1} n,
H :
  @has_mem.mem.{u u} (equiv.perm.{u+1} n) (finset.{u} (equiv.perm.{u+1} n)) (@finset.has_mem.{u} (equiv.perm.{u+1} n))
    σ
    (@finset.univ.{u} (equiv.perm.{u+1} n)
       (@equiv.fintype.{u u} n n (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          (λ (a b : n), (λ (a b : n), _inst_2 a b) a b)
          _inst_1
          _inst_1)),
j : n
⊢ @eq.{v+1} R
    (M
       (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n)
          (@has_mul.mul.{u} (equiv.perm.{u+1} n)
             (@semigroup.to_has_mul.{u} (equiv.perm.{u+1} n)
                (@monoid.to_semigroup.{u} (equiv.perm.{u+1} n)
                   (@group.to_monoid.{u} (equiv.perm.{u+1} n) (@equiv.perm.perm_group.{u} n))))
             (@equiv.swap.{u+1} n (λ (a b : n), _inst_2 a b) i j)
             σ)
          j)
       j)
    (M (@coe_fn.{(max 1 (u+1)) u+1} (equiv.perm.{u+1} n) (@equiv.has_coe_to_fun.{u+1 u+1} n n) σ j) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197  end det_zero</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199  end matrix</code></pre>
</body>