<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Yury Kudryashov. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Yury Kudryashov</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import topology.local_extr analysis.calculus.deriv</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/deriv.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  /-! # Local extrema of smooth functions</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  ## Main definitions</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  In a real normed space `E` we define `pos_tangent_cone_at (s : set E) (x : E)`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  This would be the same as `tangent_cone_at ℝ≥0 s x` if we had a theory of normed semifields.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  This set is used in the proof of Fermat&#x27;s Theorem (see below), and can be used to formalize</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  [Lagrange multipliers](https://en.wikipedia.org/wiki/Lagrange_multiplier) and/or</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  [Karush–Kuhn–Tucker conditions](https://en.wikipedia.org/wiki/Karush–Kuhn–Tucker_conditions).</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  ## Main statements</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  For each theorem name listed below, we also prove similar theorems for `min`, `extr` (if applicable)`,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  and `(f)deriv` instead of `has_fderiv`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  * `is_local_max_on.has_fderiv_within_at_nonpos` : `f&#x27; y ≤ 0` whenever `a` is a local maximum</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25    of `f` on `s`, `f` has derivative `f&#x27;` at `a` within `s`, and `y` belongs to the positive tangent</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26    cone of `s` at `a`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  * `is_local_max_on.has_fderiv_within_at_eq_zero` : In the settings of the previous theorem, if both</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29    `y` and `-y` belong to the positive tangent cone, then `f&#x27; y = 0`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  * `is_local_max.has_fderiv_at_eq_zero` :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32    [Fermat&#x27;s Theorem](https://en.wikipedia.org/wiki/Fermat&#x27;s_theorem_(stationary_points)),</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33    the derivative of a differentiable function at a local extremum point equals zero.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  * `exists_has_deriv_at_eq_zero` :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36    [Rolle&#x27;s Theorem](https://en.wikipedia.org/wiki/Rolle&#x27;s_theorem): given a function `f` continuous</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37    on `[a, b]` and differentiable on `(a, b)`, there exists `c ∈ (a, b)` such that `f&#x27; c = 0`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  ## Implementation notes</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  For each mathematical fact we prove several versions of its formalization:</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  * for maxima and minima;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  * using `has_fderiv*`/`has_deriv*` or `fderiv*`/`deriv*`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  For the `fderiv*`/`deriv*` versions we omit the differentiability condition whenever it is possible</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  due to the fact that `fderiv` and `deriv` are defined to be zero for non-differentiable functions.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  ## References</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  * [Fermat&#x27;s Theorem](https://en.wikipedia.org/wiki/Fermat&#x27;s_theorem_(stationary_points));</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  * [Rolle&#x27;s Theorem](https://en.wikipedia.org/wiki/Rolle&#x27;s_theorem);</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  * [Tangent cone](https://en.wikipedia.org/wiki/Tangent_cone);</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  ## Tags</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  local extremum, Fermat&#x27;s Theorem, Rolle&#x27;s Theorem</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  universes u v</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  open filter set</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  open_locale topological_space classical</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  section vector_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  variables {E : Type u} [normed_group E] [normed_space ℝ E] {f : E → ℝ} {a : E}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='hn'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='normed_group'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='normed_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 600, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) h (@set_of.{0} nat (λ (x : nat), (λ (n : nat), @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) (@has_add.add.{u} E (@add_semigroup.to_has_add.{u} E (@add_monoid.to_add_semigroup.{u} E (@add_group.to_add_monoid.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))))) a (d n)) s) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type) (β : Type u) [_inst_1 : normed_field.{0} α] [_inst_2 : normed_group.{u} β], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title=' A normed group is an additive group endowed with a norm for which `dist x y = ∥x - y∥` defines
a metric space structure.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title=' A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `∥c • x∥ = ∥c∥ ∥x∥`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68    {f&#x27; : E →L[ℝ] ℝ}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='continuous_linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='continuous_linear_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/module.lean&#x27;, &#x27;line&#x27;: 134, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/module.lean&#x27;, &#x27;line&#x27;: 134, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π (R : Type) [_inst_1 : ring.{0} R] (M : Type u) [_inst_2 : topological_space.{u} M] [_inst_3 : add_comm_group.{u} M] (M₂ : Type) [_inst_4 : topological_space.{0} M₂] [_inst_5 : add_comm_group.{0} M₂] [_inst_6 : @module.{0 u} R M _inst_1 _inst_3] [_inst_7 : @module.{0 0} R M₂ _inst_1 _inst_5], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (R : Type) [_inst_1 : ring.{0} R] (M : Type u) [_inst_2 : topological_space.{u} M] [_inst_3 : add_comm_group.{u} M] (M₂ : Type) [_inst_4 : topological_space.{0} M₂] [_inst_5 : add_comm_group.{0} M₂] [_inst_6 : @module.{0 u} R M _inst_1 _inst_3] [_inst_7 : @module.{0 0} R M₂ _inst_1 _inst_5], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title=' Continuous linear maps between modules. We only put the type classes that are necessary for the
definition, although in applications `M` and `M₂` will be topological modules over the topological
ring `R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Continuous linear maps between modules. We only put the type classes that are necessary for the
definition, although in applications `M` and `M₂` will be topological modules over the topological
ring `R`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  /-- &quot;Positive&quot; tangent cone to `s` at `x`; the only difference from `tangent_cone_at`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  is that we require `c n → ∞` instead of `∥c n∥ → ∞`. One can think about `pos_tangent_cone_at`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  as `tangent_cone_at nnreal` but we have no theory of normed semifields yet. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  def pos_tangent_cone_at (s : set E) (x : E) : set E :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  {y : E | ∃(c : ℕ → ℝ) (d : ℕ → E), (∀ᶠ n in at_top, x + d n ∈ s) ∧</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.eventually'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.eventually'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='filter.eventually'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 554, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 554, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1645, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 554, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, (α → Prop) → filter.{0} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, (α → Prop) → filter.{0} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → filter.{0} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title=' `f.eventually p` or `∀ᶠ x in f, p x` mean that `{x | p x} ∈ f`. E.g., `∀ᶠ x in at_top, p x`
means that `p` holds true for sufficiently large `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' `f.eventually p` or `∀ᶠ x in f, p x` mean that `{x | p x} ∈ f`. E.g., `∀ᶠ x in at_top, p x`
means that `p` holds true for sufficiently large `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`at_top` is the filter representing the limit `→ ∞` on an ordered set.
 It is generated by the collection of up-sets `{b | a ≤ b}`.
 (The preorder need not have a top element for this to be well defined,
 and indeed is trivial when a top element exists.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `f.eventually p` or `∀ᶠ x in f, p x` mean that `{x | p x} ∈ f`. E.g., `∀ᶠ x in at_top, p x`
means that `p` holds true for sufficiently large `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75    (tendsto c at_top at_top) ∧ (tendsto (λn, c n • d n) at_top (𝓝 y))}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_scalar.smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1645, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1645, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1645, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{u} α → filter.{v} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β) → filter.{u} α → filter.{v} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} {γ : Type u} [c : has_scalar.{0 u} α γ], α → γ → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`at_top` is the filter representing the limit `→ ∞` on an ordered set.
 It is generated by the collection of up-sets `{b | a ≤ b}`.
 (The preorder need not have a top element for this to be well defined,
 and indeed is trivial when a top element exists.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`at_top` is the filter representing the limit `→ ∞` on an ordered set.
 It is generated by the collection of up-sets `{b | a ≤ b}`.
 (The preorder need not have a top element for this to be well defined,
 and indeed is trivial when a top element exists.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`at_top` is the filter representing the limit `→ ∞` on an ordered set.
 It is generated by the collection of up-sets `{b | a ≤ b}`.
 (The preorder need not have a top element for this to be well defined,
 and indeed is trivial when a top element exists.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  lemma pos_tangent_cone_at_mono : monotone (λ s, pos_tangent_cone_at s a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='monotone'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='pos_tangent_cone_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : preorder.{u} α] [_inst_2 : preorder.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1], set.{u} E → E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='A function between preorders is monotone if
 `a ≤ b` implies `f a ≤ f b`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title=' &quot;Positive&quot; tangent cone to `s` at `x`; the only difference from `tangent_cone_at`
is that we require `c n → ∞` instead of `∥c n∥ → ∞`. One can think about `pos_tangent_cone_at`
as `tangent_cone_at nnreal` but we have no theory of normed semifields yet.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
a : E
⊢ @monotone.{u u} (set.{u} E) (set.{u} E)
    (@partial_order.to_preorder.{u} (set.{u} E)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} E)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} E)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} E) (@set.lattice_set.{u} E)))))
    (@partial_order.to_preorder.{u} (set.{u} E)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} E)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} E)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} E) (@set.lattice_set.{u} E)))))
    (λ (s : set.{u} E), @pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79    rintros s t hst y ⟨c, d, hd, hc, hcd⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
a : E
⊢ @monotone.{u u} (set.{u} E) (set.{u} E)
    (@partial_order.to_preorder.{u} (set.{u} E)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} E)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} E)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} E) (@set.lattice_set.{u} E)))))
    (@partial_order.to_preorder.{u} (set.{u} E)
       (@lattice.order_bot.to_partial_order.{u} (set.{u} E)
          (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} E)
             (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} E) (@set.lattice_set.{u} E)))))
    (λ (s : set.{u} E), @pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
a : E,
s t : set.{u} E,
hst :
  @has_le.le.{u} (set.{u} E)
    (@preorder.to_has_le.{u} (set.{u} E)
       (@partial_order.to_preorder.{u} (set.{u} E)
          (@lattice.order_bot.to_partial_order.{u} (set.{u} E)
             (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} E)
                (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} E) (@set.lattice_set.{u} E))))))
    s
    t,
y : E,
c : nat → real,
d : nat → E,
hd :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
         (@has_add.add.{u} E
            (@add_semigroup.to_has_add.{u} E
               (@add_monoid.to_add_semigroup.{u} E
                  (@add_group.to_add_monoid.{u} E
                     (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
            a
            (d n))
         s)
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y)
⊢ @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y
    ((λ (s : set.{u} E), @pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80    exact ⟨c, d, mem_sets_of_superset hd $ λ h hn, hst hn, hc, hcd⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.mem_sets_of_superset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='hst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hcd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {f : filter.{0} α} {x y : set.{0} α}, @has_mem.mem.{0 0} (set.{0} α) (filter.{0} α) (@filter.has_mem.{0} α) x f → @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) x y → @has_mem.mem.{0 0} (set.{0} α) (filter.{0} α) (@filter.has_mem.{0} α) y f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@filter.eventually.{0} nat (λ (n : nat), @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) (@has_add.add.{u} E (@add_semigroup.to_has_add.{u} E (@add_monoid.to_add_semigroup.{u} E (@add_group.to_add_monoid.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))))) a (d n)) s) (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u} (set.{u} E) (@preorder.to_has_le.{u} (set.{u} E) (@partial_order.to_preorder.{u} (set.{u} E) (@lattice.order_bot.to_partial_order.{u} (set.{u} E) (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} E) (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} E) (@set.lattice_set.{u} E)))))) s t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@filter.tendsto.{0 0} nat real c (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))) (@filter.at_top.{0} real real.preorder)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@filter.tendsto.{0 u} nat E (λ (n : nat), @has_scalar.smul.{0 u} real E (@mul_action.to_has_scalar.{0 u} real E real.monoid (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid (@add_group.to_add_monoid.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))) (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)) (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1) (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2))))) (c n) (d n)) (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))) (@nhds.{u} E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
a : E,
s t : set.{u} E,
hst :
  @has_le.le.{u} (set.{u} E)
    (@preorder.to_has_le.{u} (set.{u} E)
       (@partial_order.to_preorder.{u} (set.{u} E)
          (@lattice.order_bot.to_partial_order.{u} (set.{u} E)
             (@lattice.bounded_lattice.to_order_bot.{u} (set.{u} E)
                (@lattice.complete_lattice.to_bounded_lattice.{u} (set.{u} E) (@set.lattice_set.{u} E))))))
    s
    t,
y : E,
c : nat → real,
d : nat → E,
hd :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
         (@has_add.add.{u} E
            (@add_semigroup.to_has_add.{u} E
               (@add_monoid.to_add_semigroup.{u} E
                  (@add_group.to_add_monoid.{u} E
                     (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
            a
            (d n))
         s)
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y)
⊢ @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y
    ((λ (s : set.{u} E), @pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  lemma mem_pos_tangent_cone_at_of_segment_subset {s : set E} {x y : E} (h : segment x y ⊆ s) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='segment'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {E : Type u} [_inst_1 : add_comm_group.{u} E] [_inst_2 : @vector_space.{0 u} real E real.discrete_field _inst_1], E → E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                           </code><font color='orange'><a title='Segments in a vector space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84    y - x ∈ pos_tangent_cone_at s x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_sub.sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pos_tangent_cone_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 315, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_sub.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1], set.{u} E → E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title=' &quot;Positive&quot; tangent cone to `s` at `x`; the only difference from `tangent_cone_at`
is that we require `c n → ∞` instead of `∥c n∥ → ∞`. One can think about `pos_tangent_cone_at`
as `tangent_cone_at nnreal` but we have no theory of normed semifields yet.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86    let c := λn:ℕ, (2:ℝ)^n,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87    let d := λn:ℕ, (c n)⁻¹ • (y-x),</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88    refine ⟨c, d, filter.univ_mem_sets&#x27; (λn, h _), _, _⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E) (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1) (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) x y) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
    (@has_sub.sub.{u} E
       (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
       y
       x)
    (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
    (@has_add.add.{u} E
       (@add_semigroup.to_has_add.{u} E
          (@add_monoid.to_add_semigroup.{u} E
             (@add_group.to_add_monoid.{u} E
                (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
       x
       (d n))
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder)

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_sub.sub.{u} E
          (@add_group_has_sub.{u} E
             (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
          y
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89    show x + d n ∈ segment x y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='segment'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 62, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {E : Type u} [_inst_1 : add_comm_group.{u} E] [_inst_2 : @vector_space.{0 u} real E real.discrete_field _inst_1], E → E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Segments in a vector space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
    (@has_add.add.{u} E
       (@add_semigroup.to_has_add.{u} E
          (@add_monoid.to_add_semigroup.{u} E
             (@add_group.to_add_monoid.{u} E
                (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
       x
       (d n))
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder)

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_sub.sub.{u} E
          (@add_group_has_sub.{u} E
             (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
          y
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90    { rw segment_eq_image,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='segment_eq_image'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/convex/basic.lean&#x27;, &#x27;line&#x27;: 82, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {E : Type u} [_inst_1 : add_comm_group.{u} E] [_inst_2 : @vector_space.{0 u} real E real.discrete_field _inst_1] (x y : E), @eq.{(max (u+1) 1)} (set.{u} E) (@segment.{u} E _inst_1 _inst_2 x y) (@set.image.{0 u} real E (λ (θ : real), @has_add.add.{u} E (@add_semigroup.to_has_add.{u} E (@add_monoid.to_add_semigroup.{u} E (@add_group.to_add_monoid.{u} E (@add_comm_group.to_add_group.{u} E _inst_1)))) (@has_scalar.smul.{0 u} real E (@mul_action.to_has_scalar.{0 u} real E real.monoid (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid (@add_group.to_add_monoid.{u} E (@add_comm_group.to_add_group.{u} E _inst_1)) (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring (@add_comm_group.to_add_comm_monoid.{u} E _inst_1) (@module.to_semimodule.{0 u} real E real.ring _inst_1 _inst_2)))) (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))) θ) x) (@has_scalar.smul.{0 u} real E (@mul_action.to_has_scalar.{0 u} real E real.monoid (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid (@add_group.to_add_monoid.{u} E (@add_comm_group.to_add_group.{u} E _inst_1)) (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring (@add_comm_group.to_add_comm_monoid.{u} E _inst_1) (@module.to_semimodule.{0 u} real E real.ring _inst_1 _inst_2)))) θ y)) (@set.Icc.{0} real real.preorder (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
    (@has_add.add.{u} E
       (@add_semigroup.to_has_add.{u} E
          (@add_monoid.to_add_semigroup.{u} E
             (@add_group.to_add_monoid.{u} E
                (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
       x
       (d n))
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder)

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_sub.sub.{u} E
          (@add_group_has_sub.{u} E
             (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
          y
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
    (@has_add.add.{u} E
       (@add_semigroup.to_has_add.{u} E
          (@add_monoid.to_add_semigroup.{u} E
             (@add_group.to_add_monoid.{u} E
                (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
       x
       (d n))
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
    (@has_add.add.{u} E
       (@add_semigroup.to_has_add.{u} E
          (@add_monoid.to_add_semigroup.{u} E
             (@add_group.to_add_monoid.{u} E
                (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
       x
       (d n))
    (@set.image.{0 u} real E
       (λ (θ : real),
          @has_add.add.{u} E
            (@add_semigroup.to_has_add.{u} E
               (@add_monoid.to_add_semigroup.{u} E
                  (@add_group.to_add_monoid.{u} E
                     (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
            (@has_scalar.smul.{0 u} real E
               (@mul_action.to_has_scalar.{0 u} real E real.monoid
                  (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
                     (@add_group.to_add_monoid.{u} E
                        (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
                     (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                        (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                        (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                           (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
               (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
                  (@has_one.one.{0} real
                     (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
                  θ)
               x)
            (@has_scalar.smul.{0 u} real E
               (@mul_action.to_has_scalar.{0 u} real E real.monoid
                  (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
                     (@add_group.to_add_monoid.{u} E
                        (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
                     (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                        (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                        (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                           (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
               θ
               y))
       (@set.Icc.{0} real real.preorder
          (@has_zero.zero.{0} real
             (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91      refine ⟨(c n)⁻¹, ⟨_, _⟩, _⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
    (@has_add.add.{u} E
       (@add_semigroup.to_has_add.{u} E
          (@add_monoid.to_add_semigroup.{u} E
             (@add_group.to_add_monoid.{u} E
                (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
       x
       (d n))
    (@set.image.{0 u} real E
       (λ (θ : real),
          @has_add.add.{u} E
            (@add_semigroup.to_has_add.{u} E
               (@add_monoid.to_add_semigroup.{u} E
                  (@add_group.to_add_monoid.{u} E
                     (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
            (@has_scalar.smul.{0 u} real E
               (@mul_action.to_has_scalar.{0 u} real E real.monoid
                  (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
                     (@add_group.to_add_monoid.{u} E
                        (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
                     (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                        (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                        (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                           (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
               (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
                  (@has_one.one.{0} real
                     (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
                  θ)
               x)
            (@has_scalar.smul.{0 u} real E
               (@mul_action.to_has_scalar.{0 u} real E real.monoid
                  (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
                     (@add_group.to_add_monoid.{u} E
                        (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
                     (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                        (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                        (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                           (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
               θ
               y))
       (@set.Icc.{0} real real.preorder
          (@has_zero.zero.{0} real
             (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
          (@has_one.one.{0} real
             (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder)
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @eq.{u+1} E
    ((λ (θ : real),
        @has_add.add.{u} E
          (@add_semigroup.to_has_add.{u} E
             (@add_monoid.to_add_semigroup.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
          (@has_scalar.smul.{0 u} real E
             (@mul_action.to_has_scalar.{0 u} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
                   (@add_group.to_add_monoid.{u} E
                      (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                      (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                         (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
                (@has_one.one.{0} real
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
                θ)
             x)
          (@has_scalar.smul.{0 u} real E
             (@mul_action.to_has_scalar.{0 u} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
                   (@add_group.to_add_monoid.{u} E
                      (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                      (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                         (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
             θ
             y))
       (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n)))
    (@has_add.add.{u} E
       (@add_semigroup.to_has_add.{u} E
          (@add_monoid.to_add_semigroup.{u} E
             (@add_group.to_add_monoid.{u} E
                (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
       x
       (d n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92      { rw inv_nonneg, apply pow_nonneg, norm_num },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='inv_nonneg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='pow_nonneg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_field.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 564, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_num.lean&#x27;, &#x27;line&#x27;: 472, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : discrete_linear_ordered_field.{0} α] {a : α}, iff (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@ordered_ring.to_ordered_semiring.{0} α (@linear_ordered_ring.to_ordered_ring.{0} α (@linear_ordered_field.to_linear_ordered_ring.{0} α (@discrete_linear_ordered_field.to_linear_ordered_field.{0} α _inst_1))))))))) (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@domain.to_no_zero_divisors.{0} α (@division_ring.to_domain.{0} α (@field.to_division_ring.{0} α (@linear_ordered_field.to_field.{0} α (@discrete_linear_ordered_field.to_linear_ordered_field.{0} α _inst_1))))))) (@has_inv.inv.{0} α (@division_ring.to_has_inv.{0} α (@field.to_division_ring.{0} α (@linear_ordered_field.to_field.{0} α (@discrete_linear_ordered_field.to_linear_ordered_field.{0} α _inst_1)))) a)) (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@ordered_ring.to_ordered_semiring.{0} α (@linear_ordered_ring.to_ordered_ring.{0} α (@linear_ordered_field.to_linear_ordered_ring.{0} α (@discrete_linear_ordered_field.to_linear_ordered_field.{0} α _inst_1))))))))) (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@domain.to_no_zero_divisors.{0} α (@division_ring.to_domain.{0} α (@field.to_division_ring.{0} α (@linear_ordered_field.to_field.{0} α (@discrete_linear_ordered_field.to_linear_ordered_field.{0} α _inst_1))))))) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_ordered_semiring.{0} α] {a : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1)))))) (@has_zero.zero.{0} α (@mul_zero_class.to_has_zero.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1))))) a → ∀ (n : nat), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1)))))) (@has_zero.zero.{0} α (@mul_zero_class.to_has_zero.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1))))) (@has_pow.pow.{0 0} α nat (@monoid.has_pow.{0} α (@semiring.to_monoid.{0} α (@ordered_semiring.to_semiring.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1)))) a n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title=' Normalize numerical expressions. Supports the operations
  `+` `-` `*` `/` `^` and `%` over numerical types such as
`ℕ`, `ℤ`, `ℚ`, `ℝ`, `ℂ` and some general algebraic types,
and can prove goals of the form `A = B`, `A ≠ B`, `A &lt; B` and `A ≤ B`,
where `A` and `B` are numerical expressions.
It also has a relatively simple primality prover.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='norm_num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder)
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @eq.{u+1} E
    ((λ (θ : real),
        @has_add.add.{u} E
          (@add_semigroup.to_has_add.{u} E
             (@add_monoid.to_add_semigroup.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
          (@has_scalar.smul.{0 u} real E
             (@mul_action.to_has_scalar.{0 u} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
                   (@add_group.to_add_monoid.{u} E
                      (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                      (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                         (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
                (@has_one.one.{0} real
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
                θ)
             x)
          (@has_scalar.smul.{0 u} real E
             (@mul_action.to_has_scalar.{0 u} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
                   (@add_group.to_add_monoid.{u} E
                      (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                      (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                         (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
             θ
             y))
       (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n)))
    (@has_add.add.{u} E
       (@add_semigroup.to_has_add.{u} E
          (@add_monoid.to_add_semigroup.{u} E
             (@add_group.to_add_monoid.{u} E
                (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
       x
       (d n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_monoid.to_partial_order.{0} real
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                   (@ordered_ring.to_ordered_semiring.{0} real
                      (@linear_ordered_ring.to_ordered_ring.{0} real
                         (@linear_ordered_field.to_linear_ordered_ring.{0} real
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                               real.discrete_linear_ordered_field)))))))))
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real
          (@domain.to_no_zero_divisors.{0} real
             (@division_ring.to_domain.{0} real
                (@field.to_division_ring.{0} real
                   (@linear_ordered_field.to_field.{0} real
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                         real.discrete_linear_ordered_field)))))))
    (c n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_monoid.to_partial_order.{0} real
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                   (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring))))))
    (@has_zero.zero.{0} real
       (@mul_zero_class.to_has_zero.{0} real
          (@semiring.to_mul_zero_class.{0} real
             (@ordered_semiring.to_semiring.{0} real
                (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
    (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder)
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @eq.{u+1} E
    ((λ (θ : real),
        @has_add.add.{u} E
          (@add_semigroup.to_has_add.{u} E
             (@add_monoid.to_add_semigroup.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
          (@has_scalar.smul.{0 u} real E
             (@mul_action.to_has_scalar.{0 u} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
                   (@add_group.to_add_monoid.{u} E
                      (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                      (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                         (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
                (@has_one.one.{0} real
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
                θ)
             x)
          (@has_scalar.smul.{0 u} real E
             (@mul_action.to_has_scalar.{0 u} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
                   (@add_group.to_add_monoid.{u} E
                      (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                      (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                         (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
             θ
             y))
       (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n)))
    (@has_add.add.{u} E
       (@add_semigroup.to_has_add.{u} E
          (@add_monoid.to_add_semigroup.{u} E
             (@add_group.to_add_monoid.{u} E
                (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
       x
       (d n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93      { apply inv_le_one, apply one_le_pow_of_one_le, norm_num },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='inv_le_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='one_le_pow_of_one_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_field.lean&#x27;, &#x27;line&#x27;: 161, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 586, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_num.lean&#x27;, &#x27;line&#x27;: 472, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_ordered_field.{0} α] {a : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@ordered_ring.to_ordered_semiring.{0} α (@linear_ordered_ring.to_ordered_ring.{0} α (@linear_ordered_field.to_linear_ordered_ring.{0} α _inst_1)))))))) (@has_one.one.{0} α (@zero_ne_one_class.to_has_one.{0} α (@domain.to_zero_ne_one_class.{0} α (@division_ring.to_domain.{0} α (@field.to_division_ring.{0} α (@linear_ordered_field.to_field.{0} α _inst_1)))))) a → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@ordered_ring.to_ordered_semiring.{0} α (@linear_ordered_ring.to_ordered_ring.{0} α (@linear_ordered_field.to_linear_ordered_ring.{0} α _inst_1)))))))) (@has_inv.inv.{0} α (@division_ring.to_has_inv.{0} α (@field.to_division_ring.{0} α (@linear_ordered_field.to_field.{0} α _inst_1))) a) (@has_one.one.{0} α (@zero_ne_one_class.to_has_one.{0} α (@domain.to_zero_ne_one_class.{0} α (@division_ring.to_domain.{0} α (@field.to_division_ring.{0} α (@linear_ordered_field.to_field.{0} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_ordered_semiring.{0} α] {a : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1)))))) (@has_one.one.{0} α (@monoid.to_has_one.{0} α (@semiring.to_monoid.{0} α (@ordered_semiring.to_semiring.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1))))) a → ∀ (n : nat), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1)))))) (@has_one.one.{0} α (@monoid.to_has_one.{0} α (@semiring.to_monoid.{0} α (@ordered_semiring.to_semiring.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1))))) (@has_pow.pow.{0 0} α nat (@monoid.has_pow.{0} α (@semiring.to_monoid.{0} α (@ordered_semiring.to_semiring.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1)))) a n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title=' Normalize numerical expressions. Supports the operations
  `+` `-` `*` `/` `^` and `%` over numerical types such as
`ℕ`, `ℤ`, `ℚ`, `ℝ`, `ℂ` and some general algebraic types,
and can prove goals of the form `A = B`, `A ≠ B`, `A &lt; B` and `A ≤ B`,
where `A` and `B` are numerical expressions.
It also has a relatively simple primality prover.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='norm_num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder)
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @eq.{u+1} E
    ((λ (θ : real),
        @has_add.add.{u} E
          (@add_semigroup.to_has_add.{u} E
             (@add_monoid.to_add_semigroup.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
          (@has_scalar.smul.{0 u} real E
             (@mul_action.to_has_scalar.{0 u} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
                   (@add_group.to_add_monoid.{u} E
                      (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                      (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                         (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
                (@has_one.one.{0} real
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
                θ)
             x)
          (@has_scalar.smul.{0 u} real E
             (@mul_action.to_has_scalar.{0 u} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
                   (@add_group.to_add_monoid.{u} E
                      (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                      (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                         (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
             θ
             y))
       (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n)))
    (@has_add.add.{u} E
       (@add_semigroup.to_has_add.{u} E
          (@add_monoid.to_add_semigroup.{u} E
             (@add_group.to_add_monoid.{u} E
                (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
       x
       (d n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder)
    (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
    (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_monoid.to_partial_order.{0} real
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                   (@ordered_ring.to_ordered_semiring.{0} real
                      (@linear_ordered_ring.to_ordered_ring.{0} real
                         (@linear_ordered_field.to_linear_ordered_ring.{0} real real.linear_ordered_field))))))))
    (@has_one.one.{0} real
       (@zero_ne_one_class.to_has_one.{0} real
          (@domain.to_zero_ne_one_class.{0} real
             (@division_ring.to_domain.{0} real
                (@field.to_division_ring.{0} real
                   (@linear_ordered_field.to_field.{0} real real.linear_ordered_field))))))
    (c n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_monoid.to_partial_order.{0} real
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                   (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring))))))
    (@has_one.one.{0} real
       (@monoid.to_has_one.{0} real
          (@semiring.to_monoid.{0} real
             (@ordered_semiring.to_semiring.{0} real
                (@linear_ordered_semiring.to_ordered_semiring.{0} real real.linear_ordered_semiring)))))
    (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @eq.{u+1} E
    ((λ (θ : real),
        @has_add.add.{u} E
          (@add_semigroup.to_has_add.{u} E
             (@add_monoid.to_add_semigroup.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
          (@has_scalar.smul.{0 u} real E
             (@mul_action.to_has_scalar.{0 u} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
                   (@add_group.to_add_monoid.{u} E
                      (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                      (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                         (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
                (@has_one.one.{0} real
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
                θ)
             x)
          (@has_scalar.smul.{0 u} real E
             (@mul_action.to_has_scalar.{0 u} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
                   (@add_group.to_add_monoid.{u} E
                      (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                      (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                         (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
             θ
             y))
       (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n)))
    (@has_add.add.{u} E
       (@add_semigroup.to_has_add.{u} E
          (@add_monoid.to_add_semigroup.{u} E
             (@add_group.to_add_monoid.{u} E
                (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
       x
       (d n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94      { simp only [d, sub_smul, smul_sub, one_smul], abel } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='sub_smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='smul_sub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='one_smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 115, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/abel.lean&#x27;, &#x27;line&#x27;: 321, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : ring.{?l_1} α] [_inst_2 : add_comm_group.{?l_2} β] [_inst_3 : @module.{?l_1 ?l_2} α β _inst_1 _inst_2] (r s : α) (y : β), @eq.{?l_2+1} β (@has_scalar.smul.{?l_1 ?l_2} α β (@mul_action.to_has_scalar.{?l_1 ?l_2} α β (@ring.to_monoid.{?l_1} α _inst_1) (@distrib_mul_action.to_mul_action.{?l_1 ?l_2} α β (@ring.to_monoid.{?l_1} α _inst_1) (@add_group.to_add_monoid.{?l_2} β (@add_comm_group.to_add_group.{?l_2} β _inst_2)) (@semimodule.to_distrib_mul_action.{?l_1 ?l_2} α β (@ring.to_semiring.{?l_1} α _inst_1) (@add_comm_group.to_add_comm_monoid.{?l_2} β _inst_2) (@module.to_semimodule.{?l_1 ?l_2} α β _inst_1 _inst_2 _inst_3)))) (@has_sub.sub.{?l_1} α (@add_group_has_sub.{?l_1} α (@add_comm_group.to_add_group.{?l_1} α (@ring.to_add_comm_group.{?l_1} α _inst_1))) r s) y) (@has_sub.sub.{?l_2} β (@add_group_has_sub.{?l_2} β (@add_comm_group.to_add_group.{?l_2} β _inst_2)) (@has_scalar.smul.{?l_1 ?l_2} α β (@mul_action.to_has_scalar.{?l_1 ?l_2} α β (@ring.to_monoid.{?l_1} α _inst_1) (@distrib_mul_action.to_mul_action.{?l_1 ?l_2} α β (@ring.to_monoid.{?l_1} α _inst_1) (@add_group.to_add_monoid.{?l_2} β (@add_comm_group.to_add_group.{?l_2} β _inst_2)) (@semimodule.to_distrib_mul_action.{?l_1 ?l_2} α β (@ring.to_semiring.{?l_1} α _inst_1) (@add_comm_group.to_add_comm_monoid.{?l_2} β _inst_2) (@module.to_semimodule.{?l_1 ?l_2} α β _inst_1 _inst_2 _inst_3)))) r y) (@has_scalar.smul.{?l_1 ?l_2} α β (@mul_action.to_has_scalar.{?l_1 ?l_2} α β (@ring.to_monoid.{?l_1} α _inst_1) (@distrib_mul_action.to_mul_action.{?l_1 ?l_2} α β (@ring.to_monoid.{?l_1} α _inst_1) (@add_group.to_add_monoid.{?l_2} β (@add_comm_group.to_add_group.{?l_2} β _inst_2)) (@semimodule.to_distrib_mul_action.{?l_1 ?l_2} α β (@ring.to_semiring.{?l_1} α _inst_1) (@add_comm_group.to_add_comm_monoid.{?l_2} β _inst_2) (@module.to_semimodule.{?l_1 ?l_2} α β _inst_1 _inst_2 _inst_3)))) s y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : ring.{?l_1} α] [_inst_2 : add_comm_group.{?l_2} β] [_inst_3 : @module.{?l_1 ?l_2} α β _inst_1 _inst_2] (r : α) (x y : β), @eq.{?l_2+1} β (@has_scalar.smul.{?l_1 ?l_2} α β (@mul_action.to_has_scalar.{?l_1 ?l_2} α β (@ring.to_monoid.{?l_1} α _inst_1) (@distrib_mul_action.to_mul_action.{?l_1 ?l_2} α β (@ring.to_monoid.{?l_1} α _inst_1) (@add_group.to_add_monoid.{?l_2} β (@add_comm_group.to_add_group.{?l_2} β _inst_2)) (@semimodule.to_distrib_mul_action.{?l_1 ?l_2} α β (@ring.to_semiring.{?l_1} α _inst_1) (@add_comm_group.to_add_comm_monoid.{?l_2} β _inst_2) (@module.to_semimodule.{?l_1 ?l_2} α β _inst_1 _inst_2 _inst_3)))) r (@has_sub.sub.{?l_2} β (@add_group_has_sub.{?l_2} β (@add_comm_group.to_add_group.{?l_2} β _inst_2)) x y)) (@has_sub.sub.{?l_2} β (@add_group_has_sub.{?l_2} β (@add_comm_group.to_add_group.{?l_2} β _inst_2)) (@has_scalar.smul.{?l_1 ?l_2} α β (@mul_action.to_has_scalar.{?l_1 ?l_2} α β (@ring.to_monoid.{?l_1} α _inst_1) (@distrib_mul_action.to_mul_action.{?l_1 ?l_2} α β (@ring.to_monoid.{?l_1} α _inst_1) (@add_group.to_add_monoid.{?l_2} β (@add_comm_group.to_add_group.{?l_2} β _inst_2)) (@semimodule.to_distrib_mul_action.{?l_1 ?l_2} α β (@ring.to_semiring.{?l_1} α _inst_1) (@add_comm_group.to_add_comm_monoid.{?l_2} β _inst_2) (@module.to_semimodule.{?l_1 ?l_2} α β _inst_1 _inst_2 _inst_3)))) r x) (@has_scalar.smul.{?l_1 ?l_2} α β (@mul_action.to_has_scalar.{?l_1 ?l_2} α β (@ring.to_monoid.{?l_1} α _inst_1) (@distrib_mul_action.to_mul_action.{?l_1 ?l_2} α β (@ring.to_monoid.{?l_1} α _inst_1) (@add_group.to_add_monoid.{?l_2} β (@add_comm_group.to_add_group.{?l_2} β _inst_2)) (@semimodule.to_distrib_mul_action.{?l_1 ?l_2} α β (@ring.to_semiring.{?l_1} α _inst_1) (@add_comm_group.to_add_comm_monoid.{?l_2} β _inst_2) (@module.to_semimodule.{?l_1 ?l_2} α β _inst_1 _inst_2 _inst_3)))) r y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (α : Type ?l_1) {β : Type ?l_2} [_inst_1 : monoid.{?l_1} α] [_inst_2 : @mul_action.{?l_1 ?l_2} α β _inst_1] (b : β), @eq.{?l_2+1} β (@has_scalar.smul.{?l_1 ?l_2} α β (@mul_action.to_has_scalar.{?l_1 ?l_2} α β _inst_1 _inst_2) (@has_one.one.{?l_1} α (@monoid.to_has_one.{?l_1} α _inst_1)) b) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.abel.normalize_mode (λ (a : tactic.abel.normalize_mode), tactic.abel.normalize_mode.has_reflect a) tactic.interactive.abel.mode → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Tactic for solving equations in the language of
 *additive*, commutative monoids and groups.
 Attempts to prove the goal outright if there is no `at`
 specifier and the target is an equality, but if this
 fails it falls back to rewriting all monoid expressions
 into a normal form.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='abel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(raw|term)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @eq.{u+1} E
    ((λ (θ : real),
        @has_add.add.{u} E
          (@add_semigroup.to_has_add.{u} E
             (@add_monoid.to_add_semigroup.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
          (@has_scalar.smul.{0 u} real E
             (@mul_action.to_has_scalar.{0 u} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
                   (@add_group.to_add_monoid.{u} E
                      (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                      (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                         (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
             (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group)
                (@has_one.one.{0} real
                   (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain)))
                θ)
             x)
          (@has_scalar.smul.{0 u} real E
             (@mul_action.to_has_scalar.{0 u} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
                   (@add_group.to_add_monoid.{u} E
                      (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                      (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                         (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
             θ
             y))
       (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n)))
    (@has_add.add.{u} E
       (@add_semigroup.to_has_add.{u} E
          (@add_monoid.to_add_semigroup.{u} E
             (@add_group.to_add_monoid.{u} E
                (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
       x
       (d n))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @eq.{u+1} E
    (@has_add.add.{u} E
       (@add_semigroup.to_has_add.{u} E
          (@add_monoid.to_add_semigroup.{u} E
             (@add_group.to_add_monoid.{u} E
                (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
       (@has_sub.sub.{u} E
          (@add_group_has_sub.{u} E
             (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
          x
          (@has_scalar.smul.{0 u} real E
             (@mul_action.to_has_scalar.{0 u} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
                   (@add_group.to_add_monoid.{u} E
                      (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                      (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                         (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
             (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
             x))
       (@has_scalar.smul.{0 u} real E
          (@mul_action.to_has_scalar.{0 u} real E real.monoid
             (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
                (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                   (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                   (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                      (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
          (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
          y))
    (@has_add.add.{u} E
       (@add_semigroup.to_has_add.{u} E
          (@add_monoid.to_add_semigroup.{u} E
             (@add_group.to_add_monoid.{u} E
                (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
       x
       (@has_sub.sub.{u} E
          (@add_group_has_sub.{u} E
             (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
          (@has_scalar.smul.{0 u} real E
             (@mul_action.to_has_scalar.{0 u} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
                   (@add_group.to_add_monoid.{u} E
                      (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                      (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                         (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
             (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
             y)
          (@has_scalar.smul.{0 u} real E
             (@mul_action.to_has_scalar.{0 u} real E real.monoid
                (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
                   (@add_group.to_add_monoid.{u} E
                      (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
                   (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                      (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                      (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                         (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
             (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
             x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder)

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_sub.sub.{u} E
          (@add_group_has_sub.{u} E
             (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
          y
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95    show tendsto c at_top at_top,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='filter.at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1645, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type}, (α → β) → filter.{0} α → filter.{0} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : preorder.{0} α], filter.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`at_top` is the filter representing the limit `→ ∞` on an ordered set.
 It is generated by the collection of up-sets `{b | a ≤ b}`.
 (The preorder need not have a top element for this to be well defined,
 and indeed is trivial when a top element exists.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder)

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_sub.sub.{u} E
          (@add_group_has_sub.{u} E
             (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
          y
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96    { exact tendsto_pow_at_top_at_top_of_gt_1 one_lt_two },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='tendsto_pow_at_top_at_top_of_gt_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='one_lt_two'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/specific_limits.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_ring.lean&#x27;, &#x27;line&#x27;: 89, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {r : real}, @has_lt.lt.{0} real real.has_lt (@has_one.one.{0} real (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))) r → @filter.tendsto.{0 0} nat real (λ (n : nat), @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid) r n) (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))) (@filter.at_top.{0} real real.preorder)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_ordered_semiring.{0} α], @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1)))))) (@has_one.one.{0} α (@monoid.to_has_one.{0} α (@semiring.to_monoid.{0} α (@ordered_semiring.to_semiring.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1))))) (@bit0.{0} α (@distrib.to_has_add.{0} α (@semiring.to_distrib.{0} α (@ordered_semiring.to_semiring.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1)))) (@has_one.one.{0} α (@monoid.to_has_one.{0} α (@semiring.to_monoid.{0} α (@ordered_semiring.to_semiring.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder)

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_sub.sub.{u} E
          (@add_group_has_sub.{u} E
             (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
          y
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_sub.sub.{u} E
          (@add_group_has_sub.{u} E
             (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
          y
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97    show filter.tendsto (λ (n : ℕ), c n • d n) filter.at_top (𝓝 (y - x)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='filter.at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1645, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 384, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {β : Type u}, (α → β) → filter.{0} α → filter.{u} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : preorder.{0} α], filter.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`at_top` is the filter representing the limit `→ ∞` on an ordered set.
 It is generated by the collection of up-sets `{b | a ≤ b}`.
 (The preorder need not have a top element for this to be well defined,
 and indeed is trivial when a top element exists.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='neighbourhood filter'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_sub.sub.{u} E
          (@add_group_has_sub.{u} E
             (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
          y
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98    { have : (λ (n : ℕ), c n • d n) = (λn, y - x),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_sub.sub.{u} E
          (@add_group_has_sub.{u} E
             (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
          y
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @eq.{(max 1 (u+1))} (nat → E)
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (λ (n : nat),
       @has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
this :
  @eq.{(max 1 (u+1))} (nat → E)
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (λ (n : nat),
       @has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_sub.sub.{u} E
          (@add_group_has_sub.{u} E
             (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
          y
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99      { ext n,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @eq.{(max 1 (u+1))} (nat → E)
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (λ (n : nat),
       @has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
this :
  @eq.{(max 1 (u+1))} (nat → E)
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (λ (n : nat),
       @has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_sub.sub.{u} E
          (@add_group_has_sub.{u} E
             (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
          y
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @eq.{(max 1 (u+1))} (nat → E)
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (λ (n : nat),
       @has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @eq.{u+1} E
    (@has_scalar.smul.{0 u} real E
       (@mul_action.to_has_scalar.{0 u} real E real.monoid
          (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
             (@add_group.to_add_monoid.{u} E
                (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
             (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                   (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
       (c n)
       (d n))
    (@has_sub.sub.{u} E
       (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
       y
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100        simp only [d, smul_smul],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='smul_smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 29, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : monoid.{?l_1} α] [_inst_2 : @mul_action.{?l_1 ?l_2} α β _inst_1] (a₁ a₂ : α) (b : β), @eq.{?l_2+1} β (@has_scalar.smul.{?l_1 ?l_2} α β (@mul_action.to_has_scalar.{?l_1 ?l_2} α β _inst_1 _inst_2) a₁ (@has_scalar.smul.{?l_1 ?l_2} α β (@mul_action.to_has_scalar.{?l_1 ?l_2} α β _inst_1 _inst_2) a₂ b)) (@has_scalar.smul.{?l_1 ?l_2} α β (@mul_action.to_has_scalar.{?l_1 ?l_2} α β _inst_1 _inst_2) (@has_mul.mul.{?l_1} α (@semigroup.to_has_mul.{?l_1} α (@monoid.to_semigroup.{?l_1} α _inst_1)) a₁ a₂) b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @eq.{u+1} E
    (@has_scalar.smul.{0 u} real E
       (@mul_action.to_has_scalar.{0 u} real E real.monoid
          (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
             (@add_group.to_add_monoid.{u} E
                (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
             (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                   (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
       (c n)
       (d n))
    (@has_sub.sub.{u} E
       (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
       y
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @eq.{u+1} E
    (@has_scalar.smul.{0 u} real E
       (@mul_action.to_has_scalar.{0 u} real E real.monoid
          (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
             (@add_group.to_add_monoid.{u} E
                (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
             (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                   (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
       (@has_mul.mul.{0} real (@semigroup.to_has_mul.{0} real (@monoid.to_semigroup.{0} real real.monoid)) (c n)
          (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n)))
       (@has_sub.sub.{u} E
          (@add_group_has_sub.{u} E
             (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
          y
          x))
    (@has_sub.sub.{u} E
       (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
       y
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101        rw [mul_inv_cancel, one_smul],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='mul_inv_cancel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='one_smul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/field.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/group_theory/group_action.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : division_ring.{0} α] {a : α}, @ne.{1} α a (@has_zero.zero.{0} α (@zero_ne_one_class.to_has_zero.{0} α (@division_ring.to_zero_ne_one_class.{0} α _inst_1))) → @eq.{1} α (@has_mul.mul.{0} α (@mul_zero_class.to_has_mul.{0} α (@semiring.to_mul_zero_class.{0} α (@ring.to_semiring.{0} α (@division_ring.to_ring.{0} α _inst_1)))) a (@has_inv.inv.{0} α (@division_ring.to_has_inv.{0} α _inst_1) a)) (@has_one.one.{0} α (@zero_ne_one_class.to_has_one.{0} α (@division_ring.to_zero_ne_one_class.{0} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (α : Type) {β : Type u} [_inst_1 : monoid.{0} α] [_inst_2 : @mul_action.{0 u} α β _inst_1] (b : β), @eq.{u+1} β (@has_scalar.smul.{0 u} α β (@mul_action.to_has_scalar.{0 u} α β _inst_1 _inst_2) (@has_one.one.{0} α (@monoid.to_has_one.{0} α _inst_1)) b) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @eq.{u+1} E
    (@has_scalar.smul.{0 u} real E
       (@mul_action.to_has_scalar.{0 u} real E real.monoid
          (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
             (@add_group.to_add_monoid.{u} E
                (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
             (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                   (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
       (@has_mul.mul.{0} real (@semigroup.to_has_mul.{0} real (@monoid.to_semigroup.{0} real real.monoid)) (c n)
          (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n)))
       (@has_sub.sub.{u} E
          (@add_group_has_sub.{u} E
             (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
          y
          x))
    (@has_sub.sub.{u} E
       (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
       y
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @eq.{u+1} E
    (@has_scalar.smul.{0 u} real E
       (@mul_action.to_has_scalar.{0 u} real E real.monoid
          (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
             (@add_group.to_add_monoid.{u} E
                (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
             (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                   (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@division_ring.to_zero_ne_one_class.{0} real real.division_ring)))
       (@has_sub.sub.{u} E
          (@add_group_has_sub.{u} E
             (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
          y
          x))
    (@has_sub.sub.{u} E
       (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
       y
       x)

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @ne.{1} real (c n)
    (@has_zero.zero.{0} real
       (@zero_ne_one_class.to_has_zero.{0} real (@division_ring.to_zero_ne_one_class.{0} real real.division_ring)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @ne.{1} real (c n)
    (@has_zero.zero.{0} real
       (@zero_ne_one_class.to_has_zero.{0} real (@division_ring.to_zero_ne_one_class.{0} real real.division_ring)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102        exact pow_ne_zero _ (by norm_num) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='pow_ne_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group_power.lean&#x27;, &#x27;line&#x27;: 489, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/norm_num.lean&#x27;, &#x27;line&#x27;: 472, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : domain.{0} α] {a : α} (n : nat), @ne.{1} α a (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@domain.to_no_zero_divisors.{0} α _inst_1))) → @ne.{1} α (@has_pow.pow.{0 0} α nat (@monoid.has_pow.{0} α (@ring.to_monoid.{0} α (@domain.to_ring.{0} α _inst_1))) a n) (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@domain.to_no_zero_divisors.{0} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Normalize numerical expressions. Supports the operations
  `+` `-` `*` `/` `^` and `%` over numerical types such as
`ℕ`, `ℤ`, `ℚ`, `ℝ`, `ℂ` and some general algebraic types,
and can prove goals of the form `A = B`, `A ≠ B`, `A &lt; B` and `A ≤ B`,
where `A` and `B` are numerical expressions.
It also has a relatively simple primality prover.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='norm_num'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @ne.{1} real (c n)
    (@has_zero.zero.{0} real
       (@zero_ne_one_class.to_has_zero.{0} real (@division_ring.to_zero_ne_one_class.{0} real real.division_ring)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @ne.{1} real
    (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
       (@has_one.one.{0} real
          (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
n : nat
⊢ @ne.{1} real (c n)
    (@has_zero.zero.{0} real
       (@zero_ne_one_class.to_has_zero.{0} real (@division_ring.to_zero_ne_one_class.{0} real real.division_ring)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
this :
  @eq.{(max 1 (u+1))} (nat → E)
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (λ (n : nat),
       @has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_sub.sub.{u} E
          (@add_group_has_sub.{u} E
             (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
          y
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103      rw this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max 1 (u+1))} (nat → E) (λ (n : nat), @has_scalar.smul.{0 u} real E (@mul_action.to_has_scalar.{0 u} real E real.monoid (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid (@add_group.to_add_monoid.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))) (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)) (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1) (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2))))) (c n) (d n)) (λ (n : nat), @has_sub.sub.{u} E (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))) y x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
this :
  @eq.{(max 1 (u+1))} (nat → E)
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (λ (n : nat),
       @has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_sub.sub.{u} E
          (@add_group_has_sub.{u} E
             (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
          y
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
this :
  @eq.{(max 1 (u+1))} (nat → E)
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (λ (n : nat),
       @has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_sub.sub.{u} E
          (@add_group_has_sub.{u} E
             (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
          y
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104      apply tendsto_const_nhds }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='tendsto_const_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 469, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type} [_inst_1 : topological_space.{u} α] {a : α} {f : filter.{0} β}, @filter.tendsto.{0 u} β α (λ (b : β), a) f (@nhds.{u} α _inst_1 a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
s : set.{u} E,
x y : E,
h :
  @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E)
    (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       x
       y)
    s,
c : nat → real :=
  λ (n : nat),
    @has_pow.pow.{0 0} real nat (@monoid.has_pow.{0} real real.monoid)
      (@bit0.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_one.one.{0} real
            (@zero_ne_one_class.to_has_one.{0} real (@domain.to_zero_ne_one_class.{0} real real.domain))))
      n,
d : nat → E :=
  λ (n : nat),
    @has_scalar.smul.{0 u} real E
      (@mul_action.to_has_scalar.{0 u} real E real.monoid
         (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
            (@add_group.to_add_monoid.{u} E
               (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
            (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
               (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
               (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                  (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
      (@has_inv.inv.{0} real (@division_ring.to_has_inv.{0} real real.division_ring) (c n))
      (@has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x),
this :
  @eq.{(max 1 (u+1))} (nat → E)
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (λ (n : nat),
       @has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
⊢ @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_sub.sub.{u} E
         (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
         y
         x)
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_sub.sub.{u} E
          (@add_group_has_sub.{u} E
             (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
          y
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  lemma pos_tangent_cone_at_univ : pos_tangent_cone_at univ a = univ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='pos_tangent_cone_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Π {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1], set.{u} E → E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title=' &quot;Positive&quot; tangent cone to `s` at `x`; the only difference from `tangent_cone_at`
is that we require `c n → ∞` instead of `∥c n∥ → ∞`. One can think about `pos_tangent_cone_at`
as `tangent_cone_at nnreal` but we have no theory of normed semifields yet.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  eq_univ_iff_forall.2</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='set.eq_univ_iff_forall'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 248, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s : set.{u} α}, iff (@eq.{(max (u+1) 1)} (set.{u} α) s (@set.univ.{u} α)) (∀ (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
a : E
⊢ ∀ (x : E),
    @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) x
      (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 (@set.univ.{u} E) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110    assume x,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
a : E
⊢ ∀ (x : E),
    @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) x
      (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 (@set.univ.{u} E) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
a x : E
⊢ @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) x
    (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 (@set.univ.{u} E) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111    rw [← add_sub_cancel x a],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='add_sub_cancel'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 333, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_group.{u} α] (a b : α), @eq.{u+1} α (@has_sub.sub.{u} α (@add_group_has_sub.{u} α _inst_1) (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α (@add_group.to_add_monoid.{u} α _inst_1))) a b) b) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
a x : E
⊢ @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) x
    (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 (@set.univ.{u} E) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
a x : E
⊢ @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
    (@has_sub.sub.{u} E
       (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
       (@has_add.add.{u} E
          (@add_semigroup.to_has_add.{u} E
             (@add_monoid.to_add_semigroup.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
          x
          a)
       a)
    (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 (@set.univ.{u} E) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112    exact mem_pos_tangent_cone_at_of_segment_subset (subset_univ _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='mem_pos_tangent_cone_at_of_segment_subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 83, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 240, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1] {s : set.{u} E} {x y : E}, @has_subset.subset.{u} (set.{u} E) (@set.has_subset.{u} E) (@segment.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1) (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) x y) s → @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) (@has_sub.sub.{u} E (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))) y x) (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} (s : set.{u} α), @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) s (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
a x : E
⊢ @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
    (@has_sub.sub.{u} E
       (@add_group_has_sub.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
       (@has_add.add.{u} E
          (@add_semigroup.to_has_add.{u} E
             (@add_monoid.to_add_semigroup.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
          x
          a)
       a)
    (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 (@set.univ.{u} E) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  /-- If `f` has a local max on `s` at `a`, `f&#x27;` is the derivative of `f` at `a` within `s`, and</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  `y` belongs to the positive tangent cone of s at a, then `f&#x27; y ≤ 0`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  lemma is_local_max_on.has_fderiv_within_at_nonpos {s : set E} (h : is_local_max_on f s a)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='is_local_max_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : preorder.{v} β], (α → β) → set.{u} α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                   </code><font color='orange'><a title='`is_local_max_on f s a` means that `f x ≤ f a` for all `x ∈ s` in some neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118    (hf : has_fderiv_within_at f f&#x27; s a) {y} (hy : y ∈ pos_tangent_cone_at s a) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='has_fderiv_within_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pos_tangent_cone_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 96, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {F : Type u_3} [_inst_4 : normed_group.{u_3} F] [_inst_5 : @normed_space.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4], (E → F) → @continuous_linear_map.{u_1 u_2 u_3} 𝕜 (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) F (@uniform_space.to_topological_space.{u_3} F (@metric_space.to_uniform_space&#x27;.{u_3} F (@normed_group.to_metric_space.{u_3} F _inst_4))) (@normed_group.to_add_comm_group.{u_3} F _inst_4) (@normed_space.to_module.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4 _inst_5) → set.{u_2} E → E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1], set.{u} E → E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' A function `f` has the continuous linear map `f&#x27;` as derivative at `x` within a set `s` if
`f x&#x27; = f x + f&#x27; (x&#x27; - x) + o (x&#x27; - x)` when `x&#x27;` tends to `x` inside `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title=' &quot;Positive&quot; tangent cone to `s` at `x`; the only difference from `tangent_cone_at`
is that we require `c n → ∞` instead of `∥c n∥ → ∞`. One can think about `pos_tangent_cone_at`
as `tangent_cone_at nnreal` but we have no theory of normed semifields yet.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119    f&#x27; y ≤ 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
hy : @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a)
⊢ @has_le.le.{0} real real.has_le
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       f&#x27;
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121    rcases hy with ⟨c, d, hd, hc, hcd⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
hy : @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a)
⊢ @has_le.le.{0} real real.has_le
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       f&#x27;
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hd :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
         (@has_add.add.{u} E
            (@add_semigroup.to_has_add.{u} E
               (@add_monoid.to_add_semigroup.{u} E
                  (@add_group.to_add_monoid.{u} E
                     (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
            a
            (d n))
         s)
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y)
⊢ @has_le.le.{0} real real.has_le
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       f&#x27;
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122    have hc&#x27; : tendsto (λ n, ∥c n∥) at_top at_top,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='filter.at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1645, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type}, (α → β) → filter.{0} α → filter.{0} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_norm.{0} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_norm.{0} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : preorder.{0} α], filter.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`at_top` is the filter representing the limit `→ ∞` on an ordered set.
 It is generated by the collection of up-sets `{b | a ≤ b}`.
 (The preorder need not have a top element for this to be well defined,
 and indeed is trivial when a top element exists.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hd :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
         (@has_add.add.{u} E
            (@add_semigroup.to_has_add.{u} E
               (@add_monoid.to_add_semigroup.{u} E
                  (@add_group.to_add_monoid.{u} E
                     (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
            a
            (d n))
         s)
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y)
⊢ @has_le.le.{0} real real.has_le
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       f&#x27;
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hd :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
         (@has_add.add.{u} E
            (@add_semigroup.to_has_add.{u} E
               (@add_monoid.to_add_semigroup.{u} E
                  (@add_group.to_add_monoid.{u} E
                     (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
            a
            (d n))
         s)
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y)
⊢ @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder)

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hd :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
         (@has_add.add.{u} E
            (@add_semigroup.to_has_add.{u} E
               (@add_monoid.to_add_semigroup.{u} E
                  (@add_group.to_add_monoid.{u} E
                     (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
            a
            (d n))
         s)
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder)
⊢ @has_le.le.{0} real real.has_le
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       f&#x27;
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123      from tendsto_at_top_mono _ (λ n, le_abs_self _) hc,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='filter.tendsto_at_top_mono'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='le_abs_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1709, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type} [_inst_1 : preorder.{0} β] (l : filter.{0} α), @monotone.{0 0} (α → β) Prop (@pi.preorder.{0 0} α (λ (a : α), β) (λ (i : α), _inst_1)) (@partial_order.to_preorder.{0} Prop (@lattice.order_bot.to_partial_order.{0} Prop (@lattice.bounded_lattice.to_order_bot.{0} Prop lattice.bounded_lattice_Prop))) (λ (f : α → β), @filter.tendsto.{0 0} α β f l (@filter.at_top.{0} β _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_ordered_comm_group.{0} α] (a : α), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_group.to_partial_order.{0} α (@decidable_linear_ordered_comm_group.to_ordered_comm_group.{0} α _inst_1)))) a (@abs.{0} α _inst_1 a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@filter.tendsto.{0 0} nat real c (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))) (@filter.at_top.{0} real real.preorder)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hd :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
         (@has_add.add.{u} E
            (@add_semigroup.to_has_add.{u} E
               (@add_monoid.to_add_semigroup.{u} E
                  (@add_group.to_add_monoid.{u} E
                     (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
            a
            (d n))
         s)
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y)
⊢ @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder)

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hd :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
         (@has_add.add.{u} E
            (@add_semigroup.to_has_add.{u} E
               (@add_monoid.to_add_semigroup.{u} E
                  (@add_group.to_add_monoid.{u} E
                     (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
            a
            (d n))
         s)
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder)
⊢ @has_le.le.{0} real real.has_le
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       f&#x27;
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hd :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
         (@has_add.add.{u} E
            (@add_semigroup.to_has_add.{u} E
               (@add_monoid.to_add_semigroup.{u} E
                  (@add_group.to_add_monoid.{u} E
                     (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
            a
            (d n))
         s)
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder)
⊢ @has_le.le.{0} real real.has_le
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       f&#x27;
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124    refine le_of_tendsto at_top_ne_bot (hf.lim at_top hd hc&#x27; hcd) _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='le_of_tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.at_top_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hc&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hcd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/ordered.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1656, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 161, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1645, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type} [_inst_1 : topological_space.{0} α] [_inst_2 : preorder.{0} α] [t : @order_closed_topology.{0} α _inst_1 _inst_2] {f : β → α} {a b : α} {x : filter.{0} β}, @ne.{1} (filter.{0} β) x (@lattice.has_bot.bot.{0} (filter.{0} β) (@lattice.order_bot.to_has_bot.{0} (filter.{0} β) (@lattice.bounded_lattice.to_order_bot.{0} (filter.{0} β) (@lattice.complete_lattice.to_bounded_lattice.{0} (filter.{0} β) (@filter.lattice.complete_lattice.{0} β))))) → @filter.tendsto.{0 0} β α f x (@nhds.{0} α _inst_1 a) → @has_mem.mem.{0 0} (set.{0} β) (filter.{0} β) (@filter.has_mem.{0} β) (@set.preimage.{0 0} β α f (@set_of.{0} α (λ (c : α), @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_2) c b))) x → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_2) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : nonempty.{1} α] [_inst_2 : lattice.semilattice_sup.{0} α], @ne.{1} (filter.{0} α) (@filter.at_top.{0} α (@partial_order.to_preorder.{0} α (@lattice.semilattice_sup.to_partial_order.{0} α _inst_2))) (@lattice.has_bot.bot.{0} (filter.{0} α) (@lattice.order_bot.to_has_bot.{0} (filter.{0} α) (@lattice.bounded_lattice.to_order_bot.{0} (filter.{0} α) (@lattice.complete_lattice.to_bounded_lattice.{0} (filter.{0} α) (@filter.lattice.complete_lattice.{0} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; s a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : preorder.{0} α], filter.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@filter.eventually.{0} nat (λ (n : nat), @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) (@has_add.add.{u} E (@add_semigroup.to_has_add.{u} E (@add_monoid.to_add_semigroup.{u} E (@add_group.to_add_monoid.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))))) a (d n)) s) (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@filter.tendsto.{0 0} nat real (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n)) (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))) (@filter.at_top.{0} real real.preorder)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@filter.tendsto.{0 u} nat E (λ (n : nat), @has_scalar.smul.{0 u} real E (@mul_action.to_has_scalar.{0 u} real E real.monoid (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid (@add_group.to_add_monoid.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))) (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)) (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1) (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2))))) (c n) (d n)) (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))) (@nhds.{u} E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' If a function f has a derivative f&#x27; at x, a rescaled version of f around x converges to f&#x27;, i.e.,
`n (f (x + (1/n) v) - f x)` converges to `f&#x27; v`. More generally, if `c n` tends to infinity and
`c n * d n` tends to `v`, then `c n * (f (x + d n) - f x)` tends to `f&#x27; v`. This lemma expresses
this fact, for functions having a derivative within a set. Its specific formulation is useful for
tangent cone related discussions.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`at_top` is the filter representing the limit `→ ∞` on an ordered set.
 It is generated by the collection of up-sets `{b | a ≤ b}`.
 (The preorder need not have a top element for this to be well defined,
 and indeed is trivial when a top element exists.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hd :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
         (@has_add.add.{u} E
            (@add_semigroup.to_has_add.{u} E
               (@add_monoid.to_add_semigroup.{u} E
                  (@add_group.to_add_monoid.{u} E
                     (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
            a
            (d n))
         s)
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder)
⊢ @has_le.le.{0} real real.has_le
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       f&#x27;
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hd :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
         (@has_add.add.{u} E
            (@add_semigroup.to_has_add.{u} E
               (@add_monoid.to_add_semigroup.{u} E
                  (@add_group.to_add_monoid.{u} E
                     (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
            a
            (d n))
         s)
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder)
⊢ @has_mem.mem.{0 0} (set.{0} nat) (filter.{0} nat) (@filter.has_mem.{0} nat)
    (@set.preimage.{0 0} nat real
       (λ (n : nat),
          @has_scalar.smul.{0 0} real real
            (@mul_action.to_has_scalar.{0 0} real real
               (@ring.to_monoid.{0} real
                  (@normed_ring.to_ring.{0} real
                     (@normed_field.to_normed_ring.{0} real
                        (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
               (@distrib_mul_action.to_mul_action.{0 0} real real
                  (@ring.to_monoid.{0} real
                     (@normed_ring.to_ring.{0} real
                        (@normed_field.to_normed_ring.{0} real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
                  (@add_group.to_add_monoid.{0} real
                     (@add_comm_group.to_add_group.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
                  (@semimodule.to_distrib_mul_action.{0 0} real real
                     (@ring.to_semiring.{0} real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field))))
                     (@add_comm_group.to_add_comm_monoid.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))
                     (@module.to_semimodule.{0 0} real real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
                        (@normed_space.to_module.{0 0} real real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                           (@normed_field.to_normed_space.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))))))
            (c n)
            (@has_sub.sub.{0} real
               (@add_group_has_sub.{0} real
                  (@add_comm_group.to_add_group.{0} real
                     (@normed_group.to_add_comm_group.{0} real
                        (@normed_ring.to_normed_group.{0} real
                           (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
               (f
                  (@has_add.add.{u} E
                     (@add_semigroup.to_has_add.{u} E
                        (@add_monoid.to_add_semigroup.{u} E
                           (@add_group.to_add_monoid.{u} E
                              (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                     a
                     (d n)))
               (f a)))
       (@set_of.{0} real
          (λ (c : real),
             @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) c
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@lattice.semilattice_sup.to_partial_order.{0} nat
             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125    replace hd : tendsto (λ n, a + d n) at_top (nhds_within (a + 0) s),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='filter.tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='filter.at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='nhds_within'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1361, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1645, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {β : Type u}, (α → β) → filter.{0} α → filter.{u} β → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_add.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : preorder.{0} α], filter.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : topological_space.{u} α], α → set.{u} α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`tendsto` is the generic &quot;limit of a function&quot; predicate.
 `tendsto f l₁ l₂` asserts that for every `l₂` neighborhood `a`,
 the `f`-preimage of `a` is an `l₁` neighborhood.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`at_top` is the filter representing the limit `→ ∞` on an ordered set.
 It is generated by the collection of up-sets `{b | a ≤ b}`.
 (The preorder need not have a top element for this to be well defined,
 and indeed is trivial when a top element exists.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' The &quot;neighborhood within&quot; filter. Elements of `nhds_within a s` are sets containing the
intersection of `s` and a neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hd :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
         (@has_add.add.{u} E
            (@add_semigroup.to_has_add.{u} E
               (@add_monoid.to_add_semigroup.{u} E
                  (@add_group.to_add_monoid.{u} E
                     (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
            a
            (d n))
         s)
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder)
⊢ @has_mem.mem.{0 0} (set.{0} nat) (filter.{0} nat) (@filter.has_mem.{0} nat)
    (@set.preimage.{0 0} nat real
       (λ (n : nat),
          @has_scalar.smul.{0 0} real real
            (@mul_action.to_has_scalar.{0 0} real real
               (@ring.to_monoid.{0} real
                  (@normed_ring.to_ring.{0} real
                     (@normed_field.to_normed_ring.{0} real
                        (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
               (@distrib_mul_action.to_mul_action.{0 0} real real
                  (@ring.to_monoid.{0} real
                     (@normed_ring.to_ring.{0} real
                        (@normed_field.to_normed_ring.{0} real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
                  (@add_group.to_add_monoid.{0} real
                     (@add_comm_group.to_add_group.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
                  (@semimodule.to_distrib_mul_action.{0 0} real real
                     (@ring.to_semiring.{0} real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field))))
                     (@add_comm_group.to_add_comm_monoid.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))
                     (@module.to_semimodule.{0 0} real real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
                        (@normed_space.to_module.{0 0} real real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                           (@normed_field.to_normed_space.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))))))
            (c n)
            (@has_sub.sub.{0} real
               (@add_group_has_sub.{0} real
                  (@add_comm_group.to_add_group.{0} real
                     (@normed_group.to_add_comm_group.{0} real
                        (@normed_ring.to_normed_group.{0} real
                           (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
               (f
                  (@has_add.add.{u} E
                     (@add_semigroup.to_has_add.{u} E
                        (@add_monoid.to_add_semigroup.{u} E
                           (@add_group.to_add_monoid.{u} E
                              (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                     a
                     (d n)))
               (f a)))
       (@set_of.{0} real
          (λ (c : real),
             @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) c
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@lattice.semilattice_sup.to_partial_order.{0} nat
             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hd :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
         (@has_add.add.{u} E
            (@add_semigroup.to_has_add.{u} E
               (@add_monoid.to_add_semigroup.{u} E
                  (@add_group.to_add_monoid.{u} E
                     (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
            a
            (d n))
         s)
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder)
⊢ @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_add.add.{u} E
          (@add_semigroup.to_has_add.{u} E
             (@add_monoid.to_add_semigroup.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
          a
          (@has_zero.zero.{u} E
             (@add_monoid.to_has_zero.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))))))
       s)

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_add.add.{u} E
          (@add_semigroup.to_has_add.{u} E
             (@add_monoid.to_add_semigroup.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
          a
          (@has_zero.zero.{u} E
             (@add_monoid.to_has_zero.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))))))
       s)
⊢ @has_mem.mem.{0 0} (set.{0} nat) (filter.{0} nat) (@filter.has_mem.{0} nat)
    (@set.preimage.{0 0} nat real
       (λ (n : nat),
          @has_scalar.smul.{0 0} real real
            (@mul_action.to_has_scalar.{0 0} real real
               (@ring.to_monoid.{0} real
                  (@normed_ring.to_ring.{0} real
                     (@normed_field.to_normed_ring.{0} real
                        (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
               (@distrib_mul_action.to_mul_action.{0 0} real real
                  (@ring.to_monoid.{0} real
                     (@normed_ring.to_ring.{0} real
                        (@normed_field.to_normed_ring.{0} real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
                  (@add_group.to_add_monoid.{0} real
                     (@add_comm_group.to_add_group.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
                  (@semimodule.to_distrib_mul_action.{0 0} real real
                     (@ring.to_semiring.{0} real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field))))
                     (@add_comm_group.to_add_comm_monoid.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))
                     (@module.to_semimodule.{0 0} real real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
                        (@normed_space.to_module.{0 0} real real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                           (@normed_field.to_normed_space.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))))))
            (c n)
            (@has_sub.sub.{0} real
               (@add_group_has_sub.{0} real
                  (@add_comm_group.to_add_group.{0} real
                     (@normed_group.to_add_comm_group.{0} real
                        (@normed_ring.to_normed_group.{0} real
                           (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
               (f
                  (@has_add.add.{u} E
                     (@add_semigroup.to_has_add.{u} E
                        (@add_monoid.to_add_semigroup.{u} E
                           (@add_group.to_add_monoid.{u} E
                              (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                     a
                     (d n)))
               (f a)))
       (@set_of.{0} real
          (λ (c : real),
             @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) c
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@lattice.semilattice_sup.to_partial_order.{0} nat
             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126    from tendsto_inf.2 ⟨tendsto_const_nhds.add (tangent_cone_at.lim_zero _ hc&#x27; hcd),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='filter.tendsto_inf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='tendsto_const_nhds'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='tangent_cone_at.lim_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hc&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hcd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1446, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 469, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/tangent_cone.lean&#x27;, &#x27;line&#x27;: 94, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u} {f : α → β} {x : filter.{0} α} {y₁ y₂ : filter.{u} β}, iff (@filter.tendsto.{0 u} α β f x (@lattice.has_inf.inf.{u} (filter.{u} β) (@filter.lattice.has_inf.{u} β) y₁ y₂)) (and (@filter.tendsto.{0 u} α β f x y₁) (@filter.tendsto.{0 u} α β f x y₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} {β : Type} [_inst_1 : topological_space.{u} α] {a : α} {f : filter.{0} β}, @filter.tendsto.{0 u} β α (λ (b : β), a) f (@nhds.{u} α _inst_1 a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {𝕜 : Type} [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {E : Type u} [_inst_2 : normed_group.{u} E] [_inst_3 : @normed_space.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {y : E} {α : Type} (l : filter.{0} α) {c : α → 𝕜} {d : α → E}, @filter.tendsto.{0 0} α real (λ (n : α), @has_norm.norm.{0} 𝕜 (@normed_field.to_has_norm.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)) (c n)) l (@filter.at_top.{0} real real.preorder) → @filter.tendsto.{0 u} α E (λ (n : α), @has_scalar.smul.{0 u} 𝕜 E (@mul_action.to_has_scalar.{0 u} 𝕜 E (@ring.to_monoid.{0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) (@distrib_mul_action.to_mul_action.{0 u} 𝕜 E (@ring.to_monoid.{0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) (@add_group.to_add_monoid.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_2))) (@semimodule.to_distrib_mul_action.{0 u} 𝕜 E (@ring.to_semiring.{0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_2)) (@module.to_semimodule.{0 u} 𝕜 E (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_2) (@normed_space.to_module.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2 _inst_3))))) (c n) (d n)) l (@nhds.{u} E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_2))) y) → @filter.tendsto.{0 u} α E d l (@nhds.{u} E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_2))) (@has_zero.zero.{u} E (@add_monoid.to_has_zero.{u} E (@add_group.to_add_monoid.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_2))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@filter.tendsto.{0 0} nat real (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n)) (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))) (@filter.at_top.{0} real real.preorder)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@filter.tendsto.{0 u} nat E (λ (n : nat), @has_scalar.smul.{0 u} real E (@mul_action.to_has_scalar.{0 u} real E real.monoid (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid (@add_group.to_add_monoid.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))) (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)) (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1) (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2))))) (c n) (d n)) (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))) (@nhds.{u} E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Auxiliary lemma ensuring that, under the assumptions defining the tangent cone,
the sequence `d` tends to 0 at infinity.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hd :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
         (@has_add.add.{u} E
            (@add_semigroup.to_has_add.{u} E
               (@add_monoid.to_add_semigroup.{u} E
                  (@add_group.to_add_monoid.{u} E
                     (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
            a
            (d n))
         s)
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder)
⊢ @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_add.add.{u} E
          (@add_semigroup.to_has_add.{u} E
             (@add_monoid.to_add_semigroup.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
          a
          (@has_zero.zero.{u} E
             (@add_monoid.to_has_zero.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))))))
       s)

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_add.add.{u} E
          (@add_semigroup.to_has_add.{u} E
             (@add_monoid.to_add_semigroup.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
          a
          (@has_zero.zero.{u} E
             (@add_monoid.to_has_zero.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))))))
       s)
⊢ @has_mem.mem.{0 0} (set.{0} nat) (filter.{0} nat) (@filter.has_mem.{0} nat)
    (@set.preimage.{0 0} nat real
       (λ (n : nat),
          @has_scalar.smul.{0 0} real real
            (@mul_action.to_has_scalar.{0 0} real real
               (@ring.to_monoid.{0} real
                  (@normed_ring.to_ring.{0} real
                     (@normed_field.to_normed_ring.{0} real
                        (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
               (@distrib_mul_action.to_mul_action.{0 0} real real
                  (@ring.to_monoid.{0} real
                     (@normed_ring.to_ring.{0} real
                        (@normed_field.to_normed_ring.{0} real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
                  (@add_group.to_add_monoid.{0} real
                     (@add_comm_group.to_add_group.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
                  (@semimodule.to_distrib_mul_action.{0 0} real real
                     (@ring.to_semiring.{0} real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field))))
                     (@add_comm_group.to_add_comm_monoid.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))
                     (@module.to_semimodule.{0 0} real real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
                        (@normed_space.to_module.{0 0} real real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                           (@normed_field.to_normed_space.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))))))
            (c n)
            (@has_sub.sub.{0} real
               (@add_group_has_sub.{0} real
                  (@add_comm_group.to_add_group.{0} real
                     (@normed_group.to_add_comm_group.{0} real
                        (@normed_ring.to_normed_group.{0} real
                           (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
               (f
                  (@has_add.add.{u} E
                     (@add_semigroup.to_has_add.{u} E
                        (@add_monoid.to_add_semigroup.{u} E
                           (@add_group.to_add_monoid.{u} E
                              (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                     a
                     (d n)))
               (f a)))
       (@set_of.{0} real
          (λ (c : real),
             @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) c
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@lattice.semilattice_sup.to_partial_order.{0} nat
             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127      by rwa tendsto_principal⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='filter.tendsto_principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 391, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1470, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u} {f : α → β} {l : filter.{0} α} {s : set.{u} β}, iff (@filter.tendsto.{0 u} α β f l (@filter.principal.{u} β s)) (@filter.eventually.{0} α (λ (a : α), @has_mem.mem.{u u} β (set.{u} β) (@set.has_mem.{u} β) (f a) s) l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`rewrite` followed by `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rwa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hd :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
         (@has_add.add.{u} E
            (@add_semigroup.to_has_add.{u} E
               (@add_monoid.to_add_semigroup.{u} E
                  (@add_group.to_add_monoid.{u} E
                     (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
            a
            (d n))
         s)
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder)
⊢ @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_add.add.{u} E
          (@add_semigroup.to_has_add.{u} E
             (@add_monoid.to_add_semigroup.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
          a
          (@has_zero.zero.{u} E
             (@add_monoid.to_has_zero.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))))))
       s)

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_add.add.{u} E
          (@add_semigroup.to_has_add.{u} E
             (@add_monoid.to_add_semigroup.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
          a
          (@has_zero.zero.{u} E
             (@add_monoid.to_has_zero.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))))))
       s)
⊢ @has_mem.mem.{0 0} (set.{0} nat) (filter.{0} nat) (@filter.has_mem.{0} nat)
    (@set.preimage.{0 0} nat real
       (λ (n : nat),
          @has_scalar.smul.{0 0} real real
            (@mul_action.to_has_scalar.{0 0} real real
               (@ring.to_monoid.{0} real
                  (@normed_ring.to_ring.{0} real
                     (@normed_field.to_normed_ring.{0} real
                        (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
               (@distrib_mul_action.to_mul_action.{0 0} real real
                  (@ring.to_monoid.{0} real
                     (@normed_ring.to_ring.{0} real
                        (@normed_field.to_normed_ring.{0} real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
                  (@add_group.to_add_monoid.{0} real
                     (@add_comm_group.to_add_group.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
                  (@semimodule.to_distrib_mul_action.{0 0} real real
                     (@ring.to_semiring.{0} real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field))))
                     (@add_comm_group.to_add_comm_monoid.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))
                     (@module.to_semimodule.{0 0} real real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
                        (@normed_space.to_module.{0 0} real real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                           (@normed_field.to_normed_space.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))))))
            (c n)
            (@has_sub.sub.{0} real
               (@add_group_has_sub.{0} real
                  (@add_comm_group.to_add_group.{0} real
                     (@normed_group.to_add_comm_group.{0} real
                        (@normed_ring.to_normed_group.{0} real
                           (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
               (f
                  (@has_add.add.{u} E
                     (@add_semigroup.to_has_add.{u} E
                        (@add_monoid.to_add_semigroup.{u} E
                           (@add_group.to_add_monoid.{u} E
                              (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                     a
                     (d n)))
               (f a)))
       (@set_of.{0} real
          (λ (c : real),
             @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) c
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@lattice.semilattice_sup.to_partial_order.{0} nat
             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hd :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
         (@has_add.add.{u} E
            (@add_semigroup.to_has_add.{u} E
               (@add_monoid.to_add_semigroup.{u} E
                  (@add_group.to_add_monoid.{u} E
                     (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
            a
            (d n))
         s)
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder)
⊢ @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.principal.{u} E s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hd :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
         (@has_add.add.{u} E
            (@add_semigroup.to_has_add.{u} E
               (@add_monoid.to_add_semigroup.{u} E
                  (@add_group.to_add_monoid.{u} E
                     (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
            a
            (d n))
         s)
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder)
⊢ @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_add.add.{u} E
          (@add_semigroup.to_has_add.{u} E
             (@add_monoid.to_add_semigroup.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
          a
          (@has_zero.zero.{u} E
             (@add_monoid.to_has_zero.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))))))
       s)

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_add.add.{u} E
          (@add_semigroup.to_has_add.{u} E
             (@add_monoid.to_add_semigroup.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
          a
          (@has_zero.zero.{u} E
             (@add_monoid.to_has_zero.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))))))
       s)
⊢ @has_mem.mem.{0 0} (set.{0} nat) (filter.{0} nat) (@filter.has_mem.{0} nat)
    (@set.preimage.{0 0} nat real
       (λ (n : nat),
          @has_scalar.smul.{0 0} real real
            (@mul_action.to_has_scalar.{0 0} real real
               (@ring.to_monoid.{0} real
                  (@normed_ring.to_ring.{0} real
                     (@normed_field.to_normed_ring.{0} real
                        (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
               (@distrib_mul_action.to_mul_action.{0 0} real real
                  (@ring.to_monoid.{0} real
                     (@normed_ring.to_ring.{0} real
                        (@normed_field.to_normed_ring.{0} real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
                  (@add_group.to_add_monoid.{0} real
                     (@add_comm_group.to_add_group.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
                  (@semimodule.to_distrib_mul_action.{0 0} real real
                     (@ring.to_semiring.{0} real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field))))
                     (@add_comm_group.to_add_comm_monoid.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))
                     (@module.to_semimodule.{0 0} real real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
                        (@normed_space.to_module.{0 0} real real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                           (@normed_field.to_normed_space.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))))))
            (c n)
            (@has_sub.sub.{0} real
               (@add_group_has_sub.{0} real
                  (@add_comm_group.to_add_group.{0} real
                     (@normed_group.to_add_comm_group.{0} real
                        (@normed_ring.to_normed_group.{0} real
                           (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
               (f
                  (@has_add.add.{u} E
                     (@add_semigroup.to_has_add.{u} E
                        (@add_monoid.to_add_semigroup.{u} E
                           (@add_group.to_add_monoid.{u} E
                              (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                     a
                     (d n)))
               (f a)))
       (@set_of.{0} real
          (λ (c : real),
             @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) c
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@lattice.semilattice_sup.to_partial_order.{0} nat
             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_add.add.{u} E
          (@add_semigroup.to_has_add.{u} E
             (@add_monoid.to_add_semigroup.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
          a
          (@has_zero.zero.{u} E
             (@add_monoid.to_has_zero.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))))))
       s)
⊢ @has_mem.mem.{0 0} (set.{0} nat) (filter.{0} nat) (@filter.has_mem.{0} nat)
    (@set.preimage.{0 0} nat real
       (λ (n : nat),
          @has_scalar.smul.{0 0} real real
            (@mul_action.to_has_scalar.{0 0} real real
               (@ring.to_monoid.{0} real
                  (@normed_ring.to_ring.{0} real
                     (@normed_field.to_normed_ring.{0} real
                        (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
               (@distrib_mul_action.to_mul_action.{0 0} real real
                  (@ring.to_monoid.{0} real
                     (@normed_ring.to_ring.{0} real
                        (@normed_field.to_normed_ring.{0} real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
                  (@add_group.to_add_monoid.{0} real
                     (@add_comm_group.to_add_group.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
                  (@semimodule.to_distrib_mul_action.{0 0} real real
                     (@ring.to_semiring.{0} real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field))))
                     (@add_comm_group.to_add_comm_monoid.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))
                     (@module.to_semimodule.{0 0} real real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
                        (@normed_space.to_module.{0 0} real real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                           (@normed_field.to_normed_space.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))))))
            (c n)
            (@has_sub.sub.{0} real
               (@add_group_has_sub.{0} real
                  (@add_comm_group.to_add_group.{0} real
                     (@normed_group.to_add_comm_group.{0} real
                        (@normed_ring.to_normed_group.{0} real
                           (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
               (f
                  (@has_add.add.{u} E
                     (@add_semigroup.to_has_add.{u} E
                        (@add_monoid.to_add_semigroup.{u} E
                           (@add_group.to_add_monoid.{u} E
                              (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                     a
                     (d n)))
               (f a)))
       (@set_of.{0} real
          (λ (c : real),
             @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) c
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@lattice.semilattice_sup.to_partial_order.{0} nat
             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128    rw [add_zero] at hd,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='add_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/group.lean&#x27;, &#x27;line&#x27;: 226, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_monoid.{u} α] (a : α), @eq.{u+1} α (@has_add.add.{u} α (@add_semigroup.to_has_add.{u} α (@add_monoid.to_add_semigroup.{u} α _inst_1)) a (@has_zero.zero.{u} α (@add_monoid.to_has_zero.{u} α _inst_1))) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_add.add.{u} E
          (@add_semigroup.to_has_add.{u} E
             (@add_monoid.to_add_semigroup.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
          a
          (@has_zero.zero.{u} E
             (@add_monoid.to_has_zero.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))))))
       s)
⊢ @has_mem.mem.{0 0} (set.{0} nat) (filter.{0} nat) (@filter.has_mem.{0} nat)
    (@set.preimage.{0 0} nat real
       (λ (n : nat),
          @has_scalar.smul.{0 0} real real
            (@mul_action.to_has_scalar.{0 0} real real
               (@ring.to_monoid.{0} real
                  (@normed_ring.to_ring.{0} real
                     (@normed_field.to_normed_ring.{0} real
                        (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
               (@distrib_mul_action.to_mul_action.{0 0} real real
                  (@ring.to_monoid.{0} real
                     (@normed_ring.to_ring.{0} real
                        (@normed_field.to_normed_ring.{0} real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
                  (@add_group.to_add_monoid.{0} real
                     (@add_comm_group.to_add_group.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
                  (@semimodule.to_distrib_mul_action.{0 0} real real
                     (@ring.to_semiring.{0} real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field))))
                     (@add_comm_group.to_add_comm_monoid.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))
                     (@module.to_semimodule.{0 0} real real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
                        (@normed_space.to_module.{0 0} real real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                           (@normed_field.to_normed_space.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))))))
            (c n)
            (@has_sub.sub.{0} real
               (@add_group_has_sub.{0} real
                  (@add_comm_group.to_add_group.{0} real
                     (@normed_group.to_add_comm_group.{0} real
                        (@normed_ring.to_normed_group.{0} real
                           (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
               (f
                  (@has_add.add.{u} E
                     (@add_semigroup.to_has_add.{u} E
                        (@add_monoid.to_add_semigroup.{u} E
                           (@add_group.to_add_monoid.{u} E
                              (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                     a
                     (d n)))
               (f a)))
       (@set_of.{0} real
          (λ (c : real),
             @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) c
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@lattice.semilattice_sup.to_partial_order.{0} nat
             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       a
       s)
⊢ @has_mem.mem.{0 0} (set.{0} nat) (filter.{0} nat) (@filter.has_mem.{0} nat)
    (@set.preimage.{0 0} nat real
       (λ (n : nat),
          @has_scalar.smul.{0 0} real real
            (@mul_action.to_has_scalar.{0 0} real real
               (@ring.to_monoid.{0} real
                  (@normed_ring.to_ring.{0} real
                     (@normed_field.to_normed_ring.{0} real
                        (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
               (@distrib_mul_action.to_mul_action.{0 0} real real
                  (@ring.to_monoid.{0} real
                     (@normed_ring.to_ring.{0} real
                        (@normed_field.to_normed_ring.{0} real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
                  (@add_group.to_add_monoid.{0} real
                     (@add_comm_group.to_add_group.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
                  (@semimodule.to_distrib_mul_action.{0 0} real real
                     (@ring.to_semiring.{0} real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field))))
                     (@add_comm_group.to_add_comm_monoid.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))
                     (@module.to_semimodule.{0 0} real real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
                        (@normed_space.to_module.{0 0} real real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                           (@normed_field.to_normed_space.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))))))
            (c n)
            (@has_sub.sub.{0} real
               (@add_group_has_sub.{0} real
                  (@add_comm_group.to_add_group.{0} real
                     (@normed_group.to_add_comm_group.{0} real
                        (@normed_ring.to_normed_group.{0} real
                           (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
               (f
                  (@has_add.add.{u} E
                     (@add_semigroup.to_has_add.{u} E
                        (@add_monoid.to_add_semigroup.{u} E
                           (@add_group.to_add_monoid.{u} E
                              (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                     a
                     (d n)))
               (f a)))
       (@set_of.{0} real
          (λ (c : real),
             @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) c
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@lattice.semilattice_sup.to_partial_order.{0} nat
             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@has_add.add.{u} E
          (@add_semigroup.to_has_add.{u} E
             (@add_monoid.to_add_semigroup.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
          a
          (@has_zero.zero.{u} E
             (@add_monoid.to_has_zero.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))))))
       s)
⊢ @has_mem.mem.{0 0} (set.{0} nat) (filter.{0} nat) (@filter.has_mem.{0} nat)
    (@set.preimage.{0 0} nat real
       (λ (n : nat),
          @has_scalar.smul.{0 0} real real
            (@mul_action.to_has_scalar.{0 0} real real
               (@ring.to_monoid.{0} real
                  (@normed_ring.to_ring.{0} real
                     (@normed_field.to_normed_ring.{0} real
                        (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
               (@distrib_mul_action.to_mul_action.{0 0} real real
                  (@ring.to_monoid.{0} real
                     (@normed_ring.to_ring.{0} real
                        (@normed_field.to_normed_ring.{0} real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
                  (@add_group.to_add_monoid.{0} real
                     (@add_comm_group.to_add_group.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
                  (@semimodule.to_distrib_mul_action.{0 0} real real
                     (@ring.to_semiring.{0} real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field))))
                     (@add_comm_group.to_add_comm_monoid.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))
                     (@module.to_semimodule.{0 0} real real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
                        (@normed_space.to_module.{0 0} real real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                           (@normed_field.to_normed_space.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))))))
            (c n)
            (@has_sub.sub.{0} real
               (@add_group_has_sub.{0} real
                  (@add_comm_group.to_add_group.{0} real
                     (@normed_group.to_add_comm_group.{0} real
                        (@normed_ring.to_normed_group.{0} real
                           (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
               (f
                  (@has_add.add.{u} E
                     (@add_semigroup.to_has_add.{u} E
                        (@add_monoid.to_add_semigroup.{u} E
                           (@add_group.to_add_monoid.{u} E
                              (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                     a
                     (d n)))
               (f a)))
       (@set_of.{0} real
          (λ (c : real),
             @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) c
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@lattice.semilattice_sup.to_partial_order.{0} nat
             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       a
       s)
⊢ @has_mem.mem.{0 0} (set.{0} nat) (filter.{0} nat) (@filter.has_mem.{0} nat)
    (@set.preimage.{0 0} nat real
       (λ (n : nat),
          @has_scalar.smul.{0 0} real real
            (@mul_action.to_has_scalar.{0 0} real real
               (@ring.to_monoid.{0} real
                  (@normed_ring.to_ring.{0} real
                     (@normed_field.to_normed_ring.{0} real
                        (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
               (@distrib_mul_action.to_mul_action.{0 0} real real
                  (@ring.to_monoid.{0} real
                     (@normed_ring.to_ring.{0} real
                        (@normed_field.to_normed_ring.{0} real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
                  (@add_group.to_add_monoid.{0} real
                     (@add_comm_group.to_add_group.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
                  (@semimodule.to_distrib_mul_action.{0 0} real real
                     (@ring.to_semiring.{0} real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field))))
                     (@add_comm_group.to_add_comm_monoid.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))
                     (@module.to_semimodule.{0 0} real real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
                        (@normed_space.to_module.{0 0} real real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                           (@normed_field.to_normed_space.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))))))
            (c n)
            (@has_sub.sub.{0} real
               (@add_group_has_sub.{0} real
                  (@add_comm_group.to_add_group.{0} real
                     (@normed_group.to_add_comm_group.{0} real
                        (@normed_ring.to_normed_group.{0} real
                           (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
               (f
                  (@has_add.add.{u} E
                     (@add_semigroup.to_has_add.{u} E
                        (@add_monoid.to_add_semigroup.{u} E
                           (@add_group.to_add_monoid.{u} E
                              (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                     a
                     (d n)))
               (f a)))
       (@set_of.{0} real
          (λ (c : real),
             @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) c
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@lattice.semilattice_sup.to_partial_order.{0} nat
             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129    replace h : ∀ᶠ n in at_top, f (a + d n) ≤ f a, from mem_map.1 (hd h),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='filter.eventually'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.eventually'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='filter.eventually'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='d'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='filter.mem_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 554, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 554, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1645, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 554, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 776, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → filter.{0} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → filter.{0} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : preorder.{0} α], filter.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → filter.{0} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u} {f : filter.{0} α} {m : α → β} {t : set.{u} β}, iff (@has_mem.mem.{u u} (set.{u} β) (filter.{u} β) (@filter.has_mem.{u} β) t (@filter.map.{0 u} α β m f)) (@has_mem.mem.{0 0} (set.{0} α) (filter.{0} α) (@filter.has_mem.{0} α) (@set_of.{0} α (λ (x : α), @has_mem.mem.{u u} β (set.{u} β) (@set.has_mem.{u} β) (m x) t)) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@filter.tendsto.{0 u} nat E (λ (n : nat), @has_add.add.{u} E (@add_semigroup.to_has_add.{u} E (@add_monoid.to_add_semigroup.{u} E (@add_group.to_add_monoid.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))))) a (d n)) (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))) (@nhds_within.{u} E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) a s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_local_max_on.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f s a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `f.eventually p` or `∀ᶠ x in f, p x` mean that `{x | p x} ∈ f`. E.g., `∀ᶠ x in at_top, p x`
means that `p` holds true for sufficiently large `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `f.eventually p` or `∀ᶠ x in f, p x` mean that `{x | p x} ∈ f`. E.g., `∀ᶠ x in at_top, p x`
means that `p` holds true for sufficiently large `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`at_top` is the filter representing the limit `→ ∞` on an ordered set.
 It is generated by the collection of up-sets `{b | a ≤ b}`.
 (The preorder need not have a top element for this to be well defined,
 and indeed is trivial when a top element exists.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `f.eventually p` or `∀ᶠ x in f, p x` mean that `{x | p x} ∈ f`. E.g., `∀ᶠ x in at_top, p x`
means that `p` holds true for sufficiently large `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       a
       s)
⊢ @has_mem.mem.{0 0} (set.{0} nat) (filter.{0} nat) (@filter.has_mem.{0} nat)
    (@set.preimage.{0 0} nat real
       (λ (n : nat),
          @has_scalar.smul.{0 0} real real
            (@mul_action.to_has_scalar.{0 0} real real
               (@ring.to_monoid.{0} real
                  (@normed_ring.to_ring.{0} real
                     (@normed_field.to_normed_ring.{0} real
                        (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
               (@distrib_mul_action.to_mul_action.{0 0} real real
                  (@ring.to_monoid.{0} real
                     (@normed_ring.to_ring.{0} real
                        (@normed_field.to_normed_ring.{0} real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
                  (@add_group.to_add_monoid.{0} real
                     (@add_comm_group.to_add_group.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
                  (@semimodule.to_distrib_mul_action.{0 0} real real
                     (@ring.to_semiring.{0} real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field))))
                     (@add_comm_group.to_add_comm_monoid.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))
                     (@module.to_semimodule.{0 0} real real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
                        (@normed_space.to_module.{0 0} real real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                           (@normed_field.to_normed_space.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))))))
            (c n)
            (@has_sub.sub.{0} real
               (@add_group_has_sub.{0} real
                  (@add_comm_group.to_add_group.{0} real
                     (@normed_group.to_add_comm_group.{0} real
                        (@normed_ring.to_normed_group.{0} real
                           (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
               (f
                  (@has_add.add.{u} E
                     (@add_semigroup.to_has_add.{u} E
                        (@add_monoid.to_add_semigroup.{u} E
                           (@add_group.to_add_monoid.{u} E
                              (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                     a
                     (d n)))
               (f a)))
       (@set_of.{0} real
          (λ (c : real),
             @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) c
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@lattice.semilattice_sup.to_partial_order.{0} nat
             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       a
       s)
⊢ @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (f
            (@has_add.add.{u} E
               (@add_semigroup.to_has_add.{u} E
                  (@add_monoid.to_add_semigroup.{u} E
                     (@add_group.to_add_monoid.{u} E
                        (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
               a
               (d n)))
         (f a))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       a
       s),
h :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (f
            (@has_add.add.{u} E
               (@add_semigroup.to_has_add.{u} E
                  (@add_monoid.to_add_semigroup.{u} E
                     (@add_group.to_add_monoid.{u} E
                        (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
               a
               (d n)))
         (f a))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
⊢ @has_mem.mem.{0 0} (set.{0} nat) (filter.{0} nat) (@filter.has_mem.{0} nat)
    (@set.preimage.{0 0} nat real
       (λ (n : nat),
          @has_scalar.smul.{0 0} real real
            (@mul_action.to_has_scalar.{0 0} real real
               (@ring.to_monoid.{0} real
                  (@normed_ring.to_ring.{0} real
                     (@normed_field.to_normed_ring.{0} real
                        (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
               (@distrib_mul_action.to_mul_action.{0 0} real real
                  (@ring.to_monoid.{0} real
                     (@normed_ring.to_ring.{0} real
                        (@normed_field.to_normed_ring.{0} real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
                  (@add_group.to_add_monoid.{0} real
                     (@add_comm_group.to_add_group.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
                  (@semimodule.to_distrib_mul_action.{0 0} real real
                     (@ring.to_semiring.{0} real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field))))
                     (@add_comm_group.to_add_comm_monoid.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))
                     (@module.to_semimodule.{0 0} real real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
                        (@normed_space.to_module.{0 0} real real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                           (@normed_field.to_normed_space.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))))))
            (c n)
            (@has_sub.sub.{0} real
               (@add_group_has_sub.{0} real
                  (@add_comm_group.to_add_group.{0} real
                     (@normed_group.to_add_comm_group.{0} real
                        (@normed_ring.to_normed_group.{0} real
                           (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
               (f
                  (@has_add.add.{u} E
                     (@add_semigroup.to_has_add.{u} E
                        (@add_monoid.to_add_semigroup.{u} E
                           (@add_group.to_add_monoid.{u} E
                              (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                     a
                     (d n)))
               (f a)))
       (@set_of.{0} real
          (λ (c : real),
             @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) c
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@lattice.semilattice_sup.to_partial_order.{0} nat
             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       a
       s),
h :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (f
            (@has_add.add.{u} E
               (@add_semigroup.to_has_add.{u} E
                  (@add_monoid.to_add_semigroup.{u} E
                     (@add_group.to_add_monoid.{u} E
                        (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
               a
               (d n)))
         (f a))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
⊢ @has_mem.mem.{0 0} (set.{0} nat) (filter.{0} nat) (@filter.has_mem.{0} nat)
    (@set.preimage.{0 0} nat real
       (λ (n : nat),
          @has_scalar.smul.{0 0} real real
            (@mul_action.to_has_scalar.{0 0} real real
               (@ring.to_monoid.{0} real
                  (@normed_ring.to_ring.{0} real
                     (@normed_field.to_normed_ring.{0} real
                        (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
               (@distrib_mul_action.to_mul_action.{0 0} real real
                  (@ring.to_monoid.{0} real
                     (@normed_ring.to_ring.{0} real
                        (@normed_field.to_normed_ring.{0} real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
                  (@add_group.to_add_monoid.{0} real
                     (@add_comm_group.to_add_group.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
                  (@semimodule.to_distrib_mul_action.{0 0} real real
                     (@ring.to_semiring.{0} real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field))))
                     (@add_comm_group.to_add_comm_monoid.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))
                     (@module.to_semimodule.{0 0} real real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
                        (@normed_space.to_module.{0 0} real real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                           (@normed_field.to_normed_space.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))))))
            (c n)
            (@has_sub.sub.{0} real
               (@add_group_has_sub.{0} real
                  (@add_comm_group.to_add_group.{0} real
                     (@normed_group.to_add_comm_group.{0} real
                        (@normed_ring.to_normed_group.{0} real
                           (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
               (f
                  (@has_add.add.{u} E
                     (@add_semigroup.to_has_add.{u} E
                        (@add_monoid.to_add_semigroup.{u} E
                           (@add_group.to_add_monoid.{u} E
                              (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                     a
                     (d n)))
               (f a)))
       (@set_of.{0} real
          (λ (c : real),
             @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) c
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@lattice.semilattice_sup.to_partial_order.{0} nat
             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130    replace hc : ∀ᶠ n in at_top, 0 ≤ c n, from mem_map.1 (hc (mem_at_top (0:ℝ))),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='filter.eventually'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='filter.eventually'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='filter.eventually'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='filter.mem_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.mem_at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 554, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 554, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1645, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 554, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 114, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 776, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1653, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → filter.{0} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → filter.{0} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : preorder.{0} α], filter.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → filter.{0} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type} {f : filter.{0} α} {m : α → β} {t : set.{0} β}, iff (@has_mem.mem.{0 0} (set.{0} β) (filter.{0} β) (@filter.has_mem.{0} β) t (@filter.map.{0 0} α β m f)) (@has_mem.mem.{0 0} (set.{0} α) (filter.{0} α) (@filter.has_mem.{0} α) (@set_of.{0} α (λ (x : α), @has_mem.mem.{0 0} β (set.{0} β) (@set.has_mem.{0} β) (m x) t)) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@filter.tendsto.{0 0} nat real c (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))) (@filter.at_top.{0} real real.preorder)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] (a : α), @has_mem.mem.{0 0} (set.{0} α) (filter.{0} α) (@filter.has_mem.{0} α) (@set_of.{0} α (λ (b : α), @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b)) (@filter.at_top.{0} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `f.eventually p` or `∀ᶠ x in f, p x` mean that `{x | p x} ∈ f`. E.g., `∀ᶠ x in at_top, p x`
means that `p` holds true for sufficiently large `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `f.eventually p` or `∀ᶠ x in f, p x` mean that `{x | p x} ∈ f`. E.g., `∀ᶠ x in at_top, p x`
means that `p` holds true for sufficiently large `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`at_top` is the filter representing the limit `→ ∞` on an ordered set.
 It is generated by the collection of up-sets `{b | a ≤ b}`.
 (The preorder need not have a top element for this to be well defined,
 and indeed is trivial when a top element exists.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `f.eventually p` or `∀ᶠ x in f, p x` mean that `{x | p x} ∈ f`. E.g., `∀ᶠ x in at_top, p x`
means that `p` holds true for sufficiently large `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Acts like `have`, but removes a hypothesis with the same name as
this one. For example if the state is `h : p ⊢ goal` and `f : p → q`,
then after `replace h := f h` the goal will be `h : q ⊢ goal`,
where `have h := f h` would result in the state `h : p, h : q ⊢ goal`.
This can be used to simulate the `specialize` and `apply at` tactics
of Coq.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='replace'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       a
       s),
h :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (f
            (@has_add.add.{u} E
               (@add_semigroup.to_has_add.{u} E
                  (@add_monoid.to_add_semigroup.{u} E
                     (@add_group.to_add_monoid.{u} E
                        (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
               a
               (d n)))
         (f a))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
⊢ @has_mem.mem.{0 0} (set.{0} nat) (filter.{0} nat) (@filter.has_mem.{0} nat)
    (@set.preimage.{0 0} nat real
       (λ (n : nat),
          @has_scalar.smul.{0 0} real real
            (@mul_action.to_has_scalar.{0 0} real real
               (@ring.to_monoid.{0} real
                  (@normed_ring.to_ring.{0} real
                     (@normed_field.to_normed_ring.{0} real
                        (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
               (@distrib_mul_action.to_mul_action.{0 0} real real
                  (@ring.to_monoid.{0} real
                     (@normed_ring.to_ring.{0} real
                        (@normed_field.to_normed_ring.{0} real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
                  (@add_group.to_add_monoid.{0} real
                     (@add_comm_group.to_add_group.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
                  (@semimodule.to_distrib_mul_action.{0 0} real real
                     (@ring.to_semiring.{0} real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field))))
                     (@add_comm_group.to_add_comm_monoid.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))
                     (@module.to_semimodule.{0 0} real real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
                        (@normed_space.to_module.{0 0} real real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                           (@normed_field.to_normed_space.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))))))
            (c n)
            (@has_sub.sub.{0} real
               (@add_group_has_sub.{0} real
                  (@add_comm_group.to_add_group.{0} real
                     (@normed_group.to_add_comm_group.{0} real
                        (@normed_ring.to_normed_group.{0} real
                           (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
               (f
                  (@has_add.add.{u} E
                     (@add_semigroup.to_has_add.{u} E
                        (@add_monoid.to_add_semigroup.{u} E
                           (@add_group.to_add_monoid.{u} E
                              (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                     a
                     (d n)))
               (f a)))
       (@set_of.{0} real
          (λ (c : real),
             @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) c
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@lattice.semilattice_sup.to_partial_order.{0} nat
             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hc :
  @filter.tendsto.{0 0} nat real c
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       a
       s),
h :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (f
            (@has_add.add.{u} E
               (@add_semigroup.to_has_add.{u} E
                  (@add_monoid.to_add_semigroup.{u} E
                     (@add_group.to_add_monoid.{u} E
                        (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
               a
               (d n)))
         (f a))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
⊢ @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (@has_zero.zero.{0} real
            (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
         (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))

E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       a
       s),
h :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (f
            (@has_add.add.{u} E
               (@add_semigroup.to_has_add.{u} E
                  (@add_monoid.to_add_semigroup.{u} E
                     (@add_group.to_add_monoid.{u} E
                        (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
               a
               (d n)))
         (f a))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (@has_zero.zero.{0} real
            (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
         (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
⊢ @has_mem.mem.{0 0} (set.{0} nat) (filter.{0} nat) (@filter.has_mem.{0} nat)
    (@set.preimage.{0 0} nat real
       (λ (n : nat),
          @has_scalar.smul.{0 0} real real
            (@mul_action.to_has_scalar.{0 0} real real
               (@ring.to_monoid.{0} real
                  (@normed_ring.to_ring.{0} real
                     (@normed_field.to_normed_ring.{0} real
                        (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
               (@distrib_mul_action.to_mul_action.{0 0} real real
                  (@ring.to_monoid.{0} real
                     (@normed_ring.to_ring.{0} real
                        (@normed_field.to_normed_ring.{0} real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
                  (@add_group.to_add_monoid.{0} real
                     (@add_comm_group.to_add_group.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
                  (@semimodule.to_distrib_mul_action.{0 0} real real
                     (@ring.to_semiring.{0} real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field))))
                     (@add_comm_group.to_add_comm_monoid.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))
                     (@module.to_semimodule.{0 0} real real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
                        (@normed_space.to_module.{0 0} real real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                           (@normed_field.to_normed_space.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))))))
            (c n)
            (@has_sub.sub.{0} real
               (@add_group_has_sub.{0} real
                  (@add_comm_group.to_add_group.{0} real
                     (@normed_group.to_add_comm_group.{0} real
                        (@normed_ring.to_normed_group.{0} real
                           (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
               (f
                  (@has_add.add.{u} E
                     (@add_semigroup.to_has_add.{u} E
                        (@add_monoid.to_add_semigroup.{u} E
                           (@add_group.to_add_monoid.{u} E
                              (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                     a
                     (d n)))
               (f a)))
       (@set_of.{0} real
          (λ (c : real),
             @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) c
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@lattice.semilattice_sup.to_partial_order.{0} nat
             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       a
       s),
h :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (f
            (@has_add.add.{u} E
               (@add_semigroup.to_has_add.{u} E
                  (@add_monoid.to_add_semigroup.{u} E
                     (@add_group.to_add_monoid.{u} E
                        (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
               a
               (d n)))
         (f a))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (@has_zero.zero.{0} real
            (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
         (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
⊢ @has_mem.mem.{0 0} (set.{0} nat) (filter.{0} nat) (@filter.has_mem.{0} nat)
    (@set.preimage.{0 0} nat real
       (λ (n : nat),
          @has_scalar.smul.{0 0} real real
            (@mul_action.to_has_scalar.{0 0} real real
               (@ring.to_monoid.{0} real
                  (@normed_ring.to_ring.{0} real
                     (@normed_field.to_normed_ring.{0} real
                        (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
               (@distrib_mul_action.to_mul_action.{0 0} real real
                  (@ring.to_monoid.{0} real
                     (@normed_ring.to_ring.{0} real
                        (@normed_field.to_normed_ring.{0} real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
                  (@add_group.to_add_monoid.{0} real
                     (@add_comm_group.to_add_group.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
                  (@semimodule.to_distrib_mul_action.{0 0} real real
                     (@ring.to_semiring.{0} real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field))))
                     (@add_comm_group.to_add_comm_monoid.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))
                     (@module.to_semimodule.{0 0} real real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
                        (@normed_space.to_module.{0 0} real real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                           (@normed_field.to_normed_space.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))))))
            (c n)
            (@has_sub.sub.{0} real
               (@add_group_has_sub.{0} real
                  (@add_comm_group.to_add_group.{0} real
                     (@normed_group.to_add_comm_group.{0} real
                        (@normed_ring.to_normed_group.{0} real
                           (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
               (f
                  (@has_add.add.{u} E
                     (@add_semigroup.to_has_add.{u} E
                        (@add_monoid.to_add_semigroup.{u} E
                           (@add_group.to_add_monoid.{u} E
                              (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                     a
                     (d n)))
               (f a)))
       (@set_of.{0} real
          (λ (c : real),
             @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) c
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@lattice.semilattice_sup.to_partial_order.{0} nat
             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131    filter_upwards [h, hc],</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr interactive.types.texpr) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' `filter_upwards [h1, ⋯, hn]` replaces a goal of the form `s ∈ f`
and terms `h1 : t1 ∈ f, ⋯, hn : tn ∈ f` with `∀x, x ∈ t1 → ⋯ → x ∈ tn → x ∈ s`.

`filter_upwards [h1, ⋯, hn] e` is a short form for `{ filter_upwards [h1, ⋯, hn], exact e }`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='filter_upwards'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;[expr, ...]&#x27;, &#x27;expr?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       a
       s),
h :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (f
            (@has_add.add.{u} E
               (@add_semigroup.to_has_add.{u} E
                  (@add_monoid.to_add_semigroup.{u} E
                     (@add_group.to_add_monoid.{u} E
                        (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
               a
               (d n)))
         (f a))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (@has_zero.zero.{0} real
            (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
         (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
⊢ @has_mem.mem.{0 0} (set.{0} nat) (filter.{0} nat) (@filter.has_mem.{0} nat)
    (@set.preimage.{0 0} nat real
       (λ (n : nat),
          @has_scalar.smul.{0 0} real real
            (@mul_action.to_has_scalar.{0 0} real real
               (@ring.to_monoid.{0} real
                  (@normed_ring.to_ring.{0} real
                     (@normed_field.to_normed_ring.{0} real
                        (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
               (@distrib_mul_action.to_mul_action.{0 0} real real
                  (@ring.to_monoid.{0} real
                     (@normed_ring.to_ring.{0} real
                        (@normed_field.to_normed_ring.{0} real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
                  (@add_group.to_add_monoid.{0} real
                     (@add_comm_group.to_add_group.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
                  (@semimodule.to_distrib_mul_action.{0 0} real real
                     (@ring.to_semiring.{0} real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field))))
                     (@add_comm_group.to_add_comm_monoid.{0} real
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))
                     (@module.to_semimodule.{0 0} real real
                        (@normed_ring.to_ring.{0} real
                           (@normed_field.to_normed_ring.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))
                        (@normed_group.to_add_comm_group.{0} real
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
                        (@normed_space.to_module.{0 0} real real
                           (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                           (@normed_ring.to_normed_group.{0} real
                              (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                           (@normed_field.to_normed_space.{0} real
                              (@nondiscrete_normed_field.to_normed_field.{0} real
                                 normed_field.nondiscrete_normed_field)))))))
            (c n)
            (@has_sub.sub.{0} real
               (@add_group_has_sub.{0} real
                  (@add_comm_group.to_add_group.{0} real
                     (@normed_group.to_add_comm_group.{0} real
                        (@normed_ring.to_normed_group.{0} real
                           (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
               (f
                  (@has_add.add.{u} E
                     (@add_semigroup.to_has_add.{u} E
                        (@add_monoid.to_add_semigroup.{u} E
                           (@add_group.to_add_monoid.{u} E
                              (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                     a
                     (d n)))
               (f a)))
       (@set_of.{0} real
          (λ (c : real),
             @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) c
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@lattice.semilattice_sup.to_partial_order.{0} nat
             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       a
       s),
h :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (f
            (@has_add.add.{u} E
               (@add_semigroup.to_has_add.{u} E
                  (@add_monoid.to_add_semigroup.{u} E
                     (@add_group.to_add_monoid.{u} E
                        (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
               a
               (d n)))
         (f a))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (@has_zero.zero.{0} real
            (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
         (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
⊢ ∀ (a_1 : nat),
    @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a_1
      (@set_of.{0} nat
         (λ (x : nat),
            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
              (@set_of.{0} nat
                 (λ (x : nat),
                    (λ (n : nat),
                       @has_le.le.{0} real real.has_le
                         (f
                            (@has_add.add.{u} E
                               (@add_semigroup.to_has_add.{u} E
                                  (@add_monoid.to_add_semigroup.{u} E
                                     (@add_group.to_add_monoid.{u} E
                                        (@add_comm_group.to_add_group.{u} E
                                           (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                               a
                               (d n)))
                         (f a))
                      x)) →
            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
              (@set_of.{0} nat
                 (λ (x : nat),
                    @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                      (@set_of.{0} nat
                         (λ (x : nat),
                            (λ (n : nat),
                               @has_le.le.{0} real real.has_le
                                 (@has_zero.zero.{0} real
                                    (@no_zero_divisors.to_has_zero.{0} real
                                       (@domain.to_no_zero_divisors.{0} real real.domain)))
                                 (c n))
                              x)) →
                    @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                      (@set.preimage.{0 0} nat real
                         (λ (n : nat),
                            @has_scalar.smul.{0 0} real real
                              (@mul_action.to_has_scalar.{0 0} real real
                                 (@ring.to_monoid.{0} real
                                    (@normed_ring.to_ring.{0} real
                                       (@normed_field.to_normed_ring.{0} real
                                          (@nondiscrete_normed_field.to_normed_field.{0} real
                                             normed_field.nondiscrete_normed_field))))
                                 (@distrib_mul_action.to_mul_action.{0 0} real real
                                    (@ring.to_monoid.{0} real
                                       (@normed_ring.to_ring.{0} real
                                          (@normed_field.to_normed_ring.{0} real
                                             (@nondiscrete_normed_field.to_normed_field.{0} real
                                                normed_field.nondiscrete_normed_field))))
                                    (@add_group.to_add_monoid.{0} real
                                       (@add_comm_group.to_add_group.{0} real
                                          (@normed_group.to_add_comm_group.{0} real
                                             (@normed_ring.to_normed_group.{0} real
                                                (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
                                    (@semimodule.to_distrib_mul_action.{0 0} real real
                                       (@ring.to_semiring.{0} real
                                          (@normed_ring.to_ring.{0} real
                                             (@normed_field.to_normed_ring.{0} real
                                                (@nondiscrete_normed_field.to_normed_field.{0} real
                                                   normed_field.nondiscrete_normed_field))))
                                       (@add_comm_group.to_add_comm_monoid.{0} real
                                          (@normed_group.to_add_comm_group.{0} real
                                             (@normed_ring.to_normed_group.{0} real
                                                (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))
                                       (@module.to_semimodule.{0 0} real real
                                          (@normed_ring.to_ring.{0} real
                                             (@normed_field.to_normed_ring.{0} real
                                                (@nondiscrete_normed_field.to_normed_field.{0} real
                                                   normed_field.nondiscrete_normed_field)))
                                          (@normed_group.to_add_comm_group.{0} real
                                             (@normed_ring.to_normed_group.{0} real
                                                (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
                                          (@normed_space.to_module.{0 0} real real
                                             (@nondiscrete_normed_field.to_normed_field.{0} real
                                                normed_field.nondiscrete_normed_field)
                                             (@normed_ring.to_normed_group.{0} real
                                                (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                                             (@normed_field.to_normed_space.{0} real
                                                (@nondiscrete_normed_field.to_normed_field.{0} real
                                                   normed_field.nondiscrete_normed_field)))))))
                              (c n)
                              (@has_sub.sub.{0} real
                                 (@add_group_has_sub.{0} real
                                    (@add_comm_group.to_add_group.{0} real
                                       (@normed_group.to_add_comm_group.{0} real
                                          (@normed_ring.to_normed_group.{0} real
                                             (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
                                 (f
                                    (@has_add.add.{u} E
                                       (@add_semigroup.to_has_add.{u} E
                                          (@add_monoid.to_add_semigroup.{u} E
                                             (@add_group.to_add_monoid.{u} E
                                                (@add_comm_group.to_add_group.{u} E
                                                   (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                                       a
                                       (d n)))
                                 (f a)))
                         (@set_of.{0} real
                            (λ (c : real),
                               @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) c
                                 (@has_zero.zero.{0} real
                                    (@no_zero_divisors.to_has_zero.{0} real
                                       (@domain.to_no_zero_divisors.{0} real real.domain))))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132    simp only [mem_set_of_eq, smul_eq_mul, mem_preimage, subset_def],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='set.mem_set_of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='smul_eq_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_preimage'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/module.lean&#x27;, &#x27;line&#x27;: 129, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 838, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {a : α} {p : α → Prop}, @eq.{1} Prop (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a (@set_of.{?l_1} α (λ (a : α), p a))) (p a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : semiring.{?l_1} α] {a a&#x27; : α}, @eq.{?l_1+1} α (@has_scalar.smul.{?l_1 ?l_1} α α (@mul_action.to_has_scalar.{?l_1 ?l_1} α α (@semiring.to_monoid.{?l_1} α _inst_1) (@distrib_mul_action.to_mul_action.{?l_1 ?l_1} α α (@semiring.to_monoid.{?l_1} α _inst_1) (@add_comm_monoid.to_add_monoid.{?l_1} α (@semiring.to_add_comm_monoid.{?l_1} α _inst_1)) (@semimodule.to_distrib_mul_action.{?l_1 ?l_1} α α _inst_1 (@semiring.to_add_comm_monoid.{?l_1} α _inst_1) (@semiring.to_semimodule.{?l_1} α _inst_1)))) a a&#x27;) (@has_mul.mul.{?l_1} α (@mul_zero_class.to_has_mul.{?l_1} α (@semiring.to_mul_zero_class.{?l_1} α _inst_1)) a a&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {f : α → β} {s : set.{?l_2} β} {a : α}, iff (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a (@set.preimage.{?l_1 ?l_2} α β f s)) (@has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) (f a) s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {s t : set.{?l_1} α}, @eq.{1} Prop (@has_subset.subset.{?l_1} (set.{?l_1} α) (@set.has_subset.{?l_1} α) s t) (∀ (x : α), @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x s → @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       a
       s),
h :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (f
            (@has_add.add.{u} E
               (@add_semigroup.to_has_add.{u} E
                  (@add_monoid.to_add_semigroup.{u} E
                     (@add_group.to_add_monoid.{u} E
                        (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
               a
               (d n)))
         (f a))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (@has_zero.zero.{0} real
            (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
         (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
⊢ ∀ (a_1 : nat),
    @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a_1
      (@set_of.{0} nat
         (λ (x : nat),
            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
              (@set_of.{0} nat
                 (λ (x : nat),
                    (λ (n : nat),
                       @has_le.le.{0} real real.has_le
                         (f
                            (@has_add.add.{u} E
                               (@add_semigroup.to_has_add.{u} E
                                  (@add_monoid.to_add_semigroup.{u} E
                                     (@add_group.to_add_monoid.{u} E
                                        (@add_comm_group.to_add_group.{u} E
                                           (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                               a
                               (d n)))
                         (f a))
                      x)) →
            @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
              (@set_of.{0} nat
                 (λ (x : nat),
                    @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                      (@set_of.{0} nat
                         (λ (x : nat),
                            (λ (n : nat),
                               @has_le.le.{0} real real.has_le
                                 (@has_zero.zero.{0} real
                                    (@no_zero_divisors.to_has_zero.{0} real
                                       (@domain.to_no_zero_divisors.{0} real real.domain)))
                                 (c n))
                              x)) →
                    @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) x
                      (@set.preimage.{0 0} nat real
                         (λ (n : nat),
                            @has_scalar.smul.{0 0} real real
                              (@mul_action.to_has_scalar.{0 0} real real
                                 (@ring.to_monoid.{0} real
                                    (@normed_ring.to_ring.{0} real
                                       (@normed_field.to_normed_ring.{0} real
                                          (@nondiscrete_normed_field.to_normed_field.{0} real
                                             normed_field.nondiscrete_normed_field))))
                                 (@distrib_mul_action.to_mul_action.{0 0} real real
                                    (@ring.to_monoid.{0} real
                                       (@normed_ring.to_ring.{0} real
                                          (@normed_field.to_normed_ring.{0} real
                                             (@nondiscrete_normed_field.to_normed_field.{0} real
                                                normed_field.nondiscrete_normed_field))))
                                    (@add_group.to_add_monoid.{0} real
                                       (@add_comm_group.to_add_group.{0} real
                                          (@normed_group.to_add_comm_group.{0} real
                                             (@normed_ring.to_normed_group.{0} real
                                                (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
                                    (@semimodule.to_distrib_mul_action.{0 0} real real
                                       (@ring.to_semiring.{0} real
                                          (@normed_ring.to_ring.{0} real
                                             (@normed_field.to_normed_ring.{0} real
                                                (@nondiscrete_normed_field.to_normed_field.{0} real
                                                   normed_field.nondiscrete_normed_field))))
                                       (@add_comm_group.to_add_comm_monoid.{0} real
                                          (@normed_group.to_add_comm_group.{0} real
                                             (@normed_ring.to_normed_group.{0} real
                                                (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))
                                       (@module.to_semimodule.{0 0} real real
                                          (@normed_ring.to_ring.{0} real
                                             (@normed_field.to_normed_ring.{0} real
                                                (@nondiscrete_normed_field.to_normed_field.{0} real
                                                   normed_field.nondiscrete_normed_field)))
                                          (@normed_group.to_add_comm_group.{0} real
                                             (@normed_ring.to_normed_group.{0} real
                                                (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
                                          (@normed_space.to_module.{0 0} real real
                                             (@nondiscrete_normed_field.to_normed_field.{0} real
                                                normed_field.nondiscrete_normed_field)
                                             (@normed_ring.to_normed_group.{0} real
                                                (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                                             (@normed_field.to_normed_space.{0} real
                                                (@nondiscrete_normed_field.to_normed_field.{0} real
                                                   normed_field.nondiscrete_normed_field)))))))
                              (c n)
                              (@has_sub.sub.{0} real
                                 (@add_group_has_sub.{0} real
                                    (@add_comm_group.to_add_group.{0} real
                                       (@normed_group.to_add_comm_group.{0} real
                                          (@normed_ring.to_normed_group.{0} real
                                             (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
                                 (f
                                    (@has_add.add.{u} E
                                       (@add_semigroup.to_has_add.{u} E
                                          (@add_monoid.to_add_semigroup.{u} E
                                             (@add_group.to_add_monoid.{u} E
                                                (@add_comm_group.to_add_group.{u} E
                                                   (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                                       a
                                       (d n)))
                                 (f a)))
                         (@set_of.{0} real
                            (λ (c : real),
                               @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) c
                                 (@has_zero.zero.{0} real
                                    (@no_zero_divisors.to_has_zero.{0} real
                                       (@domain.to_no_zero_divisors.{0} real real.domain))))))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       a
       s),
h :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (f
            (@has_add.add.{u} E
               (@add_semigroup.to_has_add.{u} E
                  (@add_monoid.to_add_semigroup.{u} E
                     (@add_group.to_add_monoid.{u} E
                        (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
               a
               (d n)))
         (f a))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (@has_zero.zero.{0} real
            (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
         (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
⊢ ∀ (a_1 : nat),
    @has_le.le.{0} real real.has_le
      (f
         (@has_add.add.{u} E
            (@add_semigroup.to_has_add.{u} E
               (@add_monoid.to_add_semigroup.{u} E
                  (@add_group.to_add_monoid.{u} E
                     (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
            a
            (d a_1)))
      (f a) →
    @has_le.le.{0} real real.has_le
      (@has_zero.zero.{0} real
         (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
      (c a_1) →
    @has_le.le.{0} real real.has_le
      (@has_mul.mul.{0} real (@mul_zero_class.to_has_mul.{0} real (@semiring.to_mul_zero_class.{0} real real.semiring))
         (c a_1)
         (@has_sub.sub.{0} real
            (@add_group_has_sub.{0} real
               (@add_comm_group.to_add_group.{0} real
                  (@normed_group.to_add_comm_group.{0} real
                     (@normed_ring.to_normed_group.{0} real
                        (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
            (f
               (@has_add.add.{u} E
                  (@add_semigroup.to_has_add.{u} E
                     (@add_monoid.to_add_semigroup.{u} E
                        (@add_group.to_add_monoid.{u} E
                           (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                  a
                  (d a_1)))
            (f a)))
      (@has_zero.zero.{0} real
         (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133    assume n hnf hn,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       a
       s),
h :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (f
            (@has_add.add.{u} E
               (@add_semigroup.to_has_add.{u} E
                  (@add_monoid.to_add_semigroup.{u} E
                     (@add_group.to_add_monoid.{u} E
                        (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
               a
               (d n)))
         (f a))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (@has_zero.zero.{0} real
            (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
         (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
⊢ ∀ (a_1 : nat),
    @has_le.le.{0} real real.has_le
      (f
         (@has_add.add.{u} E
            (@add_semigroup.to_has_add.{u} E
               (@add_monoid.to_add_semigroup.{u} E
                  (@add_group.to_add_monoid.{u} E
                     (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
            a
            (d a_1)))
      (f a) →
    @has_le.le.{0} real real.has_le
      (@has_zero.zero.{0} real
         (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
      (c a_1) →
    @has_le.le.{0} real real.has_le
      (@has_mul.mul.{0} real (@mul_zero_class.to_has_mul.{0} real (@semiring.to_mul_zero_class.{0} real real.semiring))
         (c a_1)
         (@has_sub.sub.{0} real
            (@add_group_has_sub.{0} real
               (@add_comm_group.to_add_group.{0} real
                  (@normed_group.to_add_comm_group.{0} real
                     (@normed_ring.to_normed_group.{0} real
                        (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
            (f
               (@has_add.add.{u} E
                  (@add_semigroup.to_has_add.{u} E
                     (@add_monoid.to_add_semigroup.{u} E
                        (@add_group.to_add_monoid.{u} E
                           (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                  a
                  (d a_1)))
            (f a)))
      (@has_zero.zero.{0} real
         (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       a
       s),
h :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (f
            (@has_add.add.{u} E
               (@add_semigroup.to_has_add.{u} E
                  (@add_monoid.to_add_semigroup.{u} E
                     (@add_group.to_add_monoid.{u} E
                        (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
               a
               (d n)))
         (f a))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (@has_zero.zero.{0} real
            (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
         (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
n : nat,
hnf :
  @has_le.le.{0} real real.has_le
    (f
       (@has_add.add.{u} E
          (@add_semigroup.to_has_add.{u} E
             (@add_monoid.to_add_semigroup.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
          a
          (d n)))
    (f a),
hn :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    (c n)
⊢ @has_le.le.{0} real real.has_le
    (@has_mul.mul.{0} real (@mul_zero_class.to_has_mul.{0} real (@semiring.to_mul_zero_class.{0} real real.semiring))
       (c n)
       (@has_sub.sub.{0} real
          (@add_group_has_sub.{0} real
             (@add_comm_group.to_add_group.{0} real
                (@normed_group.to_add_comm_group.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
          (f
             (@has_add.add.{u} E
                (@add_semigroup.to_has_add.{u} E
                   (@add_monoid.to_add_semigroup.{u} E
                      (@add_group.to_add_monoid.{u} E
                         (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                a
                (d n)))
          (f a)))
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134    exact mul_nonpos_of_nonneg_of_nonpos hn (sub_nonpos.2 hnf)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='mul_nonpos_of_nonneg_of_nonpos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hn'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='sub_nonpos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hnf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ordered_ring.lean&#x27;, &#x27;line&#x27;: 51, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/ordered_group.lean&#x27;, &#x27;line&#x27;: 570, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_semiring.{0} α] {a b : α}, @ge.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α _inst_1)))) a (@has_zero.zero.{0} α (@mul_zero_class.to_has_zero.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α _inst_1)))) → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α _inst_1)))) b (@has_zero.zero.{0} α (@mul_zero_class.to_has_zero.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α _inst_1)))) → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α _inst_1)))) (@has_mul.mul.{0} α (@mul_zero_class.to_has_mul.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α _inst_1))) a b) (@has_zero.zero.{0} α (@mul_zero_class.to_has_zero.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) (c n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : ordered_comm_group.{0} α] {a b : α}, iff (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} α _inst_1))))) (@has_sub.sub.{0} α (@add_group_has_sub.{0} α (@add_comm_group.to_add_group.{0} α (@ordered_comm_group.to_add_comm_group.{0} α _inst_1))) a b) (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α (@add_group.to_add_monoid.{0} α (@add_comm_group.to_add_group.{0} α (@ordered_comm_group.to_add_comm_group.{0} α _inst_1)))))) (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} α _inst_1))))) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} real real.has_le (f (@has_add.add.{u} E (@add_semigroup.to_has_add.{u} E (@add_monoid.to_add_semigroup.{u} E (@add_group.to_add_monoid.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))))) a (d n))) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
c : nat → real,
d : nat → E,
hcd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_scalar.smul.{0 u} real E
         (@mul_action.to_has_scalar.{0 u} real E real.monoid
            (@distrib_mul_action.to_mul_action.{0 u} real E real.monoid
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
               (@semimodule.to_distrib_mul_action.{0 u} real E real.semiring
                  (@add_comm_group.to_add_comm_monoid.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))
                  (@module.to_semimodule.{0 u} real E real.ring (@normed_group.to_add_comm_group.{u} E _inst_1)
                     (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)))))
         (c n)
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       y),
hc&#x27; :
  @filter.tendsto.{0 0} nat real
    (λ (n : nat), @has_norm.norm.{0} real (@normed_field.to_has_norm.{0} real normed_field.normed_field) (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@filter.at_top.{0} real real.preorder),
hd :
  @filter.tendsto.{0 u} nat E
    (λ (n : nat),
       @has_add.add.{u} E
         (@add_semigroup.to_has_add.{u} E
            (@add_monoid.to_add_semigroup.{u} E
               (@add_group.to_add_monoid.{u} E
                  (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
         a
         (d n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds_within.{u} E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       a
       s),
h :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (f
            (@has_add.add.{u} E
               (@add_semigroup.to_has_add.{u} E
                  (@add_monoid.to_add_semigroup.{u} E
                     (@add_group.to_add_monoid.{u} E
                        (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
               a
               (d n)))
         (f a))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
hc :
  @filter.eventually.{0} nat
    (λ (n : nat),
       @has_le.le.{0} real real.has_le
         (@has_zero.zero.{0} real
            (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
         (c n))
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))),
n : nat,
hnf :
  @has_le.le.{0} real real.has_le
    (f
       (@has_add.add.{u} E
          (@add_semigroup.to_has_add.{u} E
             (@add_monoid.to_add_semigroup.{u} E
                (@add_group.to_add_monoid.{u} E
                   (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
          a
          (d n)))
    (f a),
hn :
  @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    (c n)
⊢ @has_le.le.{0} real real.has_le
    (@has_mul.mul.{0} real (@mul_zero_class.to_has_mul.{0} real (@semiring.to_mul_zero_class.{0} real real.semiring))
       (c n)
       (@has_sub.sub.{0} real
          (@add_group_has_sub.{0} real
             (@add_comm_group.to_add_group.{0} real
                (@normed_group.to_add_comm_group.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
          (f
             (@has_add.add.{u} E
                (@add_semigroup.to_has_add.{u} E
                   (@add_monoid.to_add_semigroup.{u} E
                      (@add_group.to_add_monoid.{u} E
                         (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))))
                a
                (d n)))
          (f a)))
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137  /-- If `f` has a local max on `s` at `a`, `f` is differentiable at `a` within `s`, and</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138  `y` belongs to the positive tangent cone of s at a, then `f&#x27; y ≤ 0`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139  lemma is_local_max_on.fderiv_within_nonpos {s : set E} (h : is_local_max_on f s a)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='is_local_max_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : preorder.{v} β], (α → β) → set.{u} α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='orange'><a title='`is_local_max_on f s a` means that `f x ≤ f a` for all `x ∈ s` in some neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140    (hf : differentiable_within_at ℝ f s a) {y} (hy : y ∈ pos_tangent_cone_at s a) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='differentiable_within_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pos_tangent_cone_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 108, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {F : Type u_3} [_inst_4 : normed_group.{u_3} F] [_inst_5 : @normed_space.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4], (E → F) → set.{u_2} E → E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1], set.{u} E → E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' A function `f` is differentiable at a point `x` within a set `s` if it admits a derivative
there (possibly non-unique).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title=' &quot;Positive&quot; tangent cone to `s` at `x`; the only difference from `tangent_cone_at`
is that we require `c n → ∞` instead of `∥c n∥ → ∞`. One can think about `pos_tangent_cone_at`
as `tangent_cone_at nnreal` but we have no theory of normed semifields yet.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141    (fderiv_within ℝ f s a : E → ℝ) y ≤ 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='fderiv_within'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {F : Type u_3} [_inst_4 : normed_group.{u_3} F] [_inst_5 : @normed_space.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4], (E → F) → set.{u_2} E → E → @continuous_linear_map.{u_1 u_2 u_3} 𝕜 (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) F (@uniform_space.to_topological_space.{u_3} F (@metric_space.to_uniform_space&#x27;.{u_3} F (@normed_group.to_metric_space.{u_3} F _inst_4))) (@normed_group.to_add_comm_group.{u_3} F _inst_4) (@normed_space.to_module.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4 _inst_5)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' If `f` has a derivative at `x` within `s`, then `fderiv_within 𝕜 f s x` is such a derivative.
Otherwise, it is set to `0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142  h.has_fderiv_within_at_nonpos hf.has_fderiv_within_at hy</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_local_max_on.has_fderiv_within_at_nonpos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='differentiable_within_at.has_fderiv_within_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_local_max_on.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f s a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1] {f : E → real} {a : E} {f&#x27; : @continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)} {s : set.{u} E}, @is_local_max_on.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f s a → @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; s a → ∀ {y : E}, @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a) → @has_le.le.{0} real real.has_le (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)) (@continuous_linear_map.to_fun.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)) f&#x27; y) (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@differentiable_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f s a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type} [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {E : Type u} [_inst_2 : normed_group.{u} E] [_inst_3 : @normed_space.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {F : Type} [_inst_4 : normed_group.{0} F] [_inst_5 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4] {f : E → F} {x : E} {s : set.{u} E}, @differentiable_within_at.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f s x → @has_fderiv_within_at.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f (@fderiv_within.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f s x) s x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' If `f` has a local max on `s` at `a`, `f&#x27;` is the derivative of `f` at `a` within `s`, and
`y` belongs to the positive tangent cone of s at a, then `f&#x27; y ≤ 0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144  /-- If `f` has a local max on `s` at `a`, `f&#x27;` is a derivative of `f` at `a` within `s`, and</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145  both `y` and `-y` belong to the positive tangent cone of s at a, then `f&#x27; y ≤ 0`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146  lemma is_local_max_on.has_fderiv_within_at_eq_zero {s : set E} (h : is_local_max_on f s a)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='is_local_max_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : preorder.{v} β], (α → β) → set.{u} α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                    </code><font color='orange'><a title='`is_local_max_on f s a` means that `f x ≤ f a` for all `x ∈ s` in some neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147    (hf : has_fderiv_within_at f f&#x27; s a) {y} (hy : y ∈ pos_tangent_cone_at s a)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='has_fderiv_within_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pos_tangent_cone_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 96, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {F : Type u_3} [_inst_4 : normed_group.{u_3} F] [_inst_5 : @normed_space.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4], (E → F) → @continuous_linear_map.{u_1 u_2 u_3} 𝕜 (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) F (@uniform_space.to_topological_space.{u_3} F (@metric_space.to_uniform_space&#x27;.{u_3} F (@normed_group.to_metric_space.{u_3} F _inst_4))) (@normed_group.to_add_comm_group.{u_3} F _inst_4) (@normed_space.to_module.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4 _inst_5) → set.{u_2} E → E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1], set.{u} E → E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' A function `f` has the continuous linear map `f&#x27;` as derivative at `x` within a set `s` if
`f x&#x27; = f x + f&#x27; (x&#x27; - x) + o (x&#x27; - x)` when `x&#x27;` tends to `x` inside `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title=' &quot;Positive&quot; tangent cone to `s` at `x`; the only difference from `tangent_cone_at`
is that we require `c n → ∞` instead of `∥c n∥ → ∞`. One can think about `pos_tangent_cone_at`
as `tangent_cone_at nnreal` but we have no theory of normed semifields yet.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148    (hy&#x27; : -y ∈ pos_tangent_cone_at s a) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pos_tangent_cone_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1], set.{u} E → E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title=' &quot;Positive&quot; tangent cone to `s` at `x`; the only difference from `tangent_cone_at`
is that we require `c n → ∞` instead of `∥c n∥ → ∞`. One can think about `pos_tangent_cone_at`
as `tangent_cone_at nnreal` but we have no theory of normed semifields yet.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149    f&#x27; y = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150  le_antisymm (h.has_fderiv_within_at_nonpos hf hy) $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_local_max_on.has_fderiv_within_at_nonpos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : partial_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) b a → @eq.{1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_local_max_on.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f s a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1] {f : E → real} {a : E} {f&#x27; : @continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)} {s : set.{u} E}, @is_local_max_on.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f s a → @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; s a → ∀ {y : E}, @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a) → @has_le.le.{0} real real.has_le (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)) (@continuous_linear_map.to_fun.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)) f&#x27; y) (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; s a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title=' If `f` has a local max on `s` at `a`, `f&#x27;` is the derivative of `f` at `a` within `s`, and
`y` belongs to the positive tangent cone of s at a, then `f&#x27; y ≤ 0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151    by simpa using h.has_fderiv_within_at_nonpos hf hy&#x27;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 117, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_local_max_on.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f s a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; s a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) (@has_neg.neg.{u} E (@add_group.to_has_neg.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))) y) (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' If `f` has a local max on `s` at `a`, `f&#x27;` is the derivative of `f` at `a` within `s`, and
`y` belongs to the positive tangent cone of s at a, then `f&#x27; y ≤ 0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
hy : @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a),
hy&#x27; :
  @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
    (@has_neg.neg.{u} E
       (@add_group.to_has_neg.{u} E
          (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
       y)
    (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a)
⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real (@partial_order.to_preorder.{0} real real.partial_order))
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       f&#x27;
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
hy : @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a),
hy&#x27; :
  @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
    (@has_neg.neg.{u} E
       (@add_group.to_has_neg.{u} E
          (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
       y)
    (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a)
⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real (@partial_order.to_preorder.{0} real real.partial_order))
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       f&#x27;
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  /-- If `f` has a local max on `s` at `a` and both `y` and `-y` belong to the positive tangent cone</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154  of s at a, then `f&#x27; y = 0`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155  lemma is_local_max_on.fderiv_within_eq_zero {s : set E} (h : is_local_max_on f s a)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='is_local_max_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : preorder.{v} β], (α → β) → set.{u} α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='orange'><a title='`is_local_max_on f s a` means that `f x ≤ f a` for all `x ∈ s` in some neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156    {y} (hy : y ∈ pos_tangent_cone_at s a) (hy&#x27; : -y ∈ pos_tangent_cone_at s a) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pos_tangent_cone_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pos_tangent_cone_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1], set.{u} E → E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1], set.{u} E → E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title=' &quot;Positive&quot; tangent cone to `s` at `x`; the only difference from `tangent_cone_at`
is that we require `c n → ∞` instead of `∥c n∥ → ∞`. One can think about `pos_tangent_cone_at`
as `tangent_cone_at nnreal` but we have no theory of normed semifields yet.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title=' &quot;Positive&quot; tangent cone to `s` at `x`; the only difference from `tangent_cone_at`
is that we require `c n → ∞` instead of `∥c n∥ → ∞`. One can think about `pos_tangent_cone_at`
as `tangent_cone_at nnreal` but we have no theory of normed semifields yet.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157    (fderiv_within ℝ f s a : E → ℝ) y = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='fderiv_within'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {F : Type u_3} [_inst_4 : normed_group.{u_3} F] [_inst_5 : @normed_space.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4], (E → F) → set.{u_2} E → E → @continuous_linear_map.{u_1 u_2 u_3} 𝕜 (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) F (@uniform_space.to_topological_space.{u_3} F (@metric_space.to_uniform_space&#x27;.{u_3} F (@normed_group.to_metric_space.{u_3} F _inst_4))) (@normed_group.to_add_comm_group.{u_3} F _inst_4) (@normed_space.to_module.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4 _inst_5)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' If `f` has a derivative at `x` within `s`, then `fderiv_within 𝕜 f s x` is such a derivative.
Otherwise, it is set to `0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158  if hf : differentiable_within_at ℝ f s a</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='differentiable_within_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 609, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 108, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (c : Prop) [h : decidable c] {α : Prop}, (c → α) → (not c → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (𝕜 : Type) [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {E : Type u} [_inst_2 : normed_group.{u} E] [_inst_3 : @normed_space.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {F : Type} [_inst_4 : normed_group.{0} F] [_inst_5 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4], (E → F) → set.{u} E → E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' A function `f` is differentiable at a point `x` within a set `s` if it admits a derivative
there (possibly non-unique).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159  then h.has_fderiv_within_at_eq_zero hf.has_fderiv_within_at hy hy&#x27;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_local_max_on.has_fderiv_within_at_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='differentiable_within_at.has_fderiv_within_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 146, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@is_local_max_on.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f s a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1] {f : E → real} {a : E} {f&#x27; : @continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)} {s : set.{u} E}, @is_local_max_on.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f s a → @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; s a → ∀ {y : E}, @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a) → @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) (@has_neg.neg.{u} E (@add_group.to_has_neg.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))) y) (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a) → @eq.{1} real (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)) (@continuous_linear_map.to_fun.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)) f&#x27; y) (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@differentiable_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f s a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type} [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {E : Type u} [_inst_2 : normed_group.{u} E] [_inst_3 : @normed_space.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {F : Type} [_inst_4 : normed_group.{0} F] [_inst_5 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4] {f : E → F} {x : E} {s : set.{u} E}, @differentiable_within_at.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f s x → @has_fderiv_within_at.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f (@fderiv_within.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f s x) s x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) (@has_neg.neg.{u} E (@add_group.to_has_neg.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))) y) (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' If `f` has a local max on `s` at `a`, `f&#x27;` is a derivative of `f` at `a` within `s`, and
both `y` and `-y` belong to the positive tangent cone of s at a, then `f&#x27; y ≤ 0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160  else by { rw fderiv_within_zero_of_not_differentiable_within_at hf, refl }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='not'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='fderiv_within_zero_of_not_differentiable_within_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type} [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {E : Type u} [_inst_2 : normed_group.{u} E] [_inst_3 : @normed_space.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {F : Type} [_inst_4 : normed_group.{0} F] [_inst_5 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4] {f : E → F} {x : E} {s : set.{u} E}, not (@differentiable_within_at.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f s x) → @eq.{(max (u+1) 1)} (@continuous_linear_map.{0 u 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_2))) (@normed_group.to_add_comm_group.{u} E _inst_2) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_4))) (@normed_group.to_add_comm_group.{0} F _inst_4) (@normed_space.to_module.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4 _inst_5)) (@fderiv_within.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f s x) (@has_zero.zero.{u} (@continuous_linear_map.{0 u 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_2))) (@normed_group.to_add_comm_group.{u} E _inst_2) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_4))) (@normed_group.to_add_comm_group.{0} F _inst_4) (@normed_space.to_module.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4 _inst_5)) (@continuous_linear_map.has_zero.{0 u 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_2))) (@normed_group.to_add_comm_group.{u} E _inst_2) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_4))) (@normed_group.to_add_comm_group.{0} F _inst_4) (@normed_space.to_module.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4 _inst_5)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@differentiable_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f s a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
y : E,
hy : @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a),
hy&#x27; :
  @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
    (@has_neg.neg.{u} E
       (@add_group.to_has_neg.{u} E
          (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
       y)
    (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a),
hf :
  not
    (@differentiable_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
       (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
       (@normed_field.to_normed_space.{0} real
          (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
       f
       s
       a)
⊢ @eq.{1} real
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real
             (@metric_space.to_uniform_space&#x27;.{0} real
                (@normed_group.to_metric_space.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          (@normed_space.to_module.{0 u} real E
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             _inst_1
             _inst_2)
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
       (@continuous_linear_map.to_fun.{0 u 0} real
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real
             (@metric_space.to_uniform_space&#x27;.{0} real
                (@normed_group.to_metric_space.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          (@normed_space.to_module.{0 u} real E
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             _inst_1
             _inst_2)
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
       (@fderiv_within.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          (@normed_field.to_normed_space.{0} real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
          f
          s
          a)
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
s : set.{u} E,
h :
  @is_local_max_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
y : E,
hy : @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a),
hy&#x27; :
  @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
    (@has_neg.neg.{u} E
       (@add_group.to_has_neg.{u} E
          (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
       y)
    (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a),
hf :
  not
    (@differentiable_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
       (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
       (@normed_field.to_normed_space.{0} real
          (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
       f
       s
       a)
⊢ @eq.{1} real
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real
             (@metric_space.to_uniform_space&#x27;.{0} real
                (@normed_group.to_metric_space.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          (@normed_space.to_module.{0 u} real E
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             _inst_1
             _inst_2)
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
       (@continuous_linear_map.to_fun.{0 u 0} real
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real
             (@metric_space.to_uniform_space&#x27;.{0} real
                (@normed_group.to_metric_space.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          (@normed_space.to_module.{0 u} real E
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             _inst_1
             _inst_2)
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
       (@has_zero.zero.{u}
          (@continuous_linear_map.{0 u 0} real
             (@normed_ring.to_ring.{0} real
                (@normed_field.to_normed_ring.{0} real
                   (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
             E
             (@uniform_space.to_topological_space.{u} E
                (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
             (@normed_group.to_add_comm_group.{u} E _inst_1)
             real
             (@uniform_space.to_topological_space.{0} real
                (@metric_space.to_uniform_space&#x27;.{0} real
                   (@normed_group.to_metric_space.{0} real
                      (@normed_ring.to_normed_group.{0} real
                         (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
             (@normed_group.to_add_comm_group.{0} real
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
             (@normed_space.to_module.{0 u} real E
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                _inst_1
                _inst_2)
             (@normed_space.to_module.{0 0} real real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                (@normed_field.to_normed_space.{0} real
                   (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
          (@continuous_linear_map.has_zero.{0 u 0} real
             (@normed_ring.to_ring.{0} real
                (@normed_field.to_normed_ring.{0} real
                   (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
             E
             (@uniform_space.to_topological_space.{u} E
                (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
             (@normed_group.to_add_comm_group.{u} E _inst_1)
             real
             (@uniform_space.to_topological_space.{0} real
                (@metric_space.to_uniform_space&#x27;.{0} real
                   (@normed_group.to_metric_space.{0} real
                      (@normed_ring.to_normed_group.{0} real
                         (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
             (@normed_group.to_add_comm_group.{0} real
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
             (@normed_space.to_module.{0 u} real E
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                _inst_1
                _inst_2)
             (@normed_space.to_module.{0 0} real real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                (@normed_field.to_normed_space.{0} real
                   (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))))
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162  /-- If `f` has a local min on `s` at `a`, `f&#x27;` is the derivative of `f` at `a` within `s`, and</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  `y` belongs to the positive tangent cone of s at a, then `0 ≤ f&#x27; y`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164  lemma is_local_min_on.has_fderiv_within_at_nonneg {s : set E} (h : is_local_min_on f s a)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='is_local_min_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : preorder.{v} β], (α → β) → set.{u} α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                   </code><font color='orange'><a title='`is_local_min_on f s a` means that `f a ≤ f x` for all `x ∈ s` in some neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165    (hf : has_fderiv_within_at f f&#x27; s a) {y} (hy : y ∈ pos_tangent_cone_at s a) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='has_fderiv_within_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pos_tangent_cone_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 96, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {F : Type u_3} [_inst_4 : normed_group.{u_3} F] [_inst_5 : @normed_space.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4], (E → F) → @continuous_linear_map.{u_1 u_2 u_3} 𝕜 (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) F (@uniform_space.to_topological_space.{u_3} F (@metric_space.to_uniform_space&#x27;.{u_3} F (@normed_group.to_metric_space.{u_3} F _inst_4))) (@normed_group.to_add_comm_group.{u_3} F _inst_4) (@normed_space.to_module.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4 _inst_5) → set.{u_2} E → E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1], set.{u} E → E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' A function `f` has the continuous linear map `f&#x27;` as derivative at `x` within a set `s` if
`f x&#x27; = f x + f&#x27; (x&#x27; - x) + o (x&#x27; - x)` when `x&#x27;` tends to `x` inside `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title=' &quot;Positive&quot; tangent cone to `s` at `x`; the only difference from `tangent_cone_at`
is that we require `c n → ∞` instead of `∥c n∥ → ∞`. One can think about `pos_tangent_cone_at`
as `tangent_cone_at nnreal` but we have no theory of normed semifields yet.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166    0 ≤ f&#x27; y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167  by simpa using h.neg.has_fderiv_within_at_nonpos hf.neg hy</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 294, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 923, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_local_min_on.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f s a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; s a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' If `f` has a local max on `s` at `a`, `f&#x27;` is the derivative of `f` at `a` within `s`, and
`y` belongs to the positive tangent cone of s at a, then `f&#x27; y ≤ 0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_min_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
hy : @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a)
⊢ @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       f&#x27;
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_min_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
hy : @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a)
⊢ @has_le.le.{0} real real.has_le
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       f&#x27;
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169  /-- If `f` has a local min on `s` at `a`, `f` is differentiable at `a` within `s`, and</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170  `y` belongs to the positive tangent cone of s at a, then `0 ≤ f&#x27; y`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171  lemma is_local_min_on.fderiv_within_nonneg {s : set E} (h : is_local_min_on f s a)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='is_local_min_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : preorder.{v} β], (α → β) → set.{u} α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='orange'><a title='`is_local_min_on f s a` means that `f a ≤ f x` for all `x ∈ s` in some neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172    (hf : differentiable_within_at ℝ f s a) {y} (hy : y ∈ pos_tangent_cone_at s a) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='differentiable_within_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pos_tangent_cone_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 108, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {F : Type u_3} [_inst_4 : normed_group.{u_3} F] [_inst_5 : @normed_space.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4], (E → F) → set.{u_2} E → E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1], set.{u} E → E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' A function `f` is differentiable at a point `x` within a set `s` if it admits a derivative
there (possibly non-unique).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title=' &quot;Positive&quot; tangent cone to `s` at `x`; the only difference from `tangent_cone_at`
is that we require `c n → ∞` instead of `∥c n∥ → ∞`. One can think about `pos_tangent_cone_at`
as `tangent_cone_at nnreal` but we have no theory of normed semifields yet.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173    (0:ℝ) ≤ (fderiv_within ℝ f s a : E → ℝ) y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='fderiv_within'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {F : Type u_3} [_inst_4 : normed_group.{u_3} F] [_inst_5 : @normed_space.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4], (E → F) → set.{u_2} E → E → @continuous_linear_map.{u_1 u_2 u_3} 𝕜 (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) F (@uniform_space.to_topological_space.{u_3} F (@metric_space.to_uniform_space&#x27;.{u_3} F (@normed_group.to_metric_space.{u_3} F _inst_4))) (@normed_group.to_add_comm_group.{u_3} F _inst_4) (@normed_space.to_module.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4 _inst_5)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title=' If `f` has a derivative at `x` within `s`, then `fderiv_within 𝕜 f s x` is such a derivative.
Otherwise, it is set to `0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174  h.has_fderiv_within_at_nonneg hf.has_fderiv_within_at hy</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_local_min_on.has_fderiv_within_at_nonneg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='differentiable_within_at.has_fderiv_within_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 164, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_local_min_on.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f s a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1] {f : E → real} {a : E} {f&#x27; : @continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)} {s : set.{u} E}, @is_local_min_on.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f s a → @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; s a → ∀ {y : E}, @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a) → @has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)) (@continuous_linear_map.to_fun.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)) f&#x27; y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@differentiable_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f s a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type} [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {E : Type u} [_inst_2 : normed_group.{u} E] [_inst_3 : @normed_space.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {F : Type} [_inst_4 : normed_group.{0} F] [_inst_5 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4] {f : E → F} {x : E} {s : set.{u} E}, @differentiable_within_at.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f s x → @has_fderiv_within_at.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f (@fderiv_within.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f s x) s x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' If `f` has a local min on `s` at `a`, `f&#x27;` is the derivative of `f` at `a` within `s`, and
`y` belongs to the positive tangent cone of s at a, then `0 ≤ f&#x27; y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176  /-- If `f` has a local max on `s` at `a`, `f&#x27;` is a derivative of `f` at `a` within `s`, and</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177  both `y` and `-y` belong to the positive tangent cone of s at a, then `f&#x27; y ≤ 0`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178  lemma is_local_min_on.has_fderiv_within_at_eq_zero {s : set E} (h : is_local_min_on f s a)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='is_local_min_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : preorder.{v} β], (α → β) → set.{u} α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                    </code><font color='orange'><a title='`is_local_min_on f s a` means that `f a ≤ f x` for all `x ∈ s` in some neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179    (hf : has_fderiv_within_at f f&#x27; s a) {y} (hy : y ∈ pos_tangent_cone_at s a)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='has_fderiv_within_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pos_tangent_cone_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 96, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {F : Type u_3} [_inst_4 : normed_group.{u_3} F] [_inst_5 : @normed_space.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4], (E → F) → @continuous_linear_map.{u_1 u_2 u_3} 𝕜 (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) F (@uniform_space.to_topological_space.{u_3} F (@metric_space.to_uniform_space&#x27;.{u_3} F (@normed_group.to_metric_space.{u_3} F _inst_4))) (@normed_group.to_add_comm_group.{u_3} F _inst_4) (@normed_space.to_module.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4 _inst_5) → set.{u_2} E → E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1], set.{u} E → E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' A function `f` has the continuous linear map `f&#x27;` as derivative at `x` within a set `s` if
`f x&#x27; = f x + f&#x27; (x&#x27; - x) + o (x&#x27; - x)` when `x&#x27;` tends to `x` inside `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title=' &quot;Positive&quot; tangent cone to `s` at `x`; the only difference from `tangent_cone_at`
is that we require `c n → ∞` instead of `∥c n∥ → ∞`. One can think about `pos_tangent_cone_at`
as `tangent_cone_at nnreal` but we have no theory of normed semifields yet.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180    (hy&#x27; : -y ∈ pos_tangent_cone_at s a) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pos_tangent_cone_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1], set.{u} E → E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title=' &quot;Positive&quot; tangent cone to `s` at `x`; the only difference from `tangent_cone_at`
is that we require `c n → ∞` instead of `∥c n∥ → ∞`. One can think about `pos_tangent_cone_at`
as `tangent_cone_at nnreal` but we have no theory of normed semifields yet.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181    f&#x27; y = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182  by simpa using h.neg.has_fderiv_within_at_eq_zero hf.neg hy hy&#x27;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 294, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 923, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_local_min_on.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f s a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; s a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) (@has_neg.neg.{u} E (@add_group.to_has_neg.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))) y) (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' If `f` has a local max on `s` at `a`, `f&#x27;` is a derivative of `f` at `a` within `s`, and
both `y` and `-y` belong to the positive tangent cone of s at a, then `f&#x27; y ≤ 0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_min_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
hy : @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a),
hy&#x27; :
  @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
    (@has_neg.neg.{u} E
       (@add_group.to_has_neg.{u} E
          (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
       y)
    (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a)
⊢ @eq.{1} real
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       f&#x27;
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
s : set.{u} E,
h :
  @is_local_min_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
hf :
  @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    s
    a,
y : E,
hy : @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a),
hy&#x27; :
  @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
    (@has_neg.neg.{u} E
       (@add_group.to_has_neg.{u} E
          (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
       y)
    (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a)
⊢ @eq.{1} real
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       f&#x27;
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184  /-- If `f` has a local min on `s` at `a` and both `y` and `-y` belong to the positive tangent cone</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185  of s at a, then `f&#x27; y = 0`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186  lemma is_local_min_on.fderiv_within_eq_zero {s : set E} (h : is_local_min_on f s a)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='is_local_min_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : preorder.{v} β], (α → β) → set.{u} α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='orange'><a title='`is_local_min_on f s a` means that `f a ≤ f x` for all `x ∈ s` in some neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187    {y} (hy : y ∈ pos_tangent_cone_at s a) (hy&#x27; : -y ∈ pos_tangent_cone_at s a) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pos_tangent_cone_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='has_neg.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='pos_tangent_cone_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 314, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 73, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1], set.{u} E → E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {α : Type u} [c : has_neg.{u} α], α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1], set.{u} E → E → set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title=' &quot;Positive&quot; tangent cone to `s` at `x`; the only difference from `tangent_cone_at`
is that we require `c n → ∞` instead of `∥c n∥ → ∞`. One can think about `pos_tangent_cone_at`
as `tangent_cone_at nnreal` but we have no theory of normed semifields yet.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title=' &quot;Positive&quot; tangent cone to `s` at `x`; the only difference from `tangent_cone_at`
is that we require `c n → ∞` instead of `∥c n∥ → ∞`. One can think about `pos_tangent_cone_at`
as `tangent_cone_at nnreal` but we have no theory of normed semifields yet.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188    (fderiv_within ℝ f s a : E → ℝ) y = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='fderiv_within'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {F : Type u_3} [_inst_4 : normed_group.{u_3} F] [_inst_5 : @normed_space.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4], (E → F) → set.{u_2} E → E → @continuous_linear_map.{u_1 u_2 u_3} 𝕜 (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) F (@uniform_space.to_topological_space.{u_3} F (@metric_space.to_uniform_space&#x27;.{u_3} F (@normed_group.to_metric_space.{u_3} F _inst_4))) (@normed_group.to_add_comm_group.{u_3} F _inst_4) (@normed_space.to_module.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4 _inst_5)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title=' If `f` has a derivative at `x` within `s`, then `fderiv_within 𝕜 f s x` is such a derivative.
Otherwise, it is set to `0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189  if hf : differentiable_within_at ℝ f s a</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='differentiable_within_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 609, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 108, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (c : Prop) [h : decidable c] {α : Prop}, (c → α) → (not c → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (𝕜 : Type) [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {E : Type u} [_inst_2 : normed_group.{u} E] [_inst_3 : @normed_space.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {F : Type} [_inst_4 : normed_group.{0} F] [_inst_5 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4], (E → F) → set.{u} E → E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' A function `f` is differentiable at a point `x` within a set `s` if it admits a derivative
there (possibly non-unique).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190  then h.has_fderiv_within_at_eq_zero hf.has_fderiv_within_at hy hy&#x27;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_local_min_on.has_fderiv_within_at_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='differentiable_within_at.has_fderiv_within_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hy&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 178, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@is_local_min_on.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f s a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1] {f : E → real} {a : E} {f&#x27; : @continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)} {s : set.{u} E}, @is_local_min_on.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f s a → @has_fderiv_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; s a → ∀ {y : E}, @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a) → @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) (@has_neg.neg.{u} E (@add_group.to_has_neg.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))) y) (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a) → @eq.{1} real (@coe_fn.{(max (u+1) 1) (max (u+1) 1)} (@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)) (@continuous_linear_map.to_fun.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)) f&#x27; y) (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@differentiable_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f s a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type} [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {E : Type u} [_inst_2 : normed_group.{u} E] [_inst_3 : @normed_space.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {F : Type} [_inst_4 : normed_group.{0} F] [_inst_5 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4] {f : E → F} {x : E} {s : set.{u} E}, @differentiable_within_at.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f s x → @has_fderiv_within_at.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f (@fderiv_within.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f s x) s x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) (@has_neg.neg.{u} E (@add_group.to_has_neg.{u} E (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1))) y) (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' If `f` has a local max on `s` at `a`, `f&#x27;` is a derivative of `f` at `a` within `s`, and
both `y` and `-y` belong to the positive tangent cone of s at a, then `f&#x27; y ≤ 0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191  else by { rw fderiv_within_zero_of_not_differentiable_within_at hf, refl }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='fderiv_within_zero_of_not_differentiable_within_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 142, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='not (@differentiable_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f s a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type} [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {E : Type u} [_inst_2 : normed_group.{u} E] [_inst_3 : @normed_space.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {F : Type} [_inst_4 : normed_group.{0} F] [_inst_5 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4] {f : E → F} {x : E} {s : set.{u} E}, not (@differentiable_within_at.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f s x) → @eq.{(max (u+1) 1)} (@continuous_linear_map.{0 u 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_2))) (@normed_group.to_add_comm_group.{u} E _inst_2) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_4))) (@normed_group.to_add_comm_group.{0} F _inst_4) (@normed_space.to_module.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4 _inst_5)) (@fderiv_within.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f s x) (@has_zero.zero.{u} (@continuous_linear_map.{0 u 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_2))) (@normed_group.to_add_comm_group.{u} E _inst_2) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_4))) (@normed_group.to_add_comm_group.{0} F _inst_4) (@normed_space.to_module.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4 _inst_5)) (@continuous_linear_map.has_zero.{0 u 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_2))) (@normed_group.to_add_comm_group.{u} E _inst_2) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_4))) (@normed_group.to_add_comm_group.{0} F _inst_4) (@normed_space.to_module.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4 _inst_5)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@differentiable_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f s a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
s : set.{u} E,
h :
  @is_local_min_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
y : E,
hy : @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a),
hy&#x27; :
  @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
    (@has_neg.neg.{u} E
       (@add_group.to_has_neg.{u} E
          (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
       y)
    (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a),
hf :
  not
    (@differentiable_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
       (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
       (@normed_field.to_normed_space.{0} real
          (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
       f
       s
       a)
⊢ @eq.{1} real
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real
             (@metric_space.to_uniform_space&#x27;.{0} real
                (@normed_group.to_metric_space.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          (@normed_space.to_module.{0 u} real E
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             _inst_1
             _inst_2)
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
       (@continuous_linear_map.to_fun.{0 u 0} real
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real
             (@metric_space.to_uniform_space&#x27;.{0} real
                (@normed_group.to_metric_space.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          (@normed_space.to_module.{0 u} real E
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             _inst_1
             _inst_2)
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
       (@fderiv_within.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
          (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
          (@normed_field.to_normed_space.{0} real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
          f
          s
          a)
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
s : set.{u} E,
h :
  @is_local_min_on.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    s
    a,
y : E,
hy : @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a),
hy&#x27; :
  @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E)
    (@has_neg.neg.{u} E
       (@add_group.to_has_neg.{u} E
          (@add_comm_group.to_add_group.{u} E (@normed_group.to_add_comm_group.{u} E _inst_1)))
       y)
    (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 s a),
hf :
  not
    (@differentiable_within_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
       (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
       (@normed_field.to_normed_space.{0} real
          (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
       f
       s
       a)
⊢ @eq.{1} real
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real
             (@metric_space.to_uniform_space&#x27;.{0} real
                (@normed_group.to_metric_space.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          (@normed_space.to_module.{0 u} real E
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             _inst_1
             _inst_2)
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
       (@continuous_linear_map.to_fun.{0 u 0} real
          (@normed_ring.to_ring.{0} real
             (@normed_field.to_normed_ring.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
          E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real
             (@metric_space.to_uniform_space&#x27;.{0} real
                (@normed_group.to_metric_space.{0} real
                   (@normed_ring.to_normed_group.{0} real
                      (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
          (@normed_group.to_add_comm_group.{0} real
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
          (@normed_space.to_module.{0 u} real E
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             _inst_1
             _inst_2)
          (@normed_space.to_module.{0 0} real real
             (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
             (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
             (@normed_field.to_normed_space.{0} real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
       (@has_zero.zero.{u}
          (@continuous_linear_map.{0 u 0} real
             (@normed_ring.to_ring.{0} real
                (@normed_field.to_normed_ring.{0} real
                   (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
             E
             (@uniform_space.to_topological_space.{u} E
                (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
             (@normed_group.to_add_comm_group.{u} E _inst_1)
             real
             (@uniform_space.to_topological_space.{0} real
                (@metric_space.to_uniform_space&#x27;.{0} real
                   (@normed_group.to_metric_space.{0} real
                      (@normed_ring.to_normed_group.{0} real
                         (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
             (@normed_group.to_add_comm_group.{0} real
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
             (@normed_space.to_module.{0 u} real E
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                _inst_1
                _inst_2)
             (@normed_space.to_module.{0 0} real real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                (@normed_field.to_normed_space.{0} real
                   (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))))
          (@continuous_linear_map.has_zero.{0 u 0} real
             (@normed_ring.to_ring.{0} real
                (@normed_field.to_normed_ring.{0} real
                   (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))
             E
             (@uniform_space.to_topological_space.{u} E
                (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
             (@normed_group.to_add_comm_group.{u} E _inst_1)
             real
             (@uniform_space.to_topological_space.{0} real
                (@metric_space.to_uniform_space&#x27;.{0} real
                   (@normed_group.to_metric_space.{0} real
                      (@normed_ring.to_normed_group.{0} real
                         (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))))
             (@normed_group.to_add_comm_group.{0} real
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field)))
             (@normed_space.to_module.{0 u} real E
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                _inst_1
                _inst_2)
             (@normed_space.to_module.{0 0} real real
                (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)
                (@normed_ring.to_normed_group.{0} real
                   (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
                (@normed_field.to_normed_space.{0} real
                   (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))))
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193  /-- Fermat&#x27;s Theorem: the derivative of a function at a local minimum equals zero. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194  lemma is_local_min.has_fderiv_at_eq_zero (h : is_local_min f a) (hf : has_fderiv_at f f&#x27; a) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='blue'><a title='is_local_min'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='has_fderiv_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : preorder.{v} β], (α → β) → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {F : Type u_3} [_inst_4 : normed_group.{u_3} F] [_inst_5 : @normed_space.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4], (E → F) → @continuous_linear_map.{u_1 u_2 u_3} 𝕜 (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) F (@uniform_space.to_topological_space.{u_3} F (@metric_space.to_uniform_space&#x27;.{u_3} F (@normed_group.to_metric_space.{u_3} F _inst_4))) (@normed_group.to_add_comm_group.{u_3} F _inst_4) (@normed_space.to_module.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4 _inst_5) → E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='orange'><a title='`is_local_min f a` means that `f a ≤ f x` for all `x` in some neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title=' A function `f` has the continuous linear map `f&#x27;` as derivative at `x` if
`f x&#x27; = f x + f&#x27; (x&#x27; - x) + o (x&#x27; - x)` when `x&#x27;` tends to `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195    f&#x27; = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
h :
  @is_local_min.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    a,
hf :
  @has_fderiv_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    a
⊢ @eq.{(max (u+1) 1)}
    (@continuous_linear_map.{0 u 0} real real.ring E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@normed_group.to_add_comm_group.{u} E _inst_1)
       real
       (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
       real.add_comm_group
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       (@discrete_field.to_vector_space.{0} real real.discrete_field))
    f&#x27;
    (@has_zero.zero.{u}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.has_zero.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197    ext y,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
h :
  @is_local_min.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    a,
hf :
  @has_fderiv_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    a
⊢ @eq.{(max (u+1) 1)}
    (@continuous_linear_map.{0 u 0} real real.ring E
       (@uniform_space.to_topological_space.{u} E
          (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
       (@normed_group.to_add_comm_group.{u} E _inst_1)
       real
       (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
       real.add_comm_group
       (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
       (@discrete_field.to_vector_space.{0} real real.discrete_field))
    f&#x27;
    (@has_zero.zero.{u}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.has_zero.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
h :
  @is_local_min.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    a,
hf :
  @has_fderiv_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    a,
y : E
⊢ @eq.{1} real
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       f&#x27;
       y)
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@has_zero.zero.{u}
          (@continuous_linear_map.{0 u 0} real real.ring E
             (@uniform_space.to_topological_space.{u} E
                (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
             (@normed_group.to_add_comm_group.{u} E _inst_1)
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.has_zero.{0 u 0} real real.ring E
             (@uniform_space.to_topological_space.{u} E
                (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
             (@normed_group.to_add_comm_group.{u} E _inst_1)
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
             (@discrete_field.to_vector_space.{0} real real.discrete_field)))
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198    apply (h.on univ).has_fderiv_within_at_eq_zero hf.has_fderiv_within_at;</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set.univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_local_min.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_fderiv_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
h :
  @is_local_min.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    a,
hf :
  @has_fderiv_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    a,
y : E
⊢ @eq.{1} real
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       f&#x27;
       y)
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@has_zero.zero.{u}
          (@continuous_linear_map.{0 u 0} real real.ring E
             (@uniform_space.to_topological_space.{u} E
                (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
             (@normed_group.to_add_comm_group.{u} E _inst_1)
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.has_zero.{0 u 0} real real.ring E
             (@uniform_space.to_topological_space.{u} E
                (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
             (@normed_group.to_add_comm_group.{u} E _inst_1)
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
             (@discrete_field.to_vector_space.{0} real real.discrete_field)))
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199      rw pos_tangent_cone_at_univ; apply mem_univ</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='pos_tangent_cone_at_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='set.mem_univ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 107, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 235, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1] {a : E}, @eq.{(max (u+1) 1)} (set.{u} E) (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 (@set.univ.{u} E) a) (@set.univ.{u} E)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} (x : α), @has_mem.mem.{u u} α (set.{u} α) (@set.has_mem.{u} α) x (@set.univ.{u} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
h :
  @is_local_min.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    a,
hf :
  @has_fderiv_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    a,
y : E
⊢ @eq.{1} real
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       f&#x27;
       y)
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@has_zero.zero.{u}
          (@continuous_linear_map.{0 u 0} real real.ring E
             (@uniform_space.to_topological_space.{u} E
                (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
             (@normed_group.to_add_comm_group.{u} E _inst_1)
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.has_zero.{0 u 0} real real.ring E
             (@uniform_space.to_topological_space.{u} E
                (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
             (@normed_group.to_add_comm_group.{u} E _inst_1)
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
             (@discrete_field.to_vector_space.{0} real real.discrete_field)))
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
h :
  @is_local_min.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    a,
hf :
  @has_fderiv_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    a,
y : E
⊢ @has_mem.mem.{u u} E (set.{u} E) (@set.has_mem.{u} E) y
    (@pos_tangent_cone_at.{u} E _inst_1 _inst_2 (@set.univ.{u} E) a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='E : Type u,
_inst_1 : normed_group.{u} E,
_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1,
f : E → real,
a : E,
f&#x27; :
  @continuous_linear_map.{0 u 0} real real.ring E
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    (@normed_group.to_add_comm_group.{u} E _inst_1)
    real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.add_comm_group
    (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
    (@discrete_field.to_vector_space.{0} real real.discrete_field),
h :
  @is_local_min.{u 0} E real
    (@uniform_space.to_topological_space.{u} E
       (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
    real.preorder
    f
    a,
hf :
  @has_fderiv_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    a,
y : E
⊢ @eq.{1} real
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       f&#x27;
       y)
    (@coe_fn.{(max (u+1) 1) (max (u+1) 1)}
       (@continuous_linear_map.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@continuous_linear_map.to_fun.{0 u 0} real real.ring E
          (@uniform_space.to_topological_space.{u} E
             (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
          (@normed_group.to_add_comm_group.{u} E _inst_1)
          real
          (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
          real.add_comm_group
          (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
          (@discrete_field.to_vector_space.{0} real real.discrete_field))
       (@has_zero.zero.{u}
          (@continuous_linear_map.{0 u 0} real real.ring E
             (@uniform_space.to_topological_space.{u} E
                (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
             (@normed_group.to_add_comm_group.{u} E _inst_1)
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
             (@discrete_field.to_vector_space.{0} real real.discrete_field))
          (@continuous_linear_map.has_zero.{0 u 0} real real.ring E
             (@uniform_space.to_topological_space.{u} E
                (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1)))
             (@normed_group.to_add_comm_group.{u} E _inst_1)
             real
             (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
             real.add_comm_group
             (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2)
             (@discrete_field.to_vector_space.{0} real real.discrete_field)))
       y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202  /-- Fermat&#x27;s Theorem: the derivative of a function at a local minimum equals zero. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203  lemma is_local_min.fderiv_eq_zero (h : is_local_min f a) : fderiv ℝ f a = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='is_local_min'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='fderiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 123, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : preorder.{v} β], (α → β) → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {F : Type u_3} [_inst_4 : normed_group.{u_3} F] [_inst_5 : @normed_space.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4], (E → F) → E → @continuous_linear_map.{u_1 u_2 u_3} 𝕜 (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) F (@uniform_space.to_topological_space.{u_3} F (@metric_space.to_uniform_space&#x27;.{u_3} F (@normed_group.to_metric_space.{u_3} F _inst_4))) (@normed_group.to_add_comm_group.{u_3} F _inst_4) (@normed_space.to_module.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4 _inst_5)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='`is_local_min f a` means that `f a ≤ f x` for all `x` in some neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' If `f` has a derivative at `x`, then `fderiv 𝕜 f x` is such a derivative. Otherwise, it is
set to `0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204  if hf : differentiable_at ℝ f a then h.has_fderiv_at_eq_zero hf.has_fderiv_at</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='differentiable_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_local_min.has_fderiv_at_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='differentiable_at.has_fderiv_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 609, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 194, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 347, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (c : Prop) [h : decidable c] {α : Prop}, (c → α) → (not c → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (𝕜 : Type) [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {E : Type u} [_inst_2 : normed_group.{u} E] [_inst_3 : @normed_space.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {F : Type} [_inst_4 : normed_group.{0} F] [_inst_5 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4], (E → F) → E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@is_local_min.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1] {f : E → real} {a : E} {f&#x27; : @continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)}, @is_local_min.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f a → @has_fderiv_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; a → @eq.{(max (u+1) 1)} (@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)) f&#x27; (@has_zero.zero.{u} (@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)) (@continuous_linear_map.has_zero.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@differentiable_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type} [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {E : Type u} [_inst_2 : normed_group.{u} E] [_inst_3 : @normed_space.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {F : Type} [_inst_4 : normed_group.{0} F] [_inst_5 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4] {f : E → F} {x : E}, @differentiable_at.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x → @has_fderiv_at.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f (@fderiv.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' A function `f` is differentiable at a point `x` if it admits a derivative there (possibly
non-unique).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='Fermat&#x27;s Theorem: the derivative of a function at a local minimum equals zero.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205  else fderiv_zero_of_not_differentiable_at hf</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 147, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='not (@differentiable_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@differentiable_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207  /-- Fermat&#x27;s Theorem: the derivative of a function at a local maximum equals zero. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208  lemma is_local_max.has_fderiv_at_eq_zero (h : is_local_max f a) (hf : has_fderiv_at f f&#x27; a) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='blue'><a title='is_local_max'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='has_fderiv_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 57, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : preorder.{v} β], (α → β) → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {F : Type u_3} [_inst_4 : normed_group.{u_3} F] [_inst_5 : @normed_space.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4], (E → F) → @continuous_linear_map.{u_1 u_2 u_3} 𝕜 (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) F (@uniform_space.to_topological_space.{u_3} F (@metric_space.to_uniform_space&#x27;.{u_3} F (@normed_group.to_metric_space.{u_3} F _inst_4))) (@normed_group.to_add_comm_group.{u_3} F _inst_4) (@normed_space.to_module.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4 _inst_5) → E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='orange'><a title='`is_local_max f a` means that `f x ≤ f a` for all `x ∈ s` in some neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title=' A function `f` has the continuous linear map `f&#x27;` as derivative at `x` if
`f x&#x27; = f x + f&#x27; (x&#x27; - x) + o (x&#x27; - x)` when `x&#x27;` tends to `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209    f&#x27; = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210  neg_eq_zero.1 $ h.neg.has_fderiv_at_eq_zero hf.neg</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='neg_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_local_max.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_local_min.has_fderiv_at_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_fderiv_at.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/basic.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 288, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 194, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 927, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : add_group.{u} α] {a : α}, iff (@eq.{u+1} α (@has_neg.neg.{u} α (@add_group.to_has_neg.{u} α _inst_1) a) (@has_zero.zero.{u} α (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α _inst_1)))) (@eq.{u+1} α a (@has_zero.zero.{u} α (@add_monoid.to_has_zero.{u} α (@add_group.to_add_monoid.{u} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@is_local_max.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type} [_inst_1 : topological_space.{u} α] [_inst_2 : ordered_comm_group.{0} β] {f : α → β} {a : α}, @is_local_max.{u 0} α β _inst_1 (@partial_order.to_preorder.{0} β (@ordered_comm_monoid.to_partial_order.{0} β (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} β (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} β _inst_2)))) f a → @is_local_min.{u 0} α β _inst_1 (@partial_order.to_preorder.{0} β (@ordered_comm_monoid.to_partial_order.{0} β (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} β (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} β _inst_2)))) (λ (x : α), @has_neg.neg.{0} β (@add_group.to_has_neg.{0} β (@add_comm_group.to_add_group.{0} β (@ordered_comm_group.to_add_comm_group.{0} β _inst_2))) (f x)) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1] {f : E → real} {a : E} {f&#x27; : @continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)}, @is_local_min.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f a → @has_fderiv_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; a → @eq.{(max (u+1) 1)} (@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)) f&#x27; (@has_zero.zero.{u} (@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)) (@continuous_linear_map.has_zero.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_fderiv_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type} [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {E : Type u} [_inst_2 : normed_group.{u} E] [_inst_3 : @normed_space.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {F : Type} [_inst_4 : normed_group.{0} F] [_inst_5 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4] {f : E → F} {f&#x27; : @continuous_linear_map.{0 u 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_2))) (@normed_group.to_add_comm_group.{u} E _inst_2) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_4))) (@normed_group.to_add_comm_group.{0} F _inst_4) (@normed_space.to_module.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4 _inst_5)} {x : E}, @has_fderiv_at.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f f&#x27; x → @has_fderiv_at.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 (λ (x : E), @has_neg.neg.{0} F (@add_group.to_has_neg.{0} F (@add_comm_group.to_add_group.{0} F (@normed_group.to_add_comm_group.{0} F _inst_4))) (f x)) (@has_neg.neg.{u} (@continuous_linear_map.{0 u 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_2))) (@normed_group.to_add_comm_group.{u} E _inst_2) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_4))) (@normed_group.to_add_comm_group.{0} F _inst_4) (@normed_space.to_module.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4 _inst_5)) (@continuous_linear_map.has_neg.{0 u 0} 𝕜 (@normed_ring.to_ring.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_2))) (@normed_group.to_add_comm_group.{u} E _inst_2) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_4))) (@normed_group.to_add_comm_group.{0} F _inst_4) (@normed_space.to_module.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4 _inst_5) (@normed_top_group.{0} F _inst_4)) f&#x27;) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='Fermat&#x27;s Theorem: the derivative of a function at a local minimum equals zero.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212  /-- Fermat&#x27;s Theorem: the derivative of a function at a local maximum equals zero. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213  lemma is_local_max.fderiv_eq_zero (h : is_local_max f a) : fderiv ℝ f a = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='is_local_max'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='fderiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 57, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 123, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : preorder.{v} β], (α → β) → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {F : Type u_3} [_inst_4 : normed_group.{u_3} F] [_inst_5 : @normed_space.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4], (E → F) → E → @continuous_linear_map.{u_1 u_2 u_3} 𝕜 (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) F (@uniform_space.to_topological_space.{u_3} F (@metric_space.to_uniform_space&#x27;.{u_3} F (@normed_group.to_metric_space.{u_3} F _inst_4))) (@normed_group.to_add_comm_group.{u_3} F _inst_4) (@normed_space.to_module.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4 _inst_5)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='`is_local_max f a` means that `f x ≤ f a` for all `x ∈ s` in some neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' If `f` has a derivative at `x`, then `fderiv 𝕜 f x` is such a derivative. Otherwise, it is
set to `0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214  if hf : differentiable_at ℝ f a then h.has_fderiv_at_eq_zero hf.has_fderiv_at</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='differentiable_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_local_max.has_fderiv_at_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='differentiable_at.has_fderiv_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 609, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 208, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 347, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (c : Prop) [h : decidable c] {α : Prop}, (c → α) → (not c → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (𝕜 : Type) [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {E : Type u} [_inst_2 : normed_group.{u} E] [_inst_3 : @normed_space.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {F : Type} [_inst_4 : normed_group.{0} F] [_inst_5 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4], (E → F) → E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@is_local_max.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1] {f : E → real} {a : E} {f&#x27; : @continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)}, @is_local_max.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f a → @has_fderiv_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; a → @eq.{(max (u+1) 1)} (@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)) f&#x27; (@has_zero.zero.{u} (@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)) (@continuous_linear_map.has_zero.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@differentiable_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type} [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {E : Type u} [_inst_2 : normed_group.{u} E] [_inst_3 : @normed_space.{0 u} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {F : Type} [_inst_4 : normed_group.{0} F] [_inst_5 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4] {f : E → F} {x : E}, @differentiable_at.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x → @has_fderiv_at.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f (@fderiv.{0 u 0} 𝕜 _inst_1 E _inst_2 _inst_3 F _inst_4 _inst_5 f x) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' A function `f` is differentiable at a point `x` if it admits a derivative there (possibly
non-unique).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='Fermat&#x27;s Theorem: the derivative of a function at a local maximum equals zero.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215  else fderiv_zero_of_not_differentiable_at hf</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 147, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='not (@differentiable_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@differentiable_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217  /-- Fermat&#x27;s Theorem: the derivative of a function at a local extremum equals zero. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218  lemma is_local_extr.has_fderiv_at_eq_zero (h : is_local_extr f a) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='blue'><a title='is_local_extr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : preorder.{v} β], (α → β) → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='orange'><a title='`is_local_extr_on f s a` means `is_local_min_on f s a ∨ is_local_max_on f s a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219    has_fderiv_at f f&#x27; a → f&#x27; = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_fderiv_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 101, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {𝕜 : Type u_1} [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {F : Type u_3} [_inst_4 : normed_group.{u_3} F] [_inst_5 : @normed_space.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4], (E → F) → @continuous_linear_map.{u_1 u_2 u_3} 𝕜 (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) F (@uniform_space.to_topological_space.{u_3} F (@metric_space.to_uniform_space&#x27;.{u_3} F (@normed_group.to_metric_space.{u_3} F _inst_4))) (@normed_group.to_add_comm_group.{u_3} F _inst_4) (@normed_space.to_module.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4 _inst_5) → E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' A function `f` has the continuous linear map `f&#x27;` as derivative at `x` if
`f x&#x27; = f x + f&#x27; (x&#x27; - x) + o (x&#x27; - x)` when `x&#x27;` tends to `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220  h.elim is_local_min.has_fderiv_at_eq_zero is_local_max.has_fderiv_at_eq_zero</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_local_extr.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_local_min.has_fderiv_at_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_local_max.has_fderiv_at_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 194, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 208, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_local_extr.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type} [_inst_1 : topological_space.{u} α] [_inst_2 : preorder.{0} β] {f : α → β} {a : α} {p : Prop}, @is_local_extr.{u 0} α β _inst_1 _inst_2 f a → (@is_local_min.{u 0} α β _inst_1 _inst_2 f a → p) → (@is_local_max.{u 0} α β _inst_1 _inst_2 f a → p) → p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1] {f : E → real} {a : E} {f&#x27; : @continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)}, @is_local_min.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f a → @has_fderiv_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; a → @eq.{(max (u+1) 1)} (@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)) f&#x27; (@has_zero.zero.{u} (@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)) (@continuous_linear_map.has_zero.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1] {f : E → real} {a : E} {f&#x27; : @continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)}, @is_local_max.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f a → @has_fderiv_at.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; a → @eq.{(max (u+1) 1)} (@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)) f&#x27; (@has_zero.zero.{u} (@continuous_linear_map.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)) (@continuous_linear_map.has_zero.{0 u 0} real real.ring E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.add_comm_group (@normed_space.to_module.{0 u} real E normed_field.normed_field _inst_1 _inst_2) (@discrete_field.to_vector_space.{0} real real.discrete_field)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Fermat&#x27;s Theorem: the derivative of a function at a local minimum equals zero.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Fermat&#x27;s Theorem: the derivative of a function at a local maximum equals zero.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222  /-- Fermat&#x27;s Theorem: the derivative of a function at a local extremum equals zero. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223  lemma is_local_extr.fderiv_eq_zero (h : is_local_extr f a) : fderiv ℝ f a = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='blue'><a title='is_local_extr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='fderiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 123, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : preorder.{v} β], (α → β) → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (𝕜 : Type u_1) [_inst_1 : nondiscrete_normed_field.{u_1} 𝕜] {E : Type u_2} [_inst_2 : normed_group.{u_2} E] [_inst_3 : @normed_space.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2] {F : Type u_3} [_inst_4 : normed_group.{u_3} F] [_inst_5 : @normed_space.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4], (E → F) → E → @continuous_linear_map.{u_1 u_2 u_3} 𝕜 (@normed_ring.to_ring.{u_1} 𝕜 (@normed_field.to_normed_ring.{u_1} 𝕜 (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1))) E (@uniform_space.to_topological_space.{u_2} E (@metric_space.to_uniform_space&#x27;.{u_2} E (@normed_group.to_metric_space.{u_2} E _inst_2))) (@normed_group.to_add_comm_group.{u_2} E _inst_2) F (@uniform_space.to_topological_space.{u_3} F (@metric_space.to_uniform_space&#x27;.{u_3} F (@normed_group.to_metric_space.{u_3} F _inst_4))) (@normed_group.to_add_comm_group.{u_3} F _inst_4) (@normed_space.to_module.{u_1 u_2} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.to_module.{u_1 u_3} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u_1} 𝕜 _inst_1) _inst_4 _inst_5)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='`is_local_extr_on f s a` means `is_local_min_on f s a ∨ is_local_max_on f s a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' If `f` has a derivative at `x`, then `fderiv 𝕜 f x` is such a derivative. Otherwise, it is
set to `0`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224  h.elim is_local_min.fderiv_eq_zero is_local_max.fderiv_eq_zero</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_local_extr.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_local_min.fderiv_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_local_max.fderiv_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 203, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 213, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_local_extr.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type} [_inst_1 : topological_space.{u} α] [_inst_2 : preorder.{0} β] {f : α → β} {a : α} {p : Prop}, @is_local_extr.{u 0} α β _inst_1 _inst_2 f a → (@is_local_min.{u 0} α β _inst_1 _inst_2 f a → p) → (@is_local_max.{u 0} α β _inst_1 _inst_2 f a → p) → p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1] {f : E → real} {a : E}, @is_local_min.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f a → @eq.{(max (u+1) 1)} (@continuous_linear_map.{0 u 0} real (@normed_ring.to_ring.{0} real (@normed_field.to_normed_ring.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))) E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real (@normed_group.to_metric_space.{0} real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))) (@normed_group.to_add_comm_group.{0} real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))) (@normed_space.to_module.{0 u} real E (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field) _inst_1 _inst_2) (@normed_space.to_module.{0 0} real real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field) (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))) (@fderiv.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f a) (@has_zero.zero.{u} (@continuous_linear_map.{0 u 0} real (@normed_ring.to_ring.{0} real (@normed_field.to_normed_ring.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))) E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real (@normed_group.to_metric_space.{0} real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))) (@normed_group.to_add_comm_group.{0} real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))) (@normed_space.to_module.{0 u} real E (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field) _inst_1 _inst_2) (@normed_space.to_module.{0 0} real real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field) (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))) (@continuous_linear_map.has_zero.{0 u 0} real (@normed_ring.to_ring.{0} real (@normed_field.to_normed_ring.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))) E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real (@normed_group.to_metric_space.{0} real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))) (@normed_group.to_add_comm_group.{0} real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))) (@normed_space.to_module.{0 u} real E (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field) _inst_1 _inst_2) (@normed_space.to_module.{0 0} real real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field) (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {E : Type u} [_inst_1 : normed_group.{u} E] [_inst_2 : @normed_space.{0 u} real E normed_field.normed_field _inst_1] {f : E → real} {a : E}, @is_local_max.{u 0} E real (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) real.preorder f a → @eq.{(max (u+1) 1)} (@continuous_linear_map.{0 u 0} real (@normed_ring.to_ring.{0} real (@normed_field.to_normed_ring.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))) E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real (@normed_group.to_metric_space.{0} real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))) (@normed_group.to_add_comm_group.{0} real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))) (@normed_space.to_module.{0 u} real E (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field) _inst_1 _inst_2) (@normed_space.to_module.{0 0} real real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field) (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))) (@fderiv.{0 u 0} real normed_field.nondiscrete_normed_field E _inst_1 _inst_2 real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f a) (@has_zero.zero.{u} (@continuous_linear_map.{0 u 0} real (@normed_ring.to_ring.{0} real (@normed_field.to_normed_ring.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))) E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real (@normed_group.to_metric_space.{0} real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))) (@normed_group.to_add_comm_group.{0} real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))) (@normed_space.to_module.{0 u} real E (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field) _inst_1 _inst_2) (@normed_space.to_module.{0 0} real real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field) (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))) (@continuous_linear_map.has_zero.{0 u 0} real (@normed_ring.to_ring.{0} real (@normed_field.to_normed_ring.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))) E (@uniform_space.to_topological_space.{u} E (@metric_space.to_uniform_space&#x27;.{u} E (@normed_group.to_metric_space.{u} E _inst_1))) (@normed_group.to_add_comm_group.{u} E _inst_1) real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real (@normed_group.to_metric_space.{0} real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))))) (@normed_group.to_add_comm_group.{0} real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))) (@normed_space.to_module.{0 u} real E (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field) _inst_1 _inst_2) (@normed_space.to_module.{0 0} real real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field) (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Fermat&#x27;s Theorem: the derivative of a function at a local minimum equals zero.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Fermat&#x27;s Theorem: the derivative of a function at a local maximum equals zero.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226  end vector_space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228  section real</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230  variables {f : ℝ → ℝ} {f&#x27; : ℝ} {a b : ℝ}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232  /-- Fermat&#x27;s Theorem: the derivative of a function at a local extremum equals zero. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233  lemma is_local_min.has_deriv_at_eq_zero (h : is_local_min f a) (hf : has_deriv_at f f&#x27; a) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='blue'><a title='is_local_min'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='has_deriv_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/deriv.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : preorder.{v} β], (α → β) → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field.{u} 𝕜] {F : Type v} [_inst_2 : normed_group.{v} F] [_inst_3 : @normed_space.{u v} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2], (𝕜 → F) → F → 𝕜 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='orange'><a title='`is_local_min f a` means that `f a ≤ f x` for all `x` in some neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`f` has the derivative `f&#x27;` at the point `x`.

That is, `f x&#x27; = f x + (x&#x27; - x) • f&#x27; + o(x&#x27; - x)` where `x&#x27;` converges to `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234    f&#x27; = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235  by simpa using continuous_linear_map.ext_iff.1</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='continuous_linear_map.ext_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/module.lean&#x27;, &#x27;line&#x27;: 181, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {R : Type} [_inst_1 : ring.{0} R] {M : Type} [_inst_2 : topological_space.{0} M] [_inst_3 : add_comm_group.{0} M] {M₂ : Type} [_inst_4 : topological_space.{0} M₂] [_inst_5 : add_comm_group.{0} M₂] [_inst_8 : @module.{0 0} R M _inst_1 _inst_3] [_inst_9 : @module.{0 0} R M₂ _inst_1 _inst_5] {f g : @continuous_linear_map.{0 0 0} R _inst_1 M _inst_2 _inst_3 M₂ _inst_4 _inst_5 _inst_8 _inst_9}, iff (@eq.{1} (@continuous_linear_map.{0 0 0} R _inst_1 M _inst_2 _inst_3 M₂ _inst_4 _inst_5 _inst_8 _inst_9) f g) (∀ (x : M), @eq.{1} M₂ (@coe_fn.{1 1} (@continuous_linear_map.{0 0 0} R _inst_1 M _inst_2 _inst_3 M₂ _inst_4 _inst_5 _inst_8 _inst_9) (@continuous_linear_map.to_fun.{0 0 0} R _inst_1 M _inst_2 _inst_3 M₂ _inst_4 _inst_5 _inst_8 _inst_9) f x) (@coe_fn.{1 1} (@continuous_linear_map.{0 0 0} R _inst_1 M _inst_2 _inst_3 M₂ _inst_4 _inst_5 _inst_8 _inst_9) (@continuous_linear_map.to_fun.{0 0 0} R _inst_1 M _inst_2 _inst_3 M₂ _inst_4 _inst_5 _inst_8 _inst_9) g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='f : real → real,
f&#x27; a : real,
h :
  @is_local_min.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.preorder
    f
    a,
hf :
  @has_deriv_at.{0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    a
⊢ @eq.{1} real f&#x27;
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236    (h.has_fderiv_at_eq_zero (has_deriv_at_iff_has_fderiv_at.1 hf)) 1</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_deriv_at_iff_has_fderiv_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 194, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/deriv.lean&#x27;, &#x27;line&#x27;: 151, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@is_local_min.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.preorder f a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {𝕜 : Type} [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {F : Type} [_inst_2 : normed_group.{0} F] [_inst_3 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {f : 𝕜 → F} {x : 𝕜} {f&#x27; : F}, iff (@has_deriv_at.{0 0} 𝕜 _inst_1 F _inst_2 _inst_3 f f&#x27; x) (@has_fderiv_at.{0 0 0} 𝕜 _inst_1 𝕜 (@normed_ring.to_normed_group.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) (@normed_field.to_normed_space.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)) F _inst_2 _inst_3 f (@continuous_linear_map.smul_right.{0 0 0} 𝕜 (@nonzero_comm_ring.to_comm_ring.{0} 𝕜 (@euclidean_domain.to_nonzero_comm_ring.{0} 𝕜 (@discrete_field.to_euclidean_domain.{0} 𝕜 (@normed_field.to_discrete_field.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))))) (@uniform_space.to_topological_space.{0} 𝕜 (@metric_space.to_uniform_space&#x27;.{0} 𝕜 (@normed_field.to_metric_space.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) 𝕜 (@uniform_space.to_topological_space.{0} 𝕜 (@metric_space.to_uniform_space&#x27;.{0} 𝕜 (@normed_field.to_metric_space.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) (@normed_group.to_add_comm_group.{0} 𝕜 (@normed_ring.to_normed_group.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) F (@uniform_space.to_topological_space.{0} F (@metric_space.to_uniform_space&#x27;.{0} F (@normed_group.to_metric_space.{0} F _inst_2))) (@normed_group.to_add_comm_group.{0} F _inst_2) (@discrete_field.to_vector_space.{0} 𝕜 (@normed_field.to_discrete_field.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) (@normed_space.to_module.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2 _inst_3) (@normed_space.topological_vector_space.{0 0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) F _inst_2 _inst_3) (@has_one.one.{0} (@continuous_linear_map.{0 0 0} 𝕜 (@comm_ring.to_ring.{0} 𝕜 (@nonzero_comm_ring.to_comm_ring.{0} 𝕜 (@euclidean_domain.to_nonzero_comm_ring.{0} 𝕜 (@discrete_field.to_euclidean_domain.{0} 𝕜 (@normed_field.to_discrete_field.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))))) 𝕜 (@uniform_space.to_topological_space.{0} 𝕜 (@metric_space.to_uniform_space&#x27;.{0} 𝕜 (@normed_field.to_metric_space.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) (@normed_group.to_add_comm_group.{0} 𝕜 (@normed_ring.to_normed_group.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) 𝕜 (@uniform_space.to_topological_space.{0} 𝕜 (@metric_space.to_uniform_space&#x27;.{0} 𝕜 (@normed_field.to_metric_space.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) (@ring.to_add_comm_group.{0} 𝕜 (@comm_ring.to_ring.{0} 𝕜 (@nonzero_comm_ring.to_comm_ring.{0} 𝕜 (@euclidean_domain.to_nonzero_comm_ring.{0} 𝕜 (@discrete_field.to_euclidean_domain.{0} 𝕜 (@normed_field.to_discrete_field.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))))))) (@discrete_field.to_vector_space.{0} 𝕜 (@normed_field.to_discrete_field.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) (@ring.to_module.{0} 𝕜 (@comm_ring.to_ring.{0} 𝕜 (@nonzero_comm_ring.to_comm_ring.{0} 𝕜 (@euclidean_domain.to_nonzero_comm_ring.{0} 𝕜 (@discrete_field.to_euclidean_domain.{0} 𝕜 (@normed_field.to_discrete_field.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))))))) (@continuous_linear_map.has_one.{0 0} 𝕜 (@comm_ring.to_ring.{0} 𝕜 (@nonzero_comm_ring.to_comm_ring.{0} 𝕜 (@euclidean_domain.to_nonzero_comm_ring.{0} 𝕜 (@discrete_field.to_euclidean_domain.{0} 𝕜 (@normed_field.to_discrete_field.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))))) 𝕜 (@uniform_space.to_topological_space.{0} 𝕜 (@metric_space.to_uniform_space&#x27;.{0} 𝕜 (@normed_field.to_metric_space.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) (@normed_group.to_add_comm_group.{0} 𝕜 (@normed_ring.to_normed_group.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)))) (@discrete_field.to_vector_space.{0} 𝕜 (@normed_field.to_discrete_field.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))))) f&#x27;) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_deriv_at.{0 0} real normed_field.nondiscrete_normed_field real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Fermat&#x27;s Theorem: the derivative of a function at a local minimum equals zero.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Expressing `has_deriv_at f f&#x27; x` in terms of `has_fderiv_at`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
f&#x27; a : real,
h :
  @is_local_min.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.preorder
    f
    a,
hf :
  @has_deriv_at.{0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    a
⊢ @eq.{1} real f&#x27;
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
f&#x27; a : real,
h :
  @is_local_min.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    real.preorder
    f
    a,
hf :
  @has_deriv_at.{0 0} real normed_field.nondiscrete_normed_field real
    (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field))
    (@normed_field.to_normed_space.{0} real
       (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))
    f
    f&#x27;
    a
⊢ @eq.{1} real f&#x27;
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238  /-- Fermat&#x27;s Theorem: the derivative of a function at a local extremum equals zero. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239  lemma is_local_min.deriv_eq_zero (h : is_local_min f a) : deriv f a = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='is_local_min'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='deriv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 54, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/deriv.lean&#x27;, &#x27;line&#x27;: 120, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : preorder.{v} β], (α → β) → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field.{u} 𝕜] {F : Type v} [_inst_2 : normed_group.{v} F] [_inst_3 : @normed_space.{u v} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2], (𝕜 → F) → 𝕜 → F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title='`is_local_min f a` means that `f a ≤ f x` for all `x` in some neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Derivative of `f` at the point `x`, if it exists.  Zero otherwise.

If the derivative exists (i.e., `∃ f&#x27;, has_deriv_at f f&#x27; x`), then
`f x&#x27; = f x + (x&#x27; - x) • deriv f x + o(x&#x27; - x)` where `x&#x27;` converges to `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240  if hf : differentiable_at ℝ f a then h.has_deriv_at_eq_zero hf.has_deriv_at</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='differentiable_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_local_min.has_deriv_at_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='differentiable_at.has_deriv_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 609, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 233, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/deriv.lean&#x27;, &#x27;line&#x27;: 280, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (c : Prop) [h : decidable c] {α : Prop}, (c → α) → (not c → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (𝕜 : Type) [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {E : Type} [_inst_2 : normed_group.{0} E] [_inst_3 : @normed_space.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {F : Type} [_inst_4 : normed_group.{0} F] [_inst_5 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4], (E → F) → E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@is_local_min.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.preorder f a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {f : real → real} {f&#x27; a : real}, @is_local_min.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.preorder f a → @has_deriv_at.{0 0} real normed_field.nondiscrete_normed_field real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; a → @eq.{1} real f&#x27; (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@differentiable_at.{0 0 0} real normed_field.nondiscrete_normed_field real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type} [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {F : Type} [_inst_2 : normed_group.{0} F] [_inst_3 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {f : 𝕜 → F} {x : 𝕜}, @differentiable_at.{0 0 0} 𝕜 _inst_1 𝕜 (@normed_ring.to_normed_group.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) (@normed_field.to_normed_space.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)) F _inst_2 _inst_3 f x → @has_deriv_at.{0 0} 𝕜 _inst_1 F _inst_2 _inst_3 f (@deriv.{0 0} 𝕜 _inst_1 F _inst_2 _inst_3 f x) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' A function `f` is differentiable at a point `x` if it admits a derivative there (possibly
non-unique).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='Fermat&#x27;s Theorem: the derivative of a function at a local extremum equals zero.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241  else deriv_zero_of_not_differentiable_at hf</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/deriv.lean&#x27;, &#x27;line&#x27;: 160, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='not (@differentiable_at.{0 0 0} real normed_field.nondiscrete_normed_field real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@differentiable_at.{0 0 0} real normed_field.nondiscrete_normed_field real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243  /-- Fermat&#x27;s Theorem: the derivative of a function at a local extremum equals zero. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244  lemma is_local_max.has_deriv_at_eq_zero (h : is_local_max f a) (hf : has_deriv_at f f&#x27; a) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='blue'><a title='is_local_max'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='has_deriv_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 57, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/deriv.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : preorder.{v} β], (α → β) → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field.{u} 𝕜] {F : Type v} [_inst_2 : normed_group.{v} F] [_inst_3 : @normed_space.{u v} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2], (𝕜 → F) → F → 𝕜 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='orange'><a title='`is_local_max f a` means that `f x ≤ f a` for all `x ∈ s` in some neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`f` has the derivative `f&#x27;` at the point `x`.

That is, `f x&#x27; = f x + (x&#x27; - x) • f&#x27; + o(x&#x27; - x)` where `x&#x27;` converges to `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245    f&#x27; = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246  neg_eq_zero.1 $ h.neg.has_deriv_at_eq_zero hf.neg</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='neg_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_local_max.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_local_min.has_deriv_at_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='has_deriv_at.neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/group/basic.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 288, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 233, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/deriv.lean&#x27;, &#x27;line&#x27;: 624, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : add_group.{0} α] {a : α}, iff (@eq.{1} α (@has_neg.neg.{0} α (@add_group.to_has_neg.{0} α _inst_1) a) (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α (@add_group.to_add_monoid.{0} α _inst_1)))) (@eq.{1} α a (@has_zero.zero.{0} α (@add_monoid.to_has_zero.{0} α (@add_group.to_add_monoid.{0} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@is_local_max.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.preorder f a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type} [_inst_1 : topological_space.{0} α] [_inst_2 : ordered_comm_group.{0} β] {f : α → β} {a : α}, @is_local_max.{0 0} α β _inst_1 (@partial_order.to_preorder.{0} β (@ordered_comm_monoid.to_partial_order.{0} β (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} β (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} β _inst_2)))) f a → @is_local_min.{0 0} α β _inst_1 (@partial_order.to_preorder.{0} β (@ordered_comm_monoid.to_partial_order.{0} β (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} β (@ordered_comm_group.to_ordered_cancel_comm_monoid.{0} β _inst_2)))) (λ (x : α), @has_neg.neg.{0} β (@add_group.to_has_neg.{0} β (@add_comm_group.to_add_group.{0} β (@ordered_comm_group.to_add_comm_group.{0} β _inst_2))) (f x)) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {f : real → real} {f&#x27; a : real}, @is_local_min.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.preorder f a → @has_deriv_at.{0 0} real normed_field.nondiscrete_normed_field real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; a → @eq.{1} real f&#x27; (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_deriv_at.{0 0} real normed_field.nondiscrete_normed_field real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type} [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {F : Type} [_inst_2 : normed_group.{0} F] [_inst_3 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {f : 𝕜 → F} {f&#x27; : F} {x : 𝕜}, @has_deriv_at.{0 0} 𝕜 _inst_1 F _inst_2 _inst_3 f f&#x27; x → @has_deriv_at.{0 0} 𝕜 _inst_1 F _inst_2 _inst_3 (λ (x : 𝕜), @has_neg.neg.{0} F (@add_group.to_has_neg.{0} F (@add_comm_group.to_add_group.{0} F (@normed_group.to_add_comm_group.{0} F _inst_2))) (f x)) (@has_neg.neg.{0} F (@add_group.to_has_neg.{0} F (@add_comm_group.to_add_group.{0} F (@normed_group.to_add_comm_group.{0} F _inst_2))) f&#x27;) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='Fermat&#x27;s Theorem: the derivative of a function at a local extremum equals zero.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248  /-- Fermat&#x27;s Theorem: the derivative of a function at a local extremum equals zero. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249  lemma is_local_max.deriv_eq_zero (h : is_local_max f a) : deriv f a = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='blue'><a title='is_local_max'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='deriv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 57, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/deriv.lean&#x27;, &#x27;line&#x27;: 120, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : preorder.{v} β], (α → β) → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field.{u} 𝕜] {F : Type v} [_inst_2 : normed_group.{v} F] [_inst_3 : @normed_space.{u v} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2], (𝕜 → F) → 𝕜 → F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='orange'><a title='`is_local_max f a` means that `f x ≤ f a` for all `x ∈ s` in some neighborhood of `a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Derivative of `f` at the point `x`, if it exists.  Zero otherwise.

If the derivative exists (i.e., `∃ f&#x27;, has_deriv_at f f&#x27; x`), then
`f x&#x27; = f x + (x&#x27; - x) • deriv f x + o(x&#x27; - x)` where `x&#x27;` converges to `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250  if hf : differentiable_at ℝ f a then h.has_deriv_at_eq_zero hf.has_deriv_at</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='dite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='differentiable_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_local_max.has_deriv_at_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='differentiable_at.has_deriv_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 609, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/fderiv.lean&#x27;, &#x27;line&#x27;: 113, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 244, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/deriv.lean&#x27;, &#x27;line&#x27;: 280, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (c : Prop) [h : decidable c] {α : Prop}, (c → α) → (not c → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (𝕜 : Type) [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {E : Type} [_inst_2 : normed_group.{0} E] [_inst_3 : @normed_space.{0 0} 𝕜 E (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {F : Type} [_inst_4 : normed_group.{0} F] [_inst_5 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_4], (E → F) → E → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@is_local_max.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.preorder f a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {f : real → real} {f&#x27; a : real}, @is_local_max.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.preorder f a → @has_deriv_at.{0 0} real normed_field.nondiscrete_normed_field real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; a → @eq.{1} real f&#x27; (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@differentiable_at.{0 0 0} real normed_field.nondiscrete_normed_field real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {𝕜 : Type} [_inst_1 : nondiscrete_normed_field.{0} 𝕜] {F : Type} [_inst_2 : normed_group.{0} F] [_inst_3 : @normed_space.{0 0} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1) _inst_2] {f : 𝕜 → F} {x : 𝕜}, @differentiable_at.{0 0 0} 𝕜 _inst_1 𝕜 (@normed_ring.to_normed_group.{0} 𝕜 (@normed_field.to_normed_ring.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1))) (@normed_field.to_normed_space.{0} 𝕜 (@nondiscrete_normed_field.to_normed_field.{0} 𝕜 _inst_1)) F _inst_2 _inst_3 f x → @has_deriv_at.{0 0} 𝕜 _inst_1 F _inst_2 _inst_3 f (@deriv.{0 0} 𝕜 _inst_1 F _inst_2 _inst_3 f x) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title=' A function `f` is differentiable at a point `x` if it admits a derivative there (possibly
non-unique).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='Fermat&#x27;s Theorem: the derivative of a function at a local extremum equals zero.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251  else deriv_zero_of_not_differentiable_at hf</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/deriv.lean&#x27;, &#x27;line&#x27;: 160, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='not (@differentiable_at.{0 0 0} real normed_field.nondiscrete_normed_field real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='not (@differentiable_at.{0 0 0} real normed_field.nondiscrete_normed_field real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field))) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253  /-- Fermat&#x27;s Theorem: the derivative of a function at a local extremum equals zero. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254  lemma is_local_extr.has_deriv_at_eq_zero (h : is_local_extr f a) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='blue'><a title='is_local_extr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : preorder.{v} β], (α → β) → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='orange'><a title='`is_local_extr_on f s a` means `is_local_min_on f s a ∨ is_local_max_on f s a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255    has_deriv_at f f&#x27; a → f&#x27; = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_deriv_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/deriv.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field.{u} 𝕜] {F : Type v} [_inst_2 : normed_group.{v} F] [_inst_3 : @normed_space.{u v} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2], (𝕜 → F) → F → 𝕜 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`f` has the derivative `f&#x27;` at the point `x`.

That is, `f x&#x27; = f x + (x&#x27; - x) • f&#x27; + o(x&#x27; - x)` where `x&#x27;` converges to `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256  h.elim is_local_min.has_deriv_at_eq_zero is_local_max.has_deriv_at_eq_zero</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_local_extr.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_local_min.has_deriv_at_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_local_max.has_deriv_at_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 233, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 244, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_local_extr.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.preorder f a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type} [_inst_1 : topological_space.{0} α] [_inst_2 : preorder.{0} β] {f : α → β} {a : α} {p : Prop}, @is_local_extr.{0 0} α β _inst_1 _inst_2 f a → (@is_local_min.{0 0} α β _inst_1 _inst_2 f a → p) → (@is_local_max.{0 0} α β _inst_1 _inst_2 f a → p) → p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {f : real → real} {f&#x27; a : real}, @is_local_min.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.preorder f a → @has_deriv_at.{0 0} real normed_field.nondiscrete_normed_field real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; a → @eq.{1} real f&#x27; (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {f : real → real} {f&#x27; a : real}, @is_local_max.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.preorder f a → @has_deriv_at.{0 0} real normed_field.nondiscrete_normed_field real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; a → @eq.{1} real f&#x27; (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Fermat&#x27;s Theorem: the derivative of a function at a local extremum equals zero.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Fermat&#x27;s Theorem: the derivative of a function at a local extremum equals zero.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258  /-- Fermat&#x27;s Theorem: the derivative of a function at a local extremum equals zero. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259  lemma is_local_extr.deriv_eq_zero (h : is_local_extr f a) : deriv f a = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='is_local_extr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='deriv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/deriv.lean&#x27;, &#x27;line&#x27;: 120, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : preorder.{v} β], (α → β) → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field.{u} 𝕜] {F : Type v} [_inst_2 : normed_group.{v} F] [_inst_3 : @normed_space.{u v} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2], (𝕜 → F) → 𝕜 → F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='orange'><a title='`is_local_extr_on f s a` means `is_local_min_on f s a ∨ is_local_max_on f s a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Derivative of `f` at the point `x`, if it exists.  Zero otherwise.

If the derivative exists (i.e., `∃ f&#x27;, has_deriv_at f f&#x27; x`), then
`f x&#x27; = f x + (x&#x27; - x) • deriv f x + o(x&#x27; - x)` where `x&#x27;` converges to `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260  h.elim is_local_min.deriv_eq_zero is_local_max.deriv_eq_zero</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='is_local_extr.elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_local_min.deriv_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_local_max.deriv_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 239, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 249, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_local_extr.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.preorder f a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type} [_inst_1 : topological_space.{0} α] [_inst_2 : preorder.{0} β] {f : α → β} {a : α} {p : Prop}, @is_local_extr.{0 0} α β _inst_1 _inst_2 f a → (@is_local_min.{0 0} α β _inst_1 _inst_2 f a → p) → (@is_local_max.{0 0} α β _inst_1 _inst_2 f a → p) → p'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {f : real → real} {a : real}, @is_local_min.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.preorder f a → @eq.{1} real (@deriv.{0 0} real normed_field.nondiscrete_normed_field real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f a) (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {f : real → real} {a : real}, @is_local_max.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.preorder f a → @eq.{1} real (@deriv.{0 0} real normed_field.nondiscrete_normed_field real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f a) (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Fermat&#x27;s Theorem: the derivative of a function at a local extremum equals zero.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Fermat&#x27;s Theorem: the derivative of a function at a local extremum equals zero.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262  end real</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>263  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>264  section Rolle</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>265  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>266  variables (f f&#x27; : ℝ → ℝ) {a b : ℝ} (hab : a &lt; b) (hfc : continuous_on f (Icc a b)) (hfI : f a = f b)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='continuous_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='set.Icc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/continuous_on.lean&#x27;, &#x27;line&#x27;: 242, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 49, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : topological_space.{u_1} α] [_inst_2 : topological_space.{u_2} β], (α → β) → set.{u_1} α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], α → α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='orange'><a title=' A function between topological spaces is continuous on a subset `s`
when it&#x27;s continuous at every point of `s` within `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Left-closed right-closed interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>267  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>268  include hab hfc hfI</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>269  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>270  /-- A continuous function on a closed interval with `f a = f b` takes either its maximum</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>271  or its minimum value at a point in the interior of the interval. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>272  lemma exists_Ioo_extr_on_Icc : ∃ c ∈ Ioo a b, is_extr_on f (Icc a b) c :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.Ioo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_extr_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Icc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/extr.lean&#x27;, &#x27;line&#x27;: 104, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 49, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], α → α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : preorder.{v} β], (α → β) → set.{u} α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], α → α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='Left-open right-open interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`is_extr_on f s a` means `is_min_on f s a` or `is_max_on f s a`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Left-closed right-closed interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>273  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>274    have ne : (Icc a b).nonempty, from nonempty_Icc.2 (le_of_lt hab),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='set.Icc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='set.nonempty_Icc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 49, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 96, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [_inst_1 : preorder.{0} α], α → α → set.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, iff (@set.nonempty.{0} α (@set.Icc.{0} α _inst_1 a b)) (@has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} real real.has_lt a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Left-closed right-closed interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b)
⊢ @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b)

f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>275    -- Consider absolute min and max points</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>276    obtain ⟨c, cmem, cle⟩ : ∃ c ∈ Icc a b, ∀ x ∈ Icc a b, f c ≤ f x,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set.Icc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 49, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : preorder.{0} α], α → α → set.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Left-closed right-closed interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b)),
            ∀ (x : real),
              @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
              @has_le.le.{0} real real.has_le (f c) (f x)))

f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>277      from compact_Icc.exists_forall_le ne hfc,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='compact_Icc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hfc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/instances/real.lean&#x27;, &#x27;line&#x27;: 316, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : real}, @compact.{0} real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) (@set.Icc.{0} real real.preorder a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@continuous_on.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) f (@set.Icc.{0} real real.preorder a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The extreme value theorem: a continuous function realizes its minimum on a compact set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b)),
            ∀ (x : real),
              @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
              @has_le.le.{0} real real.has_le (f c) (f x)))

f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>278    obtain ⟨C, Cmem, Cge⟩ : ∃ C ∈ Icc a b, ∀ x ∈ Icc a b, f x ≤ f C,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='set.Icc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 49, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : preorder.{0} α], α → α → set.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))) (λ (a : prod.{0 0} (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr))), @prod.has_reflect (option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) (λ (a : option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)), @option.has_reflect (tactic.list_Sigma.{0} tactic.rcases_patt_inverted) (λ (a : tactic.list_Sigma.{0} tactic.rcases_patt_inverted), @list.reflect tactic.rcases_patt_inverted (λ (a : tactic.rcases_patt_inverted), tactic.rcases_patt_inverted.has_reflect a) `(tactic.rcases_patt_inverted) a) `(tactic.list_Sigma.{0} tactic.rcases_patt_inverted) a) (prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) (λ (a : prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)), @prod.has_reflect (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(option.{0} pexpr) `(option.{0} pexpr) a) `(option.{0} (tactic.list_Sigma.{0} tactic.rcases_patt_inverted)) `(prod.{0 0} (option.{0} pexpr) (option.{0} pexpr)) a) tactic.interactive.obtain_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Left-closed right-closed interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `obtain` tactic is a combination of `have` and `rcases`.
`obtain ⟨patt⟩ : type,
 { ... }`
is equivalent to
`have h : type,
 { ... },
 rcases h with ⟨patt⟩`.
 The syntax `obtain ⟨patt⟩ : type := proof` is also supported.
 If `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.
 If `type` is omitted, `:= proof` is required.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='obtain'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;patt_list? (: expr)? (:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x)
⊢ @Exists.{1} real
    (λ (C : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b)),
            ∀ (x : real),
              @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
              @has_le.le.{0} real real.has_le (f x) (f C)))

f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>279      from compact_Icc.exists_forall_ge ne hfc,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='compact_Icc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hfc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/instances/real.lean&#x27;, &#x27;line&#x27;: 316, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 97, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : real}, @compact.{0} real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) (@set.Icc.{0} real real.preorder a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@continuous_on.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) f (@set.Icc.{0} real real.preorder a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The extreme value theorem: a continuous function realizes its maximum on a compact set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x)
⊢ @Exists.{1} real
    (λ (C : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b)),
            ∀ (x : real),
              @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
              @has_le.le.{0} real real.has_le (f x) (f C)))

f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>280    by_cases hc : f c = f a,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))

f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : not (@eq.{1} real (f c) (f a))
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>281    { by_cases hC : f C = f a,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))

f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : not (@eq.{1} real (f c) (f a))
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : @eq.{1} real (f C) (f a)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))

f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : not (@eq.{1} real (f C) (f a))
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>282      { have : ∀ x ∈ Icc a b, f x = f a,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='set.Icc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 49, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : preorder.{0} α], α → α → set.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Left-closed right-closed interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : @eq.{1} real (f C) (f a)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))

f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : not (@eq.{1} real (f C) (f a))
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : @eq.{1} real (f C) (f a)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : @eq.{1} real (f C) (f a)
⊢ ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @eq.{1} real (f x) (f a)

f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : @eq.{1} real (f C) (f a),
this :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @eq.{1} real (f x) (f a)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>283          from λ x hx, le_antisymm (hC ▸ Cge x hx) (hc ▸ cle x hx),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hC'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Cge'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='cle'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : partial_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) b a → @eq.{1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{1} real (f C) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {P : α → Prop} {a b : α}, @eq.{1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x : real), @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) → @has_le.le.{0} real real.has_le (f x) (f C)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{1} real (f c) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x : real), @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) → @has_le.le.{0} real real.has_le (f c) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='from'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : @eq.{1} real (f C) (f a)
⊢ ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @eq.{1} real (f x) (f a)

f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : @eq.{1} real (f C) (f a),
this :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @eq.{1} real (f x) (f a)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : @eq.{1} real (f C) (f a),
this :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @eq.{1} real (f x) (f a)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>284        -- `f` is a constant, so we can take any point in `Ioo a b`</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : @eq.{1} real (f C) (f a),
this :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @eq.{1} real (f x) (f a)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>285        rcases dense hab with ⟨c&#x27;, hc&#x27;⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='dense'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 282, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] [_inst_2 : @densely_ordered.{0} α _inst_1] {a₁ a₂ : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a₁ a₂ → @Exists.{1} α (λ (a : α), and (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a₁ a) (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a a₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} real real.has_lt a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : @eq.{1} real (f C) (f a),
this :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @eq.{1} real (f x) (f a)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : @eq.{1} real (f C) (f a),
this :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @eq.{1} real (f x) (f a),
c&#x27; : real,
hc&#x27; :
  and (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) a c&#x27;)
    (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) c&#x27; b)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>286        refine ⟨c&#x27;, hc&#x27;, or.inl _⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='c&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hc&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='or.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) a c&#x27;) (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) c&#x27; b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, a → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : @eq.{1} real (f C) (f a),
this :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @eq.{1} real (f x) (f a),
c&#x27; : real,
hc&#x27; :
  and (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) a c&#x27;)
    (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) c&#x27; b)
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : @eq.{1} real (f C) (f a),
this :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @eq.{1} real (f x) (f a),
c&#x27; : real,
hc&#x27; :
  and (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) a c&#x27;)
    (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) c&#x27; b)
⊢ @is_min_filter.{0 0} real real real.preorder f (@filter.principal.{0} real (@set.Icc.{0} real real.preorder a b)) c&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>287        assume x hx,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : @eq.{1} real (f C) (f a),
this :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @eq.{1} real (f x) (f a),
c&#x27; : real,
hc&#x27; :
  and (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) a c&#x27;)
    (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) c&#x27; b)
⊢ @is_min_filter.{0 0} real real real.preorder f (@filter.principal.{0} real (@set.Icc.{0} real real.preorder a b)) c&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : @eq.{1} real (f C) (f a),
this :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @eq.{1} real (f x) (f a),
c&#x27; : real,
hc&#x27; :
  and (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) a c&#x27;)
    (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) c&#x27; b),
x : real,
hx : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b)
⊢ @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x
    (@set_of.{0} real
       (λ (x : real),
          (λ (x : real), @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) (f c&#x27;) (f x)) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>288        rw [mem_set_of_eq, this x hx, ← hC],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='set.mem_set_of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hx'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hC'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {a : α} {p : α → Prop}, @eq.{1} Prop (@has_mem.mem.{0 0} α (set.{0} α) (@set.has_mem.{0} α) a (@set_of.{0} α (λ (a : α), p a))) (p a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x : real), @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) → @eq.{1} real (f x) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} real (f C) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : @eq.{1} real (f C) (f a),
this :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @eq.{1} real (f x) (f a),
c&#x27; : real,
hc&#x27; :
  and (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) a c&#x27;)
    (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) c&#x27; b),
x : real,
hx : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b)
⊢ @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x
    (@set_of.{0} real
       (λ (x : real),
          (λ (x : real), @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) (f c&#x27;) (f x)) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : @eq.{1} real (f C) (f a),
this :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @eq.{1} real (f x) (f a),
c&#x27; : real,
hc&#x27; :
  and (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) a c&#x27;)
    (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) c&#x27; b),
x : real,
hx : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b)
⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) (f c&#x27;) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : @eq.{1} real (f C) (f a),
this :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @eq.{1} real (f x) (f a),
c&#x27; : real,
hc&#x27; :
  and (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) a c&#x27;)
    (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) c&#x27; b),
x : real,
hx : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b)
⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) (f c&#x27;) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : @eq.{1} real (f C) (f a),
this :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @eq.{1} real (f x) (f a),
c&#x27; : real,
hc&#x27; :
  and (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) a c&#x27;)
    (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) c&#x27; b),
x : real,
hx : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b)
⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) (f c&#x27;) (f C)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>289        exact Cge c&#x27; ⟨le_of_lt hc&#x27;.1, le_of_lt hc&#x27;.2⟩ },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='Cge'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hc&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x : real), @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) → @has_le.le.{0} real real.has_le (f x) (f C)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) a c&#x27;) (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) c&#x27; b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : @eq.{1} real (f C) (f a),
this :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @eq.{1} real (f x) (f a),
c&#x27; : real,
hc&#x27; :
  and (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) a c&#x27;)
    (@has_lt.lt.{0} real (@preorder.to_has_lt.{0} real real.preorder) c&#x27; b),
x : real,
hx : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b)
⊢ @has_le.le.{0} real (@preorder.to_has_le.{0} real real.preorder) (f c&#x27;) (f C)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : not (@eq.{1} real (f C) (f a))
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>290      { refine ⟨C, ⟨lt_of_le_of_ne Cmem.1 $ mt _ hC, lt_of_le_of_ne Cmem.2 $ mt _ hC⟩, or.inr Cge⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='lt_of_le_of_ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Cmem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='mt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hC'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='or.inr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Cge'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 136, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : partial_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b → @ne.{1} α a b → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, (a → b) → not b → not a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@eq.{1} real (f C) (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, b → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x : real), @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) → @has_le.le.{0} real real.has_le (f x) (f C)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : not (@eq.{1} real (f C) (f a))
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : not (@eq.{1} real (f C) (f a))
⊢ @eq.{1} real a C → @eq.{1} real (f C) (f a)

f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : not (@eq.{1} real (f C) (f a))
⊢ @eq.{1} real C b → @eq.{1} real (f C) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>291        exacts [λ h, by rw h, λ h, by rw [h, hfI]] } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hfI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 272, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 272, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 272, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 272, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 272, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 272, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 272, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} real a C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} real C b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} real (f a) (f b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exacts'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exacts'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exacts'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exacts'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exacts'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exacts'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exacts'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : not (@eq.{1} real (f C) (f a))
⊢ @eq.{1} real a C → @eq.{1} real (f C) (f a)

f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : not (@eq.{1} real (f C) (f a))
⊢ @eq.{1} real C b → @eq.{1} real (f C) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : not (@eq.{1} real (f C) (f a)),
h : @eq.{1} real a C
⊢ @eq.{1} real (f C) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : not (@eq.{1} real (f C) (f a))
⊢ @eq.{1} real a C → @eq.{1} real (f C) (f a)

f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : not (@eq.{1} real (f C) (f a))
⊢ @eq.{1} real C b → @eq.{1} real (f C) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : not (@eq.{1} real (f C) (f a)),
h : @eq.{1} real C b
⊢ @eq.{1} real (f C) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : not (@eq.{1} real (f C) (f a)),
h : @eq.{1} real C b
⊢ @eq.{1} real (f b) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : not (@eq.{1} real (f C) (f a))
⊢ @eq.{1} real a C → @eq.{1} real (f C) (f a)

f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : @eq.{1} real (f c) (f a),
hC : not (@eq.{1} real (f C) (f a))
⊢ @eq.{1} real C b → @eq.{1} real (f C) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : not (@eq.{1} real (f c) (f a))
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>292    { refine ⟨c, ⟨lt_of_le_of_ne cmem.1 $ mt _ hc, lt_of_le_of_ne cmem.2 $ mt _ hc⟩, or.inl cle⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='lt_of_le_of_ne'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cmem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='mt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='or.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cle'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 136, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 34, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : partial_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b → @ne.{1} α a b → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, (a → b) → not b → not a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@eq.{1} real (f c) (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, a → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x : real), @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) → @has_le.le.{0} real real.has_le (f c) (f x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : not (@eq.{1} real (f c) (f a))
⊢ @Exists.{1} real
    (λ (c : real),
       @Exists.{0}
         (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b))
         (λ
          (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)),
            @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : not (@eq.{1} real (f c) (f a))
⊢ @eq.{1} real a c → @eq.{1} real (f c) (f a)

f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : not (@eq.{1} real (f c) (f a))
⊢ @eq.{1} real c b → @eq.{1} real (f c) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>293        exacts [λ h, by rw h, λ h, by rw [h, hfI]] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hfI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 272, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 272, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 272, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 272, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 272, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 272, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 272, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} real a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} real c b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} real (f a) (f b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exacts'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exacts'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exacts'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exacts'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exacts'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exacts'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exacts'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : not (@eq.{1} real (f c) (f a))
⊢ @eq.{1} real a c → @eq.{1} real (f c) (f a)

f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : not (@eq.{1} real (f c) (f a))
⊢ @eq.{1} real c b → @eq.{1} real (f c) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : not (@eq.{1} real (f c) (f a)),
h : @eq.{1} real a c
⊢ @eq.{1} real (f c) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : not (@eq.{1} real (f c) (f a))
⊢ @eq.{1} real a c → @eq.{1} real (f c) (f a)

f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : not (@eq.{1} real (f c) (f a))
⊢ @eq.{1} real c b → @eq.{1} real (f c) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : not (@eq.{1} real (f c) (f a)),
h : @eq.{1} real c b
⊢ @eq.{1} real (f c) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : not (@eq.{1} real (f c) (f a)),
h : @eq.{1} real c b
⊢ @eq.{1} real (f b) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : not (@eq.{1} real (f c) (f a))
⊢ @eq.{1} real a c → @eq.{1} real (f c) (f a)

f : real → real,
a b : real,
hab : @has_lt.lt.{0} real real.has_lt a b,
hfc :
  @continuous_on.{0 0} real real
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    f
    (@set.Icc.{0} real real.preorder a b),
hfI : @eq.{1} real (f a) (f b),
ne : @set.nonempty.{0} real (@set.Icc.{0} real real.preorder a b),
c : real,
cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Icc.{0} real real.preorder a b),
cle :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f c) (f x),
C : real,
Cmem : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) C (@set.Icc.{0} real real.preorder a b),
Cge :
  ∀ (x : real),
    @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Icc.{0} real real.preorder a b) →
    @has_le.le.{0} real real.has_le (f x) (f C),
hc : not (@eq.{1} real (f c) (f a))
⊢ @eq.{1} real c b → @eq.{1} real (f c) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>294  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>295  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>296  /-- A continuous function on a closed interval with `f a = f b` has a local extremum at some</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>297  point of the corresponding open interval. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>298  lemma exists_local_extr_Ioo : ∃ c ∈ Ioo a b, is_local_extr f c :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.Ioo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='is_local_extr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], α → α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : topological_space.{u} α] [_inst_2 : preorder.{v} β], (α → β) → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='Left-open right-open interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`is_local_extr_on f s a` means `is_local_min_on f s a ∨ is_local_max_on f s a`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>299  let ⟨c, cmem, hc⟩ := exists_Ioo_extr_on_Icc f hab hfc hfI</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cmem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='exists_Ioo_extr_on_Icc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hfc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hfI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;line&#x27;: 272, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{1} real (λ (c : real), @Exists.{0} (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)) (λ (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)), @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c)) → @Exists.{1} real (λ (c : real), @Exists.{0} (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)) (λ (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)), @is_local_extr.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.preorder f c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ (f : real → real) {a b : real}, @has_lt.lt.{0} real real.has_lt a b → @continuous_on.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) f (@set.Icc.{0} real real.preorder a b) → @eq.{1} real (f a) (f b) → @Exists.{1} real (λ (c : real), @Exists.{0} (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)) (λ (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)), @is_extr_on.{0 0} real real real.preorder f (@set.Icc.{0} real real.preorder a b) c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_lt.lt.{0} real real.has_lt a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@continuous_on.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) f (@set.Icc.{0} real real.preorder a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{1} real (f a) (f b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title=' A continuous function on a closed interval with `f a = f b` takes either its maximum
or its minimum value at a point in the interior of the interval.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>300  in ⟨c, cmem, hc.is_local_extr $ mem_nhds_sets_iff.2 ⟨Ioo a b, Ioo_subset_Icc_self, is_open_Ioo, cmem⟩⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='is_extr_on.is_local_extr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='mem_nhds_sets_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.Ioo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.Ioo_subset_Icc_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_open_Ioo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/local_extr.lean&#x27;, &#x27;line&#x27;: 130, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 421, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 192, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/ordered.lean&#x27;, &#x27;line&#x27;: 206, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='∀ {α β : Type} [_inst_1 : topological_space.{0} α] [_inst_2 : preorder.{0} β] {f : α → β} {s : set.{0} α} {a : α}, @is_extr_on.{0 0} α β _inst_2 f s a → @has_mem.mem.{0 0} (set.{0} α) (filter.{0} α) (@filter.has_mem.{0} α) s (@nhds.{0} α _inst_1 a) → @is_local_extr.{0 0} α β _inst_1 _inst_2 f a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type} [_inst_1 : topological_space.{0} α] {a : α} {s : set.{0} α}, iff (@has_mem.mem.{0 0} (set.{0} α) (filter.{0} α) (@filter.has_mem.{0} α) s (@nhds.{0} α _inst_1 a)) (@Exists.{1} (set.{0} α) (λ (t : set.{0} α), @Exists.{0} (@has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) t s) (λ (H : @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) t s), and (@is_open.{0} α _inst_1 t) (@has_mem.mem.{0 0} α (set.{0} α) (@set.has_mem.{0} α) a t))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type} [_inst_1 : preorder.{0} α], α → α → set.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b : α}, @has_subset.subset.{0} (set.{0} α) (@set.has_subset.{0} α) (@set.Ioo.{0} α _inst_1 a b) (@set.Icc.{0} α _inst_1 a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type} [_inst_1 : topological_space.{0} α] [_inst_2 : linear_order.{0} α] [_inst_3 : @order_closed_topology.{0} α _inst_1 (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_2))] {a b : α}, @is_open.{0} α _inst_1 (@set.Ioo.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_2)) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='orange'><a title='Left-open right-open interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>301  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>302  /-- Rolle&#x27;s Theorem `has_deriv_at` version -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>303  lemma exists_has_deriv_at_eq_zero (hff&#x27; : ∀ x ∈ Ioo a b, has_deriv_at f (f&#x27; x) x) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.Ioo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_deriv_at'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/deriv.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], α → α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field.{u} 𝕜] {F : Type v} [_inst_2 : normed_group.{v} F] [_inst_3 : @normed_space.{u v} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2], (𝕜 → F) → F → 𝕜 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='orange'><a title='Left-open right-open interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`f` has the derivative `f&#x27;` at the point `x`.

That is, `f x&#x27; = f x + (x&#x27; - x) • f&#x27; + o(x&#x27; - x)` where `x&#x27;` converges to `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>304    ∃ c ∈ Ioo a b, f&#x27; c = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.Ioo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], α → α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Left-open right-open interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>305  let ⟨c, cmem, hc⟩ := exists_local_extr_Ioo f hab hfc hfI in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cmem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='exists_local_extr_Ioo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hfc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hfI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;line&#x27;: 298, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{1} real (λ (c : real), @Exists.{0} (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)) (λ (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)), @is_local_extr.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.preorder f c)) → @Exists.{1} real (λ (c : real), @Exists.{0} (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)) (λ (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)), @eq.{1} real (f&#x27; c) (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_local_extr.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.preorder f c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ (f : real → real) {a b : real}, @has_lt.lt.{0} real real.has_lt a b → @continuous_on.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) f (@set.Icc.{0} real real.preorder a b) → @eq.{1} real (f a) (f b) → @Exists.{1} real (λ (c : real), @Exists.{0} (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)) (λ (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)), @is_local_extr.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.preorder f c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_lt.lt.{0} real real.has_lt a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@continuous_on.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) f (@set.Icc.{0} real real.preorder a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{1} real (f a) (f b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title=' A continuous function on a closed interval with `f a = f b` has a local extremum at some
point of the corresponding open interval.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>306    ⟨c, cmem, hc.has_deriv_at_eq_zero $ hff&#x27; c cmem⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='is_local_extr.has_deriv_at_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hff&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 254, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='∀ {f : real → real} {f&#x27; a : real}, @is_local_extr.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.preorder f a → @has_deriv_at.{0 0} real normed_field.nondiscrete_normed_field real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f f&#x27; a → @eq.{1} real f&#x27; (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ (x : real), @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) x (@set.Ioo.{0} real real.preorder a b) → @has_deriv_at.{0 0} real normed_field.nondiscrete_normed_field real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f (f&#x27; x) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Fermat&#x27;s Theorem: the derivative of a function at a local extremum equals zero.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>307  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>308  /-- Rolle&#x27;s Theorem `deriv` version -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>309  lemma exists_deriv_eq_zero : ∃ c ∈ Ioo a b, deriv f c = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='set.Ioo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='deriv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/intervals/basic.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/calculus/deriv.lean&#x27;, &#x27;line&#x27;: 120, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u} [_inst_1 : preorder.{u} α], α → α → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {𝕜 : Type u} [_inst_1 : nondiscrete_normed_field.{u} 𝕜] {F : Type v} [_inst_2 : normed_group.{v} F] [_inst_3 : @normed_space.{u v} 𝕜 F (@nondiscrete_normed_field.to_normed_field.{u} 𝕜 _inst_1) _inst_2], (𝕜 → F) → 𝕜 → F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='Left-open right-open interval'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Derivative of `f` at the point `x`, if it exists.  Zero otherwise.

If the derivative exists (i.e., `∃ f&#x27;, has_deriv_at f f&#x27; x`), then
`f x&#x27; = f x + (x&#x27; - x) • deriv f x + o(x&#x27; - x)` where `x&#x27;` converges to `x`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>310  let ⟨c, cmem, hc⟩ := exists_local_extr_Ioo f hab hfc hfI in</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_let_match'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cmem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='exists_local_extr_Ioo'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hfc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hfI'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;line&#x27;: 298, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{1} real (λ (c : real), @Exists.{0} (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)) (λ (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)), @is_local_extr.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.preorder f c)) → @Exists.{1} real (λ (c : real), @Exists.{0} (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)) (λ (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)), @eq.{1} real (@deriv.{0 0} real normed_field.nondiscrete_normed_field real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f c) (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_local_extr.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.preorder f c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ (f : real → real) {a b : real}, @has_lt.lt.{0} real real.has_lt a b → @continuous_on.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) f (@set.Icc.{0} real real.preorder a b) → @eq.{1} real (f a) (f b) → @Exists.{1} real (λ (c : real), @Exists.{0} (@has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)) (λ (H : @has_mem.mem.{0 0} real (set.{0} real) (@set.has_mem.{0} real) c (@set.Ioo.{0} real real.preorder a b)), @is_local_extr.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.preorder f c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_lt.lt.{0} real real.has_lt a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@continuous_on.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) f (@set.Icc.{0} real real.preorder a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{1} real (f a) (f b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title=' A continuous function on a closed interval with `f a = f b` has a local extremum at some
point of the corresponding open interval.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>311    ⟨c, cmem, hc.deriv_eq_zero⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='is_local_extr.deriv_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 259, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='∀ {f : real → real} {a : real}, @is_local_extr.{0 0} real real (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)) real.preorder f a → @eq.{1} real (@deriv.{0 0} real normed_field.nondiscrete_normed_field real (@normed_ring.to_normed_group.{0} real (@normed_field.to_normed_ring.{0} real normed_field.normed_field)) (@normed_field.to_normed_space.{0} real (@nondiscrete_normed_field.to_normed_field.{0} real normed_field.nondiscrete_normed_field)) f a) (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Fermat&#x27;s Theorem: the derivative of a function at a local extremum equals zero.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>312  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>313  end Rolle</code></pre>
</body>