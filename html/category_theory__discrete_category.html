<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2017 Scott Morrison. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Stephen Morgan, Scott Morrison, Floris van Doorn</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import data.ulift</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/ulift.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import data.fintype</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/fintype.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import category_theory.opposites category_theory.equivalence</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  namespace category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  universes v₁ v₂ u₁ u₂ -- declare the `v`&#x27;s first; see `category_theory.category` for an explanation</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  def discrete (α : Type u₁) := α</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  instance discrete_category (α : Type u₁) : small_category (discrete α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='category_theory.small_category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.discrete'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='green'><a title='Type u → Type (u+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title='A `small_category` has objects and morphisms in the same universe level.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  { hom  := λ X Y, ulift (plift (X = Y)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ulift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='plift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 993, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 1005, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='category_theory.discrete.{u₁} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.discrete.{u₁} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type s → Type (max s r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Sort u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='category_theory.discrete.{u₁} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.discrete.{u₁} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='Universe lifting operation'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Universe lifting operation from Sort to Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18    id   := λ X, ulift.up (plift.up rfl),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ulift.up'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='plift.up'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 993, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 1005, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='category_theory.discrete.{u₁} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type s}, α → ulift.{r s} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, α → plift.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Sort u} {a : α}, @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19    comp := λ X Y Z g f, by { rcases f with ⟨⟨rfl⟩⟩, exact g } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='category_theory.discrete.{u₁} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.discrete.{u₁} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.discrete.{u₁} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u₁ u₁} (category_theory.discrete.{u₁} α) (@category_theory.has_hom.mk.{u₁ u₁} (category_theory.discrete.{u₁} α) (λ (X Y : category_theory.discrete.{u₁} α), ulift.{u₁ 0} (plift.{0} (@eq.{u₁+1} (category_theory.discrete.{u₁} α) X Y)))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{u₁ u₁} (category_theory.discrete.{u₁} α) (@category_theory.has_hom.mk.{u₁ u₁} (category_theory.discrete.{u₁} α) (λ (X Y : category_theory.discrete.{u₁} α), ulift.{u₁ 0} (plift.{0} (@eq.{u₁+1} (category_theory.discrete.{u₁} α) X Y)))) Y Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{u₁ u₁} (category_theory.discrete.{u₁} α) (@category_theory.has_hom.mk.{u₁ u₁} (category_theory.discrete.{u₁} α) (λ (X Y : category_theory.discrete.{u₁} α), ulift.{u₁ 0} (plift.{0} (@eq.{u₁+1} (category_theory.discrete.{u₁} α) X Y)))) Y Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{u₁ u₁} (category_theory.discrete.{u₁} α) (@category_theory.has_hom.mk.{u₁ u₁} (category_theory.discrete.{u₁} α) (λ (X Y : category_theory.discrete.{u₁} α), ulift.{u₁ 0} (plift.{0} (@eq.{u₁+1} (category_theory.discrete.{u₁} α) X Y)))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='lime'><a title='α : Type u₁,
X Y Z : category_theory.discrete.{u₁} α,
g :
  @category_theory.has_hom.hom.{u₁ u₁} (category_theory.discrete.{u₁} α)
    (@category_theory.has_hom.mk.{u₁ u₁} (category_theory.discrete.{u₁} α)
       (λ (X Y : category_theory.discrete.{u₁} α),
          ulift.{u₁ 0} (plift.{0} (@eq.{u₁+1} (category_theory.discrete.{u₁} α) X Y))))
    X
    Y,
f :
  @category_theory.has_hom.hom.{u₁ u₁} (category_theory.discrete.{u₁} α)
    (@category_theory.has_hom.mk.{u₁ u₁} (category_theory.discrete.{u₁} α)
       (λ (X Y : category_theory.discrete.{u₁} α),
          ulift.{u₁ 0} (plift.{0} (@eq.{u₁+1} (category_theory.discrete.{u₁} α) X Y))))
    Y
    Z
⊢ @category_theory.has_hom.hom.{u₁ u₁} (category_theory.discrete.{u₁} α)
    (@category_theory.has_hom.mk.{u₁ u₁} (category_theory.discrete.{u₁} α)
       (λ (X Y : category_theory.discrete.{u₁} α),
          ulift.{u₁ 0} (plift.{0} (@eq.{u₁+1} (category_theory.discrete.{u₁} α) X Y))))
    X
    Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u₁,
X Y : category_theory.discrete.{u₁} α,
g :
  @category_theory.has_hom.hom.{u₁ u₁} (category_theory.discrete.{u₁} α)
    (@category_theory.has_hom.mk.{u₁ u₁} (category_theory.discrete.{u₁} α)
       (λ (X Y : category_theory.discrete.{u₁} α),
          ulift.{u₁ 0} (plift.{0} (@eq.{u₁+1} (category_theory.discrete.{u₁} α) X Y))))
    X
    Y
⊢ @category_theory.has_hom.hom.{u₁ u₁} (category_theory.discrete.{u₁} α)
    (@category_theory.has_hom.mk.{u₁ u₁} (category_theory.discrete.{u₁} α)
       (λ (X Y : category_theory.discrete.{u₁} α),
          ulift.{u₁ 0} (plift.{0} (@eq.{u₁+1} (category_theory.discrete.{u₁} α) X Y))))
    X
    Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  namespace discrete</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  variables {α : Type u₁}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  instance [inhabited α] : inhabited (discrete α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='inhabited'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='inhabited'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.discrete'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 768, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 768, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Sort u → Sort (max 1 u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  by unfold discrete; apply_instance</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1411, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.unfold_config {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.ff, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.ff, beta := bool.tt, eta := bool.ff, proj := bool.ff, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.ff, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Given defined constants `e₁ ... eₙ`, `unfold e₁ ... eₙ` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.

As with `simp`, the `at` modifier can be used to specify locations for the unfolding.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='unfold'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id*&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.unfold_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u₁,
_inst_1 : inhabited.{u₁+1} α
⊢ inhabited.{u₁+1} (category_theory.discrete.{u₁} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u₁,
_inst_1 : inhabited.{u₁+1} α
⊢ inhabited.{u₁+1} (category_theory.discrete.{u₁} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  instance [fintype α] : fintype (discrete α) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  by { dsimp [discrete], apply_instance }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  instance fintype_fun [decidable_eq α] (X Y : discrete α) : fintype (X ⟶ Y) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  by { apply ulift.fintype }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  @[simp] lemma id_def (X : discrete α) : ulift.up (plift.up (eq.refl X)) = 𝟙 X := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='ulift.up'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='plift.up'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 993, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 1005, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type s}, α → ulift.{r s} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, α → plift.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Sort u} (a : α), @eq.{u} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.discrete.{u₁} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{u₁ u₁} obj] (X : obj), @category_theory.has_hom.hom.{u₁ u₁} obj (@category_theory.category_struct.to_has_hom.{u₁ u₁} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.discrete.{u₁} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u₁} {a : α}, @eq.{u₁+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  end discrete</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  variables {C : Type u₂} [𝒞 : category.{v₂} C]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  include 𝒞</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  namespace functor</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  def of_function {I : Type u₁} (F : I → C) : (discrete I) ⥤ C :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  { obj := F,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45    map := λ X Y f, begin cases f, cases f, cases f, exact 𝟙 (F X) end }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  @[simp] lemma of_function_obj  {I : Type u₁} (F : I → C) (i : I) : (of_function F).obj i = F i := rfl</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  @[simp] lemma of_function_map  {I : Type u₁} (F : I → C) {i : discrete I} (f : i ⟶ i) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                               </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                               </code><font color='green'><a title='category_theory.discrete.{u₁} I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{u₁ u₁} obj], obj → obj → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.discrete.{u₁} I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49    (of_function F).map f = 𝟙 (F i) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.functor.of_function'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 43, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {I : Type u₁}, (I → C) → @category_theory.functor.{u₁ v₂ u₁ u₂} (category_theory.discrete.{u₁} I) (category_theory.discrete_category.{u₁} I) C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='I → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{u₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{u₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{u₁ u₁} C (@category_theory.category_struct.to_has_hom.{u₁ u₁} C (@category_theory.category.to_category_struct.{u₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{u₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{u₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{u₁ u₁} (category_theory.discrete.{u₁} I) (@category_theory.category_struct.to_has_hom.{u₁ u₁} (category_theory.discrete.{u₁} I) (@category_theory.category.to_category_struct.{u₁ u₁} (category_theory.discrete.{u₁} I) (category_theory.discrete_category.{u₁} I))) i i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] (X : obj), @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='I → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.discrete.{u₁} I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  by { cases f, cases f, cases f, refl }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{u₁ u₁} (category_theory.discrete.{u₁} I) (@category_theory.category_struct.to_has_hom.{u₁ u₁} (category_theory.discrete.{u₁} I) (@category_theory.category.to_category_struct.{u₁ u₁} (category_theory.discrete.{u₁} I) (category_theory.discrete_category.{u₁} I))) i i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='plift.{0} (@eq.{u₁+1} (category_theory.discrete.{u₁} I) i i)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u₁+1} (category_theory.discrete.{u₁} I) i i'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₂,
𝒞 : category_theory.category.{v₂ u₂} C,
I : Type u₁,
F : I → C,
i : category_theory.discrete.{u₁} I,
f :
  @category_theory.has_hom.hom.{u₁ u₁} (category_theory.discrete.{u₁} I)
    (@category_theory.category_struct.to_has_hom.{u₁ u₁} (category_theory.discrete.{u₁} I)
       (@category_theory.category.to_category_struct.{u₁ u₁} (category_theory.discrete.{u₁} I)
          (category_theory.discrete_category.{u₁} I)))
    i
    i
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} C
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} C
          (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞))
       (@category_theory.functor.obj.{u₁ v₂ u₁ u₂} (category_theory.discrete.{u₁} I)
          (category_theory.discrete_category.{u₁} I)
          C
          𝒞
          (@category_theory.functor.of_function.{v₂ u₁ u₂} C 𝒞 I F)
          i)
       (@category_theory.functor.obj.{u₁ v₂ u₁ u₂} (category_theory.discrete.{u₁} I)
          (category_theory.discrete_category.{u₁} I)
          C
          𝒞
          (@category_theory.functor.of_function.{v₂ u₁ u₂} C 𝒞 I F)
          i))
    (@category_theory.functor.map.{u₁ v₂ u₁ u₂} (category_theory.discrete.{u₁} I)
       (category_theory.discrete_category.{u₁} I)
       C
       𝒞
       (@category_theory.functor.of_function.{v₂ u₁ u₂} C 𝒞 I F)
       i
       i
       f)
    (@category_theory.category_struct.id.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)
       (F i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₂,
𝒞 : category_theory.category.{v₂ u₂} C,
I : Type u₁,
F : I → C,
i : category_theory.discrete.{u₁} I,
f : plift.{0} (@eq.{u₁+1} (category_theory.discrete.{u₁} I) i i)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} C
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} C
          (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞))
       (@category_theory.functor.obj.{u₁ v₂ u₁ u₂} (category_theory.discrete.{u₁} I)
          (category_theory.discrete_category.{u₁} I)
          C
          𝒞
          (@category_theory.functor.of_function.{v₂ u₁ u₂} C 𝒞 I F)
          i)
       (@category_theory.functor.obj.{u₁ v₂ u₁ u₂} (category_theory.discrete.{u₁} I)
          (category_theory.discrete_category.{u₁} I)
          C
          𝒞
          (@category_theory.functor.of_function.{v₂ u₁ u₂} C 𝒞 I F)
          i))
    (@category_theory.functor.map.{u₁ v₂ u₁ u₂} (category_theory.discrete.{u₁} I)
       (category_theory.discrete_category.{u₁} I)
       C
       𝒞
       (@category_theory.functor.of_function.{v₂ u₁ u₂} C 𝒞 I F)
       i
       i
       (@ulift.up.{u₁ 0} (plift.{0} (@eq.{u₁+1} (category_theory.discrete.{u₁} I) i i)) f))
    (@category_theory.category_struct.id.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)
       (F i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₂,
𝒞 : category_theory.category.{v₂ u₂} C,
I : Type u₁,
F : I → C,
i : category_theory.discrete.{u₁} I,
f : @eq.{u₁+1} (category_theory.discrete.{u₁} I) i i
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} C
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} C
          (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞))
       (@category_theory.functor.obj.{u₁ v₂ u₁ u₂} (category_theory.discrete.{u₁} I)
          (category_theory.discrete_category.{u₁} I)
          C
          𝒞
          (@category_theory.functor.of_function.{v₂ u₁ u₂} C 𝒞 I F)
          i)
       (@category_theory.functor.obj.{u₁ v₂ u₁ u₂} (category_theory.discrete.{u₁} I)
          (category_theory.discrete_category.{u₁} I)
          C
          𝒞
          (@category_theory.functor.of_function.{v₂ u₁ u₂} C 𝒞 I F)
          i))
    (@category_theory.functor.map.{u₁ v₂ u₁ u₂} (category_theory.discrete.{u₁} I)
       (category_theory.discrete_category.{u₁} I)
       C
       𝒞
       (@category_theory.functor.of_function.{v₂ u₁ u₂} C 𝒞 I F)
       i
       i
       (@ulift.up.{u₁ 0} (plift.{0} (@eq.{u₁+1} (category_theory.discrete.{u₁} I) i i))
          (@plift.up.{0} (@eq.{u₁+1} (category_theory.discrete.{u₁} I) i i) f)))
    (@category_theory.category_struct.id.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)
       (F i))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  end functor</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='C : Type u₂,
𝒞 : category_theory.category.{v₂ u₂} C,
I : Type u₁,
F : I → C,
X Z Y : category_theory.discrete.{u₁} I
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} C
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} C
          (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞))
       (F X)
       (F X))
    (@ulift.rec.{v₂+1 u₁ 0} (plift.{0} (@eq.{u₁+1} (category_theory.discrete.{u₁} I) X X))
       (λ
        (f :
          @category_theory.has_hom.hom.{u₁ u₁} (category_theory.discrete.{u₁} I)
            (@category_theory.category_struct.to_has_hom.{u₁ u₁} (category_theory.discrete.{u₁} I)
               (@category_theory.category.to_category_struct.{u₁ u₁} (category_theory.discrete.{u₁} I)
                  (category_theory.discrete_category.{u₁} I)))
            X
            X),
          @category_theory.has_hom.hom.{v₂ u₂} C
            (@category_theory.category_struct.to_has_hom.{v₂ u₂} C
               (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞))
            (F X)
            (F X))
       (@plift.rec.{v₂+1 0} (@eq.{u₁+1} (category_theory.discrete.{u₁} I) X X)
          (λ (f : plift.{0} (@eq.{u₁+1} (category_theory.discrete.{u₁} I) X X)),
             @category_theory.has_hom.hom.{v₂ u₂} C
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} C
                  (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞))
               (F X)
               (F X))
          (λ (f : @eq.{u₁+1} (category_theory.discrete.{u₁} I) X X),
             @category_theory.category_struct.id.{v₂ u₂} C
               (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)
               (F X)))
       (@category_theory.category_struct.comp.{u₁ u₁} (category_theory.discrete.{u₁} I)
          (@category_theory.category.to_category_struct.{u₁ u₁} (category_theory.discrete.{u₁} I)
             (category_theory.discrete_category.{u₁} I))
          X
          X
          X
          (@category_theory.category_struct.id.{u₁ u₁} (category_theory.discrete.{u₁} I)
             (@category_theory.category.to_category_struct.{u₁ u₁} (category_theory.discrete.{u₁} I)
                (category_theory.discrete_category.{u₁} I))
             X)
          (@category_theory.category_struct.id.{u₁ u₁} (category_theory.discrete.{u₁} I)
             (@category_theory.category.to_category_struct.{u₁ u₁} (category_theory.discrete.{u₁} I)
                (category_theory.discrete_category.{u₁} I))
             X)))
    (@category_theory.category_struct.comp.{v₂ u₂} C
       (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)
       (F X)
       (F X)
       (F X)
       (@category_theory.category_struct.id.{v₂ u₂} C
          (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)
          (F X))
       (@category_theory.category_struct.id.{v₂ u₂} C
          (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)
          (F X)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  namespace nat_trans</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  def of_homs {I : Type u₁} {F G : discrete I ⥤ C}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57    (f : Π i : discrete I, F.obj i ⟶ G.obj i) : F ⟶ G :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  { app := f }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  def of_function {I : Type u₁} {F G : I → C} (f : Π i : I, F i ⟶ G i) :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61    (functor.of_function F) ⟶ (functor.of_function G) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  of_homs f</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  @[simp] lemma of_function_app {I : Type u₁} {F G : I → C} (f : Π i : I, F i ⟶ G i) (i : I) :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65    (of_function f).app i = f i := rfl</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  end nat_trans</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  namespace nat_iso</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  def of_isos {I : Type u₁} {F G : discrete I ⥤ C}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72    (f : Π i : discrete I, F.obj i ≅ G.obj i) : F ≅ G :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  of_components f (by tidy)</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tidy.lean&#x27;, &#x27;line&#x27;: 91, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → opt_param.{1} tactic.tidy.cfg {trace_result := bool.ff, trace_result_prefix := string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))), tactics := tactic.tidy.default_tactics} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title=' Use a variety of conservative tactics to solve goals.
`tidy?` reports back the tactic script it found.
The default list of tactics is stored in `tactic.tidy.default_tidy_tactics`.
This list can be overridden using `tidy { tactics := ... }`.
(The list must be a `list` of `tactic string`, so that `tidy?`
can report a usable tactic script.) 

Tactics can also be added to the list by tagging them (locally) with the
`[tidy]` attribute.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='tidy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;??&#x27;, &#x27;tactic.tidy.cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  end nat_iso</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  namespace discrete</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  variables {J : Type v₁}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  omit 𝒞</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  def lift {α : Type u₁} {β : Type u₂} (f : α → β) : (discrete α) ⥤ (discrete β) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  functor.of_function f</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  open opposite</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  protected def opposite (α : Type u₁) : (discrete α)ᵒᵖ ≌ discrete α :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  let F : discrete α ⥤ (discrete α)ᵒᵖ := functor.of_function (λ x, op x) in</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90    refine equivalence.mk (functor.left_op F) F _ (nat_iso.of_isos $ λ X, by simp [F]),</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91    refine nat_iso.of_components (λ X, by simp [F]) _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α) (category_theory.discrete_category.{u₁} α) (opposite.{u₁+1} (category_theory.discrete.{u₁} α)) (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α) (category_theory.discrete_category.{u₁} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='lime'><a title='α : Type u₁,
F : @category_theory.functor.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
  (category_theory.discrete_category.{u₁} α)
  (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
  (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
     (category_theory.discrete_category.{u₁} α)) :=
  @category_theory.functor.of_function.{u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
       (category_theory.discrete_category.{u₁} α))
    α
    (λ (x : α), @opposite.op.{u₁+1} (category_theory.discrete.{u₁} α) x)
⊢ @category_theory.iso.{u₁ u₁}
    (@category_theory.functor.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
       (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
          (category_theory.discrete_category.{u₁} α))
       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
       (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
          (category_theory.discrete_category.{u₁} α)))
    (@category_theory.functor.category.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
       (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
          (category_theory.discrete_category.{u₁} α))
       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
       (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
          (category_theory.discrete_category.{u₁} α)))
    (@category_theory.functor.id.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
       (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
          (category_theory.discrete_category.{u₁} α)))
    (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
       (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
          (category_theory.discrete_category.{u₁} α))
       (category_theory.discrete.{u₁} α)
       (category_theory.discrete_category.{u₁} α)
       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
       (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
          (category_theory.discrete_category.{u₁} α))
       (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
          (category_theory.discrete_category.{u₁} α)
          (category_theory.discrete.{u₁} α)
          (category_theory.discrete_category.{u₁} α)
          F)
       F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u₁,
F : @category_theory.functor.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
  (category_theory.discrete_category.{u₁} α)
  (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
  (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
     (category_theory.discrete_category.{u₁} α)) :=
  @category_theory.functor.of_function.{u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
       (category_theory.discrete_category.{u₁} α))
    α
    (λ (x : α), @opposite.op.{u₁+1} (category_theory.discrete.{u₁} α) x),
X : opposite.{u₁+1} (category_theory.discrete.{u₁} α)
⊢ @category_theory.iso.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
       (category_theory.discrete_category.{u₁} α))
    (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
       (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
          (category_theory.discrete_category.{u₁} α))
       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
       (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
          (category_theory.discrete_category.{u₁} α))
       (@category_theory.functor.id.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
          (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
             (category_theory.discrete_category.{u₁} α)))
       X)
    (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
       (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
          (category_theory.discrete_category.{u₁} α))
       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
       (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
          (category_theory.discrete_category.{u₁} α))
       (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
          (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
             (category_theory.discrete_category.{u₁} α))
          (category_theory.discrete.{u₁} α)
          (category_theory.discrete_category.{u₁} α)
          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
          (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
             (category_theory.discrete_category.{u₁} α))
          (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
             (category_theory.discrete_category.{u₁} α)
             (category_theory.discrete.{u₁} α)
             (category_theory.discrete_category.{u₁} α)
             F)
          F)
       X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u₁,
F : @category_theory.functor.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
  (category_theory.discrete_category.{u₁} α)
  (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
  (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
     (category_theory.discrete_category.{u₁} α)) :=
  @category_theory.functor.of_function.{u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
       (category_theory.discrete_category.{u₁} α))
    α
    (λ (x : α), @opposite.op.{u₁+1} (category_theory.discrete.{u₁} α) x)
⊢ @category_theory.iso.{u₁ u₁}
    (@category_theory.functor.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
       (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
          (category_theory.discrete_category.{u₁} α))
       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
       (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
          (category_theory.discrete_category.{u₁} α)))
    (@category_theory.functor.category.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
       (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
          (category_theory.discrete_category.{u₁} α))
       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
       (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
          (category_theory.discrete_category.{u₁} α)))
    (@category_theory.functor.id.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
       (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
          (category_theory.discrete_category.{u₁} α)))
    (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
       (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
          (category_theory.discrete_category.{u₁} α))
       (category_theory.discrete.{u₁} α)
       (category_theory.discrete_category.{u₁} α)
       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
       (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
          (category_theory.discrete_category.{u₁} α))
       (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
          (category_theory.discrete_category.{u₁} α)
          (category_theory.discrete.{u₁} α)
          (category_theory.discrete_category.{u₁} α)
          F)
       F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u₁,
F : @category_theory.functor.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
  (category_theory.discrete_category.{u₁} α)
  (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
  (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
     (category_theory.discrete_category.{u₁} α)) :=
  @category_theory.functor.of_function.{u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
       (category_theory.discrete_category.{u₁} α))
    α
    (λ (x : α), @opposite.op.{u₁+1} (category_theory.discrete.{u₁} α) x)
⊢ ∀ {X Y : opposite.{u₁+1} (category_theory.discrete.{u₁} α)}
  (f :
    @category_theory.has_hom.hom.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
      (@category_theory.category_struct.to_has_hom.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
         (@category_theory.category.to_category_struct.{u₁ u₁}
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))))
      X
      Y),
    @eq.{u₁+1}
      (@category_theory.has_hom.hom.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
         (@category_theory.category_struct.to_has_hom.{u₁ u₁}
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.to_category_struct.{u₁ u₁}
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))))
         (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (@category_theory.functor.id.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)))
            X)
         (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α)
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)
                  (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)
                  F)
               F)
            Y))
      (@category_theory.category_struct.comp.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
         (@category_theory.category.to_category_struct.{u₁ u₁}
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α)))
         (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (@category_theory.functor.id.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)))
            X)
         (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (@category_theory.functor.id.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)))
            Y)
         (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α)
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)
                  (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)
                  F)
               F)
            Y)
         (@category_theory.functor.map.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (@category_theory.functor.id.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)))
            X
            Y
            f)
         (@category_theory.iso.hom.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (@category_theory.functor.id.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                  (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α)))
               Y)
            (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                  (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                  (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α))
                  (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)
                  (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                  (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α))
                  (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α)
                     (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α)
                     F)
                  F)
               Y)
            (@eq.mpr.{u₁+1}
               (@category_theory.iso.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                  (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α))
                  (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                     (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                     (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                        (category_theory.discrete_category.{u₁} α))
                     (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                     (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                        (category_theory.discrete_category.{u₁} α))
                     (@category_theory.functor.id.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                        (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α)))
                     Y)
                  (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                     (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                     (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                        (category_theory.discrete_category.{u₁} α))
                     (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                     (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                        (category_theory.discrete_category.{u₁} α))
                     (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                        (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                        (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α))
                        (category_theory.discrete.{u₁} α)
                        (category_theory.discrete_category.{u₁} α)
                        (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                        (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α))
                        (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α)
                           (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α)
                           F)
                        F)
                     Y))
               (@category_theory.iso.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                  (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α))
                  Y
                  Y)
               (@id.{0}
                  (@eq.{u₁+2} (Type u₁)
                     (@category_theory.iso.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                        (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α))
                        (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                           (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α))
                           (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α))
                           (@category_theory.functor.id.{u₁ u₁}
                              (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                              (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α)))
                           Y)
                        (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                           (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α))
                           (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α))
                           (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                              (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                              (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α))
                              (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α)
                              (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                              (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α))
                              (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                 (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α)
                                 (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α)
                                 F)
                              F)
                           Y))
                     (@category_theory.iso.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                        (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α))
                        Y
                        Y))
                  (@(λ
                    [_inst_1 :
                      category_theory.category.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))]
                    (X X_1 : opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                    (e_2 : @eq.{u₁+1} (opposite.{u₁+1} (category_theory.discrete.{u₁} α)) X X_1)
                    (Y Y_1 : opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                    (e_3 : @eq.{u₁+1} (opposite.{u₁+1} (category_theory.discrete.{u₁} α)) Y Y_1),
                      @congr.{u₁+1 u₁+2} (opposite.{u₁+1} (category_theory.discrete.{u₁} α)) (Type u₁)
                        (@category_theory.iso.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           _inst_1
                           X)
                        (@category_theory.iso.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           _inst_1
                           X_1)
                        Y
                        Y_1
                        (@congr_arg.{u₁+1 u₁+2} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           (opposite.{u₁+1} (category_theory.discrete.{u₁} α) → Type u₁)
                           X
                           X_1
                           (@category_theory.iso.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                              _inst_1)
                           e_2)
                        e_3)
                     (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                        (category_theory.discrete_category.{u₁} α))
                     (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                        (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                        (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α))
                        (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                        (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α))
                        (@category_theory.functor.id.{u₁ u₁}
                           (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α)))
                        Y)
                     Y
                     (@category_theory.functor.id_obj.{u₁ u₁}
                        (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                        (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α))
                        Y)
                     (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                        (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                        (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α))
                        (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                        (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α))
                        (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                           (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α))
                           (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α)
                           (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α))
                           (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α)
                              (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α)
                              F)
                           F)
                        Y)
                     Y
                     (@eq.trans.{u₁+1} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                        (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                           (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α))
                           (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α))
                           (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                              (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                              (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α))
                              (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α)
                              (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                              (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α))
                              (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                 (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α)
                                 (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α)
                                 F)
                              F)
                           Y)
                        (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)
                           (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y))
                        Y
                        (@eq.trans.{u₁+1} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                              (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                              (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α))
                              (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                              (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α))
                              (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                                 (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                 (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α))
                                 (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α)
                                 (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                 (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α))
                                 (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                    (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α)
                                    (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α)
                                    F)
                                 F)
                              Y)
                           (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α)
                              (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                              (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α))
                              (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                 (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                 (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α))
                                 α
                                 (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                              (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y))
                           (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)
                              (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y))
                           (@eq.trans.{u₁+1} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                              (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                 (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                 (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α))
                                 (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                 (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α))
                                 (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α)
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       F)
                                    F)
                                 Y)
                              (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α)
                                 (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                 (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α))
                                 (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    α
                                    (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                 (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α)
                                    (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          α
                                          (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))))
                                    Y))
                              (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α)
                                 (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                 (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α))
                                 (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    α
                                    (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                 (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y))
                              (@eq.trans.{u₁+1} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                 (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          F)
                                       F)
                                    Y)
                                 (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             α
                                             (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))))
                                       (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          α
                                          (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))))
                                    Y)
                                 (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                    (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α)
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       α
                                       (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                    (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             α
                                             (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))))
                                       Y))
                                 ((λ
                                   (c c_1 :
                                     @category_theory.functor.{u₁ u₁ u₁ u₁}
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)))
                                   (e_1 :
                                     @eq.{u₁+1}
                                       (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α)))
                                       c
                                       c_1) (a a_1 : opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                   (e_2 : @eq.{u₁+1} (opposite.{u₁+1} (category_theory.discrete.{u₁} α)) a a_1),
                                     @congr.{u₁+1 u₁+1} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          c)
                                       (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          c_1)
                                       a
                                       a_1
                                       (@congr_arg.{u₁+1 u₁+1}
                                          (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)))
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α) →
                                           opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          c
                                          c_1
                                          (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)))
                                          e_1)
                                       e_2)
                                    (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          F)
                                       F)
                                    (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             α
                                             (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))))
                                       (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          α
                                          (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))))
                                    ((λ
                                      (F F_1 :
                                        @category_theory.functor.{u₁ u₁ u₁ u₁}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                      (e_1 :
                                        @eq.{u₁+1}
                                          (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          F
                                          F_1)
                                      (G G_1 :
                                        @category_theory.functor.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α)))
                                      (e_2 :
                                        @eq.{u₁+1}
                                          (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α)
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)))
                                          G
                                          G_1),
                                        @congr.{u₁+1 u₁+1}
                                          (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α)
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)))
                                          (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)))
                                          (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α)
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             F)
                                          (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α)
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             F_1)
                                          G
                                          G_1
                                          (@congr_arg.{u₁+1 u₁+1}
                                             (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                                (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                                (@category_theory.category.opposite.{u₁ u₁}
                                                   (category_theory.discrete.{u₁} α)
                                                   (category_theory.discrete_category.{u₁} α))
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)
                                                (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                                (@category_theory.category.opposite.{u₁ u₁}
                                                   (category_theory.discrete.{u₁} α)
                                                   (category_theory.discrete_category.{u₁} α)) →
                                              @category_theory.functor.{u₁ u₁ u₁ u₁}
                                                (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                                (@category_theory.category.opposite.{u₁ u₁}
                                                   (category_theory.discrete.{u₁} α)
                                                   (category_theory.discrete_category.{u₁} α))
                                                (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                                (@category_theory.category.opposite.{u₁ u₁}
                                                   (category_theory.discrete.{u₁} α)
                                                   (category_theory.discrete_category.{u₁} α)))
                                             F
                                             F_1
                                             (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                                                (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                                (@category_theory.category.opposite.{u₁ u₁}
                                                   (category_theory.discrete.{u₁} α)
                                                   (category_theory.discrete_category.{u₁} α))
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)
                                                (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                                (@category_theory.category.opposite.{u₁ u₁}
                                                   (category_theory.discrete.{u₁} α)
                                                   (category_theory.discrete_category.{u₁} α)))
                                             e_1)
                                          e_2)
                                       (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          F)
                                       (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             α
                                             (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))))
                                       ((λ
                                         (F F_1 :
                                           @category_theory.functor.{u₁ u₁ u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α)
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)))
                                         (e_1 :
                                           @eq.{u₁+1}
                                             (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)
                                                (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                                (@category_theory.category.opposite.{u₁ u₁}
                                                   (category_theory.discrete.{u₁} α)
                                                   (category_theory.discrete_category.{u₁} α)))
                                             F
                                             F_1),
                                           @congr_arg.{u₁+1 u₁+1}
                                             (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)
                                                (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                                (@category_theory.category.opposite.{u₁ u₁}
                                                   (category_theory.discrete.{u₁} α)
                                                   (category_theory.discrete_category.{u₁} α)))
                                             (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                                (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                                (@category_theory.category.opposite.{u₁ u₁}
                                                   (category_theory.discrete.{u₁} α)
                                                   (category_theory.discrete_category.{u₁} α))
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             F
                                             F_1
                                             (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             e_1)
                                          F
                                          (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             α
                                             (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                          (@eq.refl.{u₁+1}
                                             (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)
                                                (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                                (@category_theory.category.opposite.{u₁ u₁}
                                                   (category_theory.discrete.{u₁} α)
                                                   (category_theory.discrete_category.{u₁} α)))
                                             F))
                                       F
                                       (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          α
                                          (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                       (@eq.refl.{u₁+1}
                                          (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α)
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)))
                                          F))
                                    Y
                                    Y
                                    (@eq.refl.{u₁+1} (opposite.{u₁+1} (category_theory.discrete.{u₁} α)) Y))
                                 (@category_theory.functor.comp_obj.{u₁ u₁ u₁ u₁ u₁ u₁}
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α)
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          α
                                          (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))))
                                    (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       α
                                       (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                    Y))
                              ((λ
                                (c c_1 :
                                  @category_theory.functor.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α)
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)))
                                (e_1 :
                                  @eq.{u₁+1}
                                    (@category_theory.functor.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)))
                                    c
                                    c_1) (a a_1 : category_theory.discrete.{u₁} α)
                                (e_2 : @eq.{u₁+1} (category_theory.discrete.{u₁} α) a a_1),
                                  @congr.{u₁+1 u₁+1} (category_theory.discrete.{u₁} α)
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       c)
                                    (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       c_1)
                                    a
                                    a_1
                                    (@congr_arg.{u₁+1 u₁+1}
                                       (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α)))
                                       (category_theory.discrete.{u₁} α →
                                        opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       c
                                       c_1
                                       (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α)))
                                       e_1)
                                    e_2)
                                 (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    α
                                    (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                 (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    α
                                    (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                 (@eq.refl.{u₁+1}
                                    (@category_theory.functor.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)))
                                    (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       α
                                       (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))))
                                 (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α)
                                    (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          α
                                          (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))))
                                    Y)
                                 (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y)
                                 (@eq.trans.{u₁+1} (category_theory.discrete.{u₁} α)
                                    (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             α
                                             (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))))
                                       Y)
                                    (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α)
                                       (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             α
                                             (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                          (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y)))
                                    (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y)
                                    (@category_theory.functor.left_op_obj.{u₁ u₁ u₁ u₁}
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          α
                                          (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                       Y)
                                    ((λ (a a_1 : opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                      (e_1 :
                                        @eq.{u₁+1} (opposite.{u₁+1} (category_theory.discrete.{u₁} α)) a a_1),
                                        @congr_arg.{u₁+1 u₁+1}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (category_theory.discrete.{u₁} α)
                                          a
                                          a_1
                                          (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α))
                                          e_1)
                                       (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             α
                                             (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                          (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y))
                                       Y
                                       (@eq.trans.{u₁+1} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α)
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                                (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                                (@category_theory.category.opposite.{u₁ u₁}
                                                   (category_theory.discrete.{u₁} α)
                                                   (category_theory.discrete_category.{u₁} α))
                                                α
                                                (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                             (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y))
                                          (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)
                                             (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y))
                                          Y
                                          (@category_theory.functor.of_function_obj.{u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             α
                                             (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y))
                                          (@opposite.op_unop.{u₁+1} (category_theory.discrete.{u₁} α) Y))))))
                           (@category_theory.functor.of_function_obj.{u₁ u₁ u₁}
                              (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                              (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α))
                              α
                              (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))
                              (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y)))
                        (@opposite.op_unop.{u₁+1} (category_theory.discrete.{u₁} α) Y))))
               (@category_theory.iso.refl.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                  (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α))
                  Y))))
      (@category_theory.category_struct.comp.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
         (@category_theory.category.to_category_struct.{u₁ u₁}
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α)))
         (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (@category_theory.functor.id.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)))
            X)
         (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α)
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)
                  (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)
                  F)
               F)
            X)
         (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α)
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)
                  (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)
                  F)
               F)
            Y)
         (@category_theory.iso.hom.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (@category_theory.functor.id.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                  (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α)))
               X)
            (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                  (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                  (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α))
                  (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)
                  (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                  (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α))
                  (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α)
                     (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α)
                     F)
                  F)
               X)
            …)
         …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92    tidy</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tidy.lean&#x27;, &#x27;line&#x27;: 91, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → opt_param.{1} tactic.tidy.cfg {trace_result := bool.ff, trace_result_prefix := string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))), tactics := tactic.tidy.default_tactics} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Use a variety of conservative tactics to solve goals.
`tidy?` reports back the tactic script it found.
The default list of tactics is stored in `tactic.tidy.default_tidy_tactics`.
This list can be overridden using `tidy { tactics := ... }`.
(The list must be a `list` of `tactic string`, so that `tidy?`
can report a usable tactic script.) 

Tactics can also be added to the list by tagging them (locally) with the
`[tidy]` attribute.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='tidy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;??&#x27;, &#x27;tactic.tidy.cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u₁,
F : @category_theory.functor.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
  (category_theory.discrete_category.{u₁} α)
  (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
  (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
     (category_theory.discrete_category.{u₁} α)) :=
  @category_theory.functor.of_function.{u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
       (category_theory.discrete_category.{u₁} α))
    α
    (λ (x : α), @opposite.op.{u₁+1} (category_theory.discrete.{u₁} α) x)
⊢ ∀ {X Y : opposite.{u₁+1} (category_theory.discrete.{u₁} α)}
  (f :
    @category_theory.has_hom.hom.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
      (@category_theory.category_struct.to_has_hom.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
         (@category_theory.category.to_category_struct.{u₁ u₁}
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))))
      X
      Y),
    @eq.{u₁+1}
      (@category_theory.has_hom.hom.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
         (@category_theory.category_struct.to_has_hom.{u₁ u₁}
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.to_category_struct.{u₁ u₁}
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))))
         (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (@category_theory.functor.id.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)))
            X)
         (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α)
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)
                  (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)
                  F)
               F)
            Y))
      (@category_theory.category_struct.comp.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
         (@category_theory.category.to_category_struct.{u₁ u₁}
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α)))
         (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (@category_theory.functor.id.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)))
            X)
         (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (@category_theory.functor.id.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)))
            Y)
         (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α)
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)
                  (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)
                  F)
               F)
            Y)
         (@category_theory.functor.map.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (@category_theory.functor.id.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)))
            X
            Y
            f)
         (@category_theory.iso.hom.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (@category_theory.functor.id.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                  (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α)))
               Y)
            (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                  (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                  (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α))
                  (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)
                  (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                  (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α))
                  (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α)
                     (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α)
                     F)
                  F)
               Y)
            (@eq.mpr.{u₁+1}
               (@category_theory.iso.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                  (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α))
                  (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                     (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                     (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                        (category_theory.discrete_category.{u₁} α))
                     (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                     (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                        (category_theory.discrete_category.{u₁} α))
                     (@category_theory.functor.id.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                        (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α)))
                     Y)
                  (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                     (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                     (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                        (category_theory.discrete_category.{u₁} α))
                     (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                     (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                        (category_theory.discrete_category.{u₁} α))
                     (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                        (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                        (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α))
                        (category_theory.discrete.{u₁} α)
                        (category_theory.discrete_category.{u₁} α)
                        (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                        (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α))
                        (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α)
                           (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α)
                           F)
                        F)
                     Y))
               (@category_theory.iso.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                  (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α))
                  Y
                  Y)
               (@id.{0}
                  (@eq.{u₁+2} (Type u₁)
                     (@category_theory.iso.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                        (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α))
                        (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                           (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α))
                           (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α))
                           (@category_theory.functor.id.{u₁ u₁}
                              (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                              (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α)))
                           Y)
                        (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                           (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α))
                           (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α))
                           (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                              (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                              (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α))
                              (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α)
                              (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                              (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α))
                              (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                 (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α)
                                 (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α)
                                 F)
                              F)
                           Y))
                     (@category_theory.iso.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                        (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α))
                        Y
                        Y))
                  (@(λ
                    [_inst_1 :
                      category_theory.category.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))]
                    (X X_1 : opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                    (e_2 : @eq.{u₁+1} (opposite.{u₁+1} (category_theory.discrete.{u₁} α)) X X_1)
                    (Y Y_1 : opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                    (e_3 : @eq.{u₁+1} (opposite.{u₁+1} (category_theory.discrete.{u₁} α)) Y Y_1),
                      @congr.{u₁+1 u₁+2} (opposite.{u₁+1} (category_theory.discrete.{u₁} α)) (Type u₁)
                        (@category_theory.iso.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           _inst_1
                           X)
                        (@category_theory.iso.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           _inst_1
                           X_1)
                        Y
                        Y_1
                        (@congr_arg.{u₁+1 u₁+2} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           (opposite.{u₁+1} (category_theory.discrete.{u₁} α) → Type u₁)
                           X
                           X_1
                           (@category_theory.iso.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                              _inst_1)
                           e_2)
                        e_3)
                     (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                        (category_theory.discrete_category.{u₁} α))
                     (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                        (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                        (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α))
                        (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                        (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α))
                        (@category_theory.functor.id.{u₁ u₁}
                           (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α)))
                        Y)
                     Y
                     (@category_theory.functor.id_obj.{u₁ u₁}
                        (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                        (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α))
                        Y)
                     (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                        (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                        (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α))
                        (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                        (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α))
                        (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                           (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α))
                           (category_theory.discrete.{u₁} α)
                           (category_theory.discrete_category.{u₁} α)
                           (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α))
                           (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α)
                              (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α)
                              F)
                           F)
                        Y)
                     Y
                     (@eq.trans.{u₁+1} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                        (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                           (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α))
                           (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α))
                           (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                              (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                              (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α))
                              (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α)
                              (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                              (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α))
                              (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                 (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α)
                                 (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α)
                                 F)
                              F)
                           Y)
                        (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)
                           (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y))
                        Y
                        (@eq.trans.{u₁+1} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                           (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                              (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                              (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α))
                              (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                              (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α))
                              (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                                 (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                 (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α))
                                 (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α)
                                 (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                 (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α))
                                 (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                    (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α)
                                    (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α)
                                    F)
                                 F)
                              Y)
                           (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                              (category_theory.discrete_category.{u₁} α)
                              (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                              (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α))
                              (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                 (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                 (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α))
                                 α
                                 (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                              (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y))
                           (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)
                              (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y))
                           (@eq.trans.{u₁+1} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                              (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                 (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                 (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α))
                                 (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                 (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α))
                                 (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α)
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       F)
                                    F)
                                 Y)
                              (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α)
                                 (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                 (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α))
                                 (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    α
                                    (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                 (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α)
                                    (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          α
                                          (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))))
                                    Y))
                              (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α)
                                 (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                 (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α))
                                 (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    α
                                    (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                 (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y))
                              (@eq.trans.{u₁+1} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                 (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          F)
                                       F)
                                    Y)
                                 (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             α
                                             (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))))
                                       (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          α
                                          (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))))
                                    Y)
                                 (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                    (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α)
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       α
                                       (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                    (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             α
                                             (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))))
                                       Y))
                                 ((λ
                                   (c c_1 :
                                     @category_theory.functor.{u₁ u₁ u₁ u₁}
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)))
                                   (e_1 :
                                     @eq.{u₁+1}
                                       (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α)))
                                       c
                                       c_1) (a a_1 : opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                   (e_2 : @eq.{u₁+1} (opposite.{u₁+1} (category_theory.discrete.{u₁} α)) a a_1),
                                     @congr.{u₁+1 u₁+1} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          c)
                                       (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          c_1)
                                       a
                                       a_1
                                       (@congr_arg.{u₁+1 u₁+1}
                                          (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)))
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α) →
                                           opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          c
                                          c_1
                                          (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)))
                                          e_1)
                                       e_2)
                                    (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          F)
                                       F)
                                    (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             α
                                             (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))))
                                       (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          α
                                          (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))))
                                    ((λ
                                      (F F_1 :
                                        @category_theory.functor.{u₁ u₁ u₁ u₁}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                      (e_1 :
                                        @eq.{u₁+1}
                                          (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          F
                                          F_1)
                                      (G G_1 :
                                        @category_theory.functor.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α)))
                                      (e_2 :
                                        @eq.{u₁+1}
                                          (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α)
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)))
                                          G
                                          G_1),
                                        @congr.{u₁+1 u₁+1}
                                          (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α)
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)))
                                          (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)))
                                          (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α)
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             F)
                                          (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α)
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             F_1)
                                          G
                                          G_1
                                          (@congr_arg.{u₁+1 u₁+1}
                                             (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                                (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                                (@category_theory.category.opposite.{u₁ u₁}
                                                   (category_theory.discrete.{u₁} α)
                                                   (category_theory.discrete_category.{u₁} α))
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)
                                                (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                                (@category_theory.category.opposite.{u₁ u₁}
                                                   (category_theory.discrete.{u₁} α)
                                                   (category_theory.discrete_category.{u₁} α)) →
                                              @category_theory.functor.{u₁ u₁ u₁ u₁}
                                                (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                                (@category_theory.category.opposite.{u₁ u₁}
                                                   (category_theory.discrete.{u₁} α)
                                                   (category_theory.discrete_category.{u₁} α))
                                                (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                                (@category_theory.category.opposite.{u₁ u₁}
                                                   (category_theory.discrete.{u₁} α)
                                                   (category_theory.discrete_category.{u₁} α)))
                                             F
                                             F_1
                                             (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                                                (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                                (@category_theory.category.opposite.{u₁ u₁}
                                                   (category_theory.discrete.{u₁} α)
                                                   (category_theory.discrete_category.{u₁} α))
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)
                                                (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                                (@category_theory.category.opposite.{u₁ u₁}
                                                   (category_theory.discrete.{u₁} α)
                                                   (category_theory.discrete_category.{u₁} α)))
                                             e_1)
                                          e_2)
                                       (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          F)
                                       (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             α
                                             (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))))
                                       ((λ
                                         (F F_1 :
                                           @category_theory.functor.{u₁ u₁ u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α)
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)))
                                         (e_1 :
                                           @eq.{u₁+1}
                                             (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)
                                                (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                                (@category_theory.category.opposite.{u₁ u₁}
                                                   (category_theory.discrete.{u₁} α)
                                                   (category_theory.discrete_category.{u₁} α)))
                                             F
                                             F_1),
                                           @congr_arg.{u₁+1 u₁+1}
                                             (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)
                                                (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                                (@category_theory.category.opposite.{u₁ u₁}
                                                   (category_theory.discrete.{u₁} α)
                                                   (category_theory.discrete_category.{u₁} α)))
                                             (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                                (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                                (@category_theory.category.opposite.{u₁ u₁}
                                                   (category_theory.discrete.{u₁} α)
                                                   (category_theory.discrete_category.{u₁} α))
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             F
                                             F_1
                                             (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             e_1)
                                          F
                                          (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             α
                                             (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                          (@eq.refl.{u₁+1}
                                             (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)
                                                (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                                (@category_theory.category.opposite.{u₁ u₁}
                                                   (category_theory.discrete.{u₁} α)
                                                   (category_theory.discrete_category.{u₁} α)))
                                             F))
                                       F
                                       (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          α
                                          (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                       (@eq.refl.{u₁+1}
                                          (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α)
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α)))
                                          F))
                                    Y
                                    Y
                                    (@eq.refl.{u₁+1} (opposite.{u₁+1} (category_theory.discrete.{u₁} α)) Y))
                                 (@category_theory.functor.comp_obj.{u₁ u₁ u₁ u₁ u₁ u₁}
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α)
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          α
                                          (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))))
                                    (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       α
                                       (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                    Y))
                              ((λ
                                (c c_1 :
                                  @category_theory.functor.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α)
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)))
                                (e_1 :
                                  @eq.{u₁+1}
                                    (@category_theory.functor.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)))
                                    c
                                    c_1) (a a_1 : category_theory.discrete.{u₁} α)
                                (e_2 : @eq.{u₁+1} (category_theory.discrete.{u₁} α) a a_1),
                                  @congr.{u₁+1 u₁+1} (category_theory.discrete.{u₁} α)
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       c)
                                    (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       c_1)
                                    a
                                    a_1
                                    (@congr_arg.{u₁+1 u₁+1}
                                       (@category_theory.functor.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α)))
                                       (category_theory.discrete.{u₁} α →
                                        opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       c
                                       c_1
                                       (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α)))
                                       e_1)
                                    e_2)
                                 (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    α
                                    (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                 (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    α
                                    (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                 (@eq.refl.{u₁+1}
                                    (@category_theory.functor.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)))
                                    (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       α
                                       (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))))
                                 (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                    (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                    (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α))
                                    (category_theory.discrete.{u₁} α)
                                    (category_theory.discrete_category.{u₁} α)
                                    (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          α
                                          (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))))
                                    Y)
                                 (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y)
                                 (@eq.trans.{u₁+1} (category_theory.discrete.{u₁} α)
                                    (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                       (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                       (@category_theory.category.opposite.{u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α))
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             α
                                             (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))))
                                       Y)
                                    (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α)
                                       (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             α
                                             (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                          (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y)))
                                    (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y)
                                    (@category_theory.functor.left_op_obj.{u₁ u₁ u₁ u₁}
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (category_theory.discrete.{u₁} α)
                                       (category_theory.discrete_category.{u₁} α)
                                       (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          α
                                          (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                       Y)
                                    ((λ (a a_1 : opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                      (e_1 :
                                        @eq.{u₁+1} (opposite.{u₁+1} (category_theory.discrete.{u₁} α)) a a_1),
                                        @congr_arg.{u₁+1 u₁+1}
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (category_theory.discrete.{u₁} α)
                                          a
                                          a_1
                                          (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α))
                                          e_1)
                                       (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                          (category_theory.discrete.{u₁} α)
                                          (category_theory.discrete_category.{u₁} α)
                                          (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.category.opposite.{u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α))
                                          (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             α
                                             (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                          (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y))
                                       Y
                                       (@eq.trans.{u₁+1} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                          (@category_theory.functor.obj.{u₁ u₁ u₁ u₁}
                                             (category_theory.discrete.{u₁} α)
                                             (category_theory.discrete_category.{u₁} α)
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             (@category_theory.functor.of_function.{u₁ u₁ u₁}
                                                (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                                (@category_theory.category.opposite.{u₁ u₁}
                                                   (category_theory.discrete.{u₁} α)
                                                   (category_theory.discrete_category.{u₁} α))
                                                α
                                                (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)))
                                             (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y))
                                          (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α)
                                             (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y))
                                          Y
                                          (@category_theory.functor.of_function_obj.{u₁ u₁ u₁}
                                             (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@category_theory.category.opposite.{u₁ u₁}
                                                (category_theory.discrete.{u₁} α)
                                                (category_theory.discrete_category.{u₁} α))
                                             α
                                             (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))
                                             (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y))
                                          (@opposite.op_unop.{u₁+1} (category_theory.discrete.{u₁} α) Y))))))
                           (@category_theory.functor.of_function_obj.{u₁ u₁ u₁}
                              (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                              (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                                 (category_theory.discrete_category.{u₁} α))
                              α
                              (@opposite.op.{u₁+1} (category_theory.discrete.{u₁} α))
                              (@opposite.unop.{u₁+1} (category_theory.discrete.{u₁} α) Y)))
                        (@opposite.op_unop.{u₁+1} (category_theory.discrete.{u₁} α) Y))))
               (@category_theory.iso.refl.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                  (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α))
                  Y))))
      (@category_theory.category_struct.comp.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
         (@category_theory.category.to_category_struct.{u₁ u₁}
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α)))
         (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (@category_theory.functor.id.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)))
            X)
         (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α)
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)
                  (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)
                  F)
               F)
            X)
         (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α)
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)
                  (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)
                  F)
               F)
            Y)
         (@category_theory.iso.hom.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
            (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
               (category_theory.discrete_category.{u₁} α))
            (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (@category_theory.functor.id.{u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                  (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α)))
               X)
            (@category_theory.functor.obj.{u₁ u₁ u₁ u₁} (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
               (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α))
               (@category_theory.functor.comp.{u₁ u₁ u₁ u₁ u₁ u₁}
                  (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                  (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α))
                  (category_theory.discrete.{u₁} α)
                  (category_theory.discrete_category.{u₁} α)
                  (opposite.{u₁+1} (category_theory.discrete.{u₁} α))
                  (@category_theory.category.opposite.{u₁ u₁} (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α))
                  (@category_theory.functor.left_op.{u₁ u₁ u₁ u₁} (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α)
                     (category_theory.discrete.{u₁} α)
                     (category_theory.discrete_category.{u₁} α)
                     F)
                  F)
               X)
            …)
         …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  include 𝒞</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  @[simp] lemma functor_map_id</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98    (F : discrete J ⥤ C) {j : discrete J} (f : j ⟶ j) : F.map f = 𝟙 (F.obj j) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.discrete'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.discrete'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 14, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type v₁) [_inst_1 : category_theory.category.{v₁ v₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ v₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='category_theory.discrete.{v₁} J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type v₁} [c : category_theory.has_hom.{v₁ v₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.discrete.{v₁} J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J) (category_theory.discrete_category.{v₁} J) C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v₁} [_inst_1 : category_theory.category.{v₁ v₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ v₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ v₁} C (@category_theory.category_struct.to_has_hom.{v₁ v₁} C (@category_theory.category.to_category_struct.{v₁ v₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J) (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J) (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J) (category_theory.discrete_category.{v₁} J))) j j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] (X : obj), @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J) (category_theory.discrete_category.{v₁} J) C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type v₁} [_inst_1 : category_theory.category.{v₁ v₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ v₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='category_theory.discrete.{v₁} J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₂,
𝒞 : category_theory.category.{v₂ u₂} C,
J : Type v₁,
F :
  @category_theory.functor.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
    (category_theory.discrete_category.{v₁} J)
    C
    𝒞,
j : category_theory.discrete.{v₁} J,
f :
  @category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
    (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)))
    j
    j
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} C
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} C
          (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j)
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j))
    (@category_theory.functor.map.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
       (category_theory.discrete_category.{v₁} J)
       C
       𝒞
       F
       j
       j
       f)
    (@category_theory.category_struct.id.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100    have h : f = 𝟙 j, cases f, cases f, ext,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J) (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J) (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J) (category_theory.discrete_category.{v₁} J))) j j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {obj : Type v₁} [c : category_theory.category_struct.{v₁ v₁} obj] (X : obj), @category_theory.has_hom.hom.{v₁ v₁} obj (@category_theory.category_struct.to_has_hom.{v₁ v₁} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='category_theory.discrete.{v₁} J'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J) (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J) (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J) (category_theory.discrete_category.{v₁} J))) j j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='plift.{0} (@eq.{v₁+1} (category_theory.discrete.{v₁} J) j j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₂,
𝒞 : category_theory.category.{v₂ u₂} C,
J : Type v₁,
F :
  @category_theory.functor.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
    (category_theory.discrete_category.{v₁} J)
    C
    𝒞,
j : category_theory.discrete.{v₁} J,
f :
  @category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
    (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)))
    j
    j
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} C
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} C
          (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j)
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j))
    (@category_theory.functor.map.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
       (category_theory.discrete_category.{v₁} J)
       C
       𝒞
       F
       j
       j
       f)
    (@category_theory.category_struct.id.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type u₂,
𝒞 : category_theory.category.{v₂ u₂} C,
J : Type v₁,
F :
  @category_theory.functor.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
    (category_theory.discrete_category.{v₁} J)
    C
    𝒞,
j : category_theory.discrete.{v₁} J,
f :
  @category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
    (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)))
    j
    j
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
             (category_theory.discrete_category.{v₁} J)))
       j
       j)
    f
    (@category_theory.category_struct.id.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J))
       j)

C : Type u₂,
𝒞 : category_theory.category.{v₂ u₂} C,
J : Type v₁,
F :
  @category_theory.functor.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
    (category_theory.discrete_category.{v₁} J)
    C
    𝒞,
j : category_theory.discrete.{v₁} J,
f :
  @category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
    (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)))
    j
    j,
h :
  @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
             (category_theory.discrete_category.{v₁} J)))
       j
       j)
    f
    (@category_theory.category_struct.id.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J))
       j)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} C
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} C
          (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j)
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j))
    (@category_theory.functor.map.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
       (category_theory.discrete_category.{v₁} J)
       C
       𝒞
       F
       j
       j
       f)
    (@category_theory.category_struct.id.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type u₂,
𝒞 : category_theory.category.{v₂ u₂} C,
J : Type v₁,
F :
  @category_theory.functor.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
    (category_theory.discrete_category.{v₁} J)
    C
    𝒞,
j : category_theory.discrete.{v₁} J,
f : plift.{0} (@eq.{v₁+1} (category_theory.discrete.{v₁} J) j j)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
             (category_theory.discrete_category.{v₁} J)))
       j
       j)
    (@ulift.up.{v₁ 0} (plift.{0} (@eq.{v₁+1} (category_theory.discrete.{v₁} J) j j)) f)
    (@category_theory.category_struct.id.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J))
       j)

C : Type u₂,
𝒞 : category_theory.category.{v₂ u₂} C,
J : Type v₁,
F :
  @category_theory.functor.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
    (category_theory.discrete_category.{v₁} J)
    C
    𝒞,
j : category_theory.discrete.{v₁} J,
f :
  @category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
    (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)))
    j
    j,
h :
  @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
             (category_theory.discrete_category.{v₁} J)))
       j
       j)
    f
    (@category_theory.category_struct.id.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J))
       j)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} C
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} C
          (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j)
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j))
    (@category_theory.functor.map.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
       (category_theory.discrete_category.{v₁} J)
       C
       𝒞
       F
       j
       j
       f)
    (@category_theory.category_struct.id.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type u₂,
𝒞 : category_theory.category.{v₂ u₂} C,
J : Type v₁,
F :
  @category_theory.functor.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
    (category_theory.discrete_category.{v₁} J)
    C
    𝒞,
j : category_theory.discrete.{v₁} J,
f : @eq.{v₁+1} (category_theory.discrete.{v₁} J) j j
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
             (category_theory.discrete_category.{v₁} J)))
       j
       j)
    (@ulift.up.{v₁ 0} (plift.{0} (@eq.{v₁+1} (category_theory.discrete.{v₁} J) j j))
       (@plift.up.{0} (@eq.{v₁+1} (category_theory.discrete.{v₁} J) j j) f))
    (@category_theory.category_struct.id.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J))
       j)

C : Type u₂,
𝒞 : category_theory.category.{v₂ u₂} C,
J : Type v₁,
F :
  @category_theory.functor.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
    (category_theory.discrete_category.{v₁} J)
    C
    𝒞,
j : category_theory.discrete.{v₁} J,
f :
  @category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
    (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)))
    j
    j,
h :
  @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
             (category_theory.discrete_category.{v₁} J)))
       j
       j)
    f
    (@category_theory.category_struct.id.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J))
       j)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} C
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} C
          (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j)
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j))
    (@category_theory.functor.map.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
       (category_theory.discrete_category.{v₁} J)
       C
       𝒞
       F
       j
       j
       f)
    (@category_theory.category_struct.id.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₂,
𝒞 : category_theory.category.{v₂ u₂} C,
J : Type v₁,
F :
  @category_theory.functor.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
    (category_theory.discrete_category.{v₁} J)
    C
    𝒞,
j : category_theory.discrete.{v₁} J,
f :
  @category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
    (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)))
    j
    j,
h :
  @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
             (category_theory.discrete_category.{v₁} J)))
       j
       j)
    f
    (@category_theory.category_struct.id.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J))
       j)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} C
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} C
          (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j)
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j))
    (@category_theory.functor.map.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
       (category_theory.discrete_category.{v₁} J)
       C
       𝒞
       F
       j
       j
       f)
    (@category_theory.category_struct.id.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101    rw h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J) (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J) (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J) (category_theory.discrete_category.{v₁} J))) j j) f (@category_theory.category_struct.id.{v₁ v₁} (category_theory.discrete.{v₁} J) (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J) (category_theory.discrete_category.{v₁} J)) j)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₂,
𝒞 : category_theory.category.{v₂ u₂} C,
J : Type v₁,
F :
  @category_theory.functor.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
    (category_theory.discrete_category.{v₁} J)
    C
    𝒞,
j : category_theory.discrete.{v₁} J,
f :
  @category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
    (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)))
    j
    j,
h :
  @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
             (category_theory.discrete_category.{v₁} J)))
       j
       j)
    f
    (@category_theory.category_struct.id.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J))
       j)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} C
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} C
          (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j)
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j))
    (@category_theory.functor.map.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
       (category_theory.discrete_category.{v₁} J)
       C
       𝒞
       F
       j
       j
       f)
    (@category_theory.category_struct.id.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₂,
𝒞 : category_theory.category.{v₂ u₂} C,
J : Type v₁,
F :
  @category_theory.functor.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
    (category_theory.discrete_category.{v₁} J)
    C
    𝒞,
j : category_theory.discrete.{v₁} J,
f :
  @category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
    (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)))
    j
    j,
h :
  @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
             (category_theory.discrete_category.{v₁} J)))
       j
       j)
    f
    (@category_theory.category_struct.id.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J))
       j)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} C
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} C
          (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j)
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j))
    (@category_theory.functor.map.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
       (category_theory.discrete_category.{v₁} J)
       C
       𝒞
       F
       j
       j
       (@category_theory.category_struct.id.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
             (category_theory.discrete_category.{v₁} J))
          j))
    (@category_theory.category_struct.id.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102    simp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₂,
𝒞 : category_theory.category.{v₂ u₂} C,
J : Type v₁,
F :
  @category_theory.functor.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
    (category_theory.discrete_category.{v₁} J)
    C
    𝒞,
j : category_theory.discrete.{v₁} J,
f :
  @category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
    (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)))
    j
    j,
h :
  @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category_struct.to_has_hom.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
             (category_theory.discrete_category.{v₁} J)))
       j
       j)
    f
    (@category_theory.category_struct.id.{v₁ v₁} (category_theory.discrete.{v₁} J)
       (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J))
       j)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} C
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} C
          (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j)
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j))
    (@category_theory.functor.map.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
       (category_theory.discrete_category.{v₁} J)
       C
       𝒞
       F
       j
       j
       (@category_theory.category_struct.id.{v₁ v₁} (category_theory.discrete.{v₁} J)
          (@category_theory.category.to_category_struct.{v₁ v₁} (category_theory.discrete.{v₁} J)
             (category_theory.discrete_category.{v₁} J))
          j))
    (@category_theory.category_struct.id.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₂ v₁ u₂} (category_theory.discrete.{v₁} J)
          (category_theory.discrete_category.{v₁} J)
          C
          𝒞
          F
          j))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  end discrete</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  end category_theory</code></pre>
</body>